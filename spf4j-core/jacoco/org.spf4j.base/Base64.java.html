<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Base64.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.base</a> &gt; <span class="el_source">Base64.java</span></div><h1>Base64.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.base;

import java.io.IOException;
import java.nio.CharBuffer;

/**
 * &quot;improved&quot; implementation based on DataTypeConverterImpl performance should be same/slightly faster than the JDK
 * equivalent But most importantly you can encode/decode parts of a String, which should reduce the need of copying
 * objects and reduce the amount of garbage created.
 *
 * @author zoly
 */
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">public final class Base64 {</span>

<span class="fc" id="L46">  private static final byte[] DECODE_MAP = initDecodeMap();</span>

<span class="fc" id="L48">  private static final char[] ENCODE_MAP = initEncodeMap();</span>

  private static final byte PADDING = 127;

  private Base64() {
  }

  private static byte[] initDecodeMap() {
<span class="fc" id="L56">    byte[] map = new byte[128];</span>
    int i;
<span class="fc bfc" id="L58" title="All 2 branches covered.">    for (i = 0; i &lt; 128; i++) {</span>
<span class="fc" id="L59">      map[i] = -1;</span>
    }

<span class="fc bfc" id="L62" title="All 2 branches covered.">    for (i = 'A'; i &lt;= 'Z'; i++) {</span>
<span class="fc" id="L63">      map[i] = (byte) (i - 'A');</span>
    }
<span class="fc bfc" id="L65" title="All 2 branches covered.">    for (i = 'a'; i &lt;= 'z'; i++) {</span>
<span class="fc" id="L66">      map[i] = (byte) (i - 'a' + 26);</span>
    }
<span class="fc bfc" id="L68" title="All 2 branches covered.">    for (i = '0'; i &lt;= '9'; i++) {</span>
<span class="fc" id="L69">      map[i] = (byte) (i - '0' + 52);</span>
    }
<span class="fc" id="L71">    map['+'] = 62;</span>
<span class="fc" id="L72">    map['/'] = 63;</span>
<span class="fc" id="L73">    map['='] = PADDING;</span>

<span class="fc" id="L75">    return map;</span>
  }

  /**
   * computes the length of binary data speculatively.
   *
   * &lt;p&gt;
   * Our requirement is to create byte[] of the exact length to store the binary data. If we do this in a
   * straight-forward way, it takes two passes over the data. Experiments show that this is a non-trivial overhead (35%
   * or so is spent on the first pass in calculating the length.)
   *
   * &lt;p&gt;
   * So the approach here is that we compute the length speculatively, without looking at the whole contents. The
   * obtained speculative value is never less than the actual length of the binary data, but it may be bigger. So if the
   * speculation goes wrong, we'll pay the cost of reallocation and buffer copying.
   *
   * &lt;p&gt;
   * If the base64 text is tightly packed with no indentation nor illegal char (like what most web services produce),
   * then the speculation of this method will be correct, so we get the performance benefit.
   */
  private static int guessLength2(final CharSequence text, final int from, final int to) {
    // compute the tail '=' chars
<span class="fc" id="L97">    int j = to - 1;</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">    for (; j &gt;= 0; j--) {</span>
<span class="fc" id="L99">      byte code = DECODE_MAP[text.charAt(j)];</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">      if (code != PADDING) {</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (code == -1) { // most likely this base64 text is indented. go with the upper bound</span>
<span class="nc" id="L102">          return (to - from) / 4 * 3;</span>
        }
        break;
      }
    }

<span class="fc" id="L108">    j++;    // text.charAt(j) is now at some base64 char, so +1 to make it the size</span>
<span class="fc" id="L109">    int padSize = to - j;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">    if (padSize &gt; 2) { // something is wrong with base64. be safe and go with the upper bound</span>
<span class="nc" id="L111">      return (to - from) / 4 * 3;</span>
    }

    // so far this base64 looks like it's unindented tightly packed base64.
    // take a chance and create an array with the expected size
<span class="fc" id="L116">    return (to - from) / 4 * 3 - padSize;</span>
  }




  private static int guessLength(final char[] text, final int from, final int len) {
<span class="nc" id="L123">    final int to = from + len;</span>

    // compute the tail '=' chars
<span class="nc" id="L126">    int j = to - 1;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    for (; j &gt;= 0; j--) {</span>
<span class="nc" id="L128">      byte code = DECODE_MAP[text[j]];</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      if (code != PADDING) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (code == -1) { // most likely this base64 text is indented. go with the upper bound</span>
<span class="nc" id="L131">          return len / 4 * 3;</span>
        }
        break;
      }
    }

<span class="nc" id="L137">    j++;    // text.charAt(j) is now at some base64 char, so +1 to make it the size</span>
<span class="nc" id="L138">    int padSize = to - j;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (padSize &gt; 2) { // something is wrong with base64. be safe and go with the upper bound</span>
<span class="nc" id="L140">      return len / 4 * 3;</span>
    }

    // so far this base64 looks like it's unindented tightly packed base64.
    // take a chance and create an array with the expected size
<span class="nc" id="L145">    return len / 4 * 3 - padSize;</span>
  }

  public static byte[] decodeBase64(final CharSequence text) {
<span class="nc" id="L149">    return Base64.decodeBase64(text, 0, text.length());</span>
  }

  public static byte[] decodeBase64(final String text) {
<span class="fc" id="L153">    return Base64.decodeBase64(text, 0, text.length());</span>
  }

  public static byte[] decodeBase64(final String text, final int from, final int length) {
<span class="fc" id="L157">    return decodeBase64((CharSequence) text, from, length);</span>
  }

  public static byte[] decodeBase64V2(final String text, final int from, final int length) {
<span class="nc" id="L161">    char[] steal = Strings.steal(text);</span>
<span class="nc" id="L162">    return decodeBase64(steal, from, length);</span>
  }

  /**
   * @param text base64Binary data is likely to be long, and decoding requires each character to be accessed twice (once
   * for counting length, another for decoding.)
   * @param from the index of the first character in the sequence.
   * @param len - the number of characters to decode.
   * @return - the decoded byte array.
   *
   */
  public static byte[] decodeBase64(final CharSequence text, final int from, final int len) {
<span class="fc" id="L174">    final int buflen = guessLength2(text, from, from + len);</span>
<span class="fc" id="L175">    final byte[] out = new byte[buflen];</span>
<span class="fc" id="L176">    int o = decodeInto(text, from, len, out, 0);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    if (buflen == o) { // speculation worked out to be OK</span>
<span class="fc" id="L178">      return out;</span>
    }

    // we overestimated, so need to create a new buffer
<span class="nc" id="L182">    byte[] nb = new byte[o];</span>
<span class="nc" id="L183">    System.arraycopy(out, 0, nb, 0, o);</span>
<span class="nc" id="L184">    return nb;</span>
  }

  public static byte[] decodeBase64V2(final CharSequence text, final int from, final int to) {
<span class="nc" id="L188">    final int buflen = guessLength2(text, from, to);</span>
<span class="nc" id="L189">    final byte[] out = new byte[buflen];</span>
<span class="nc" id="L190">    int o = decodeInto2(text, from, to, out, 0);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">    if (buflen == o) { // speculation worked out to be OK</span>
<span class="nc" id="L192">      return out;</span>
    }

    // we overestimated, so need to create a new buffer
<span class="nc" id="L196">    byte[] nb = new byte[o];</span>
<span class="nc" id="L197">    System.arraycopy(out, 0, nb, 0, o);</span>
<span class="nc" id="L198">    return nb;</span>
  }

  public static int decodeInto(final CharSequence text, final int from, final int len,
          final byte[] out, final int outStartIdx) {
<span class="fc" id="L203">    return decodeInto2(text, from, from + len, out, outStartIdx);</span>
  }

  public static int decodeInto2(final CharSequence text, final int from, final int to,
          final byte[] out, final int outStartIdx) {
<span class="fc" id="L208">    int o = outStartIdx;</span>
    int i;
<span class="fc" id="L210">    final byte[] quadruplet = new byte[4];</span>
<span class="fc" id="L211">    int q = 0;</span>
    // convert each quadruplet to three bytes.
<span class="fc bfc" id="L213" title="All 2 branches covered.">    for (i = from; i &lt; to; i++) {</span>
<span class="fc" id="L214">      char ch = text.charAt(i);</span>
<span class="fc" id="L215">      byte v = DECODE_MAP[ch];</span>

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (v != -1) {</span>
<span class="fc" id="L218">        quadruplet[q++] = v;</span>
      }

<span class="fc bfc" id="L221" title="All 2 branches covered.">      if (q == 4) {</span>
        // quadruplet is now filled.
<span class="fc" id="L223">        out[o++] = (byte) ((quadruplet[0] &lt;&lt; 2) | (quadruplet[1] &gt;&gt; 4));</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (quadruplet[2] != PADDING) {</span>
<span class="fc" id="L225">          out[o++] = (byte) ((quadruplet[1] &lt;&lt; 4) | (quadruplet[2] &gt;&gt; 2));</span>
        }
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (quadruplet[3] != PADDING) {</span>
<span class="fc" id="L228">          out[o++] = (byte) ((quadruplet[2] &lt;&lt; 6) | (quadruplet[3]));</span>
        }
<span class="fc" id="L230">        q = 0;</span>
      }
    }
<span class="fc" id="L233">    return o;</span>
  }

  public static byte[] decodeBase64(final char[] text, final int from, final int len) {
<span class="nc" id="L237">    final int buflen = guessLength(text, from, len);</span>
<span class="nc" id="L238">    final byte[] out = new byte[buflen];</span>
<span class="nc" id="L239">    int o = 0;</span>

    int i;

<span class="nc" id="L243">    final byte[] quadruplet = new byte[4];</span>
<span class="nc" id="L244">    int q = 0;</span>

    // convert each quadruplet to three bytes.
<span class="nc" id="L247">    int to = from + len;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">    for (i = from; i &lt; to; i++) {</span>
<span class="nc" id="L249">      char ch = text[i];</span>
<span class="nc" id="L250">      byte v = DECODE_MAP[ch];</span>

<span class="nc bnc" id="L252" title="All 2 branches missed.">      if (v != -1) {</span>
<span class="nc" id="L253">        quadruplet[q++] = v;</span>
      }

<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (q == 4) {</span>
        // quadruplet is now filled.
<span class="nc" id="L258">        out[o++] = (byte) ((quadruplet[0] &lt;&lt; 2) | (quadruplet[1] &gt;&gt; 4));</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (quadruplet[2] != PADDING) {</span>
<span class="nc" id="L260">          out[o++] = (byte) ((quadruplet[1] &lt;&lt; 4) | (quadruplet[2] &gt;&gt; 2));</span>
        }
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (quadruplet[3] != PADDING) {</span>
<span class="nc" id="L263">          out[o++] = (byte) ((quadruplet[2] &lt;&lt; 6) | (quadruplet[3]));</span>
        }
<span class="nc" id="L265">        q = 0;</span>
      }
    }

<span class="nc bnc" id="L269" title="All 2 branches missed.">    if (buflen == o) { // speculation worked out to be OK</span>
<span class="nc" id="L270">      return out;</span>
    }

    // we overestimated, so need to create a new buffer
<span class="nc" id="L274">    byte[] nb = new byte[o];</span>
<span class="nc" id="L275">    System.arraycopy(out, 0, nb, 0, o);</span>
<span class="nc" id="L276">    return nb;</span>
  }

  private static char[] initEncodeMap() {
<span class="fc" id="L280">    char[] map = new char[64];</span>
    int i;
<span class="fc bfc" id="L282" title="All 2 branches covered.">    for (i = 0; i &lt; 26; i++) {</span>
<span class="fc" id="L283">      map[i] = (char) ('A' + i);</span>
    }
<span class="fc bfc" id="L285" title="All 2 branches covered.">    for (i = 26; i &lt; 52; i++) {</span>
<span class="fc" id="L286">      map[i] = (char) ('a' + (i - 26));</span>
    }
<span class="fc bfc" id="L288" title="All 2 branches covered.">    for (i = 52; i &lt; 62; i++) {</span>
<span class="fc" id="L289">      map[i] = (char) ('0' + (i - 52));</span>
    }
<span class="fc" id="L291">    map[62] = '+';</span>
<span class="fc" id="L292">    map[63] = '/';</span>

<span class="fc" id="L294">    return map;</span>
  }

  public static char encode(final int i) {
<span class="fc" id="L298">    return ENCODE_MAP[i &amp; 0x3F];</span>
  }

  public static byte encodeByte(final int i) {
<span class="nc" id="L302">    return (byte) ENCODE_MAP[i &amp; 0x3F];</span>
  }

  public static String encodeBase64(final byte[] input) {
<span class="fc" id="L306">    return encodeBase64(input, 0, input.length);</span>
  }

  public static String encodeBase64(final byte[] input, final int offset, final int len) {
<span class="fc" id="L310">    char[] buf = TLScratch.getCharsTmp((((len + 2) / 3) * 4));</span>
<span class="fc" id="L311">    int ptr = encodeBase64(input, offset, len, buf, 0);</span>
<span class="fc" id="L312">    return new String(buf, 0, ptr);</span>
  }

  /**
   * Alternate implementation, should be better for large data.
   *
   * @param input - the byte array to encode
   * @param offset - the index of the first byte that is to be encoded.
   * @param len - the number of bytes to encode.
   * @return - the encoded String.
   */
  public static CharSequence encodeBase64V2(final byte[] input, final int offset, final int len) {
<span class="nc" id="L324">    char[] buf = new char[(((len + 2) / 3) * 4)];</span>
<span class="nc" id="L325">    int ptr = encodeBase64(input, offset, len, buf, 0);</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">    assert ptr == buf.length;</span>
<span class="nc" id="L327">    return CharBuffer.wrap(buf);</span>
  }

  public static void encodeBase64(final byte[] input, final int offset, final int len, final Appendable result)
          throws IOException {
<span class="nc bnc" id="L332" title="All 2 branches missed.">    for (int i = offset; i &lt; len; i += 3) {</span>
<span class="nc bnc" id="L333" title="All 3 branches missed.">      switch (len - i) {</span>
        case 1:
<span class="nc" id="L335">          result.append(encode(input[i] &gt;&gt; 2));</span>
<span class="nc" id="L336">          result.append(encode(((input[i]) &amp; 0x3) &lt;&lt; 4));</span>
<span class="nc" id="L337">          result.append(&quot;==&quot;);</span>
<span class="nc" id="L338">          break;</span>
        case 2:
<span class="nc" id="L340">          result.append(encode(input[i] &gt;&gt; 2));</span>
<span class="nc" id="L341">          result.append(encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF)));
<span class="nc" id="L344">          result.append(encode((input[i + 1] &amp; 0xF) &lt;&lt; 2));</span>
<span class="nc" id="L345">          result.append('=');</span>
<span class="nc" id="L346">          break;</span>
        default:
<span class="nc" id="L348">          result.append(encode(input[i] &gt;&gt; 2));</span>
<span class="nc" id="L349">          result.append(encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF)));
<span class="nc" id="L352">          result.append(encode(</span>
                  ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
                  | ((input[i + 2] &gt;&gt; 6) &amp; 0x3)));
<span class="nc" id="L355">          result.append(encode(input[i + 2] &amp; 0x3F));</span>
          break;
      }
    }
<span class="nc" id="L359">  }</span>

  /**
   * Encodes a byte array into a char array by doing base64 encoding.
   *
   * The caller must supply a big enough buffer.
   *
   * @param input - the byte array to encode.
   * @param offset - the index of the first byte to encode.
   * @param len - the number of bytes to encode.
   * @param output - the destination character array to encode to.
   * @param cptr - the index of the first character to encode to.
   * @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
   * bytes should be placed.
   */
  public static int encodeBase64(final byte[] input, final int offset,
          final int len, final char[] output, final int cptr) {
<span class="fc" id="L376">    int ptr = cptr;</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">    for (int i = offset; i &lt; len; i += 3) {</span>
<span class="pc bpc" id="L378" title="1 of 3 branches missed.">      switch (len - i) {</span>
        case 1:
<span class="nc" id="L380">          output[ptr++] = encode(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L381">          output[ptr++] = encode(((input[i]) &amp; 0x3) &lt;&lt; 4);</span>
<span class="nc" id="L382">          output[ptr++] = '=';</span>
<span class="nc" id="L383">          output[ptr++] = '=';</span>
<span class="nc" id="L384">          break;</span>
        case 2:
<span class="fc" id="L386">          output[ptr++] = encode(input[i] &gt;&gt; 2);</span>
<span class="fc" id="L387">          output[ptr++] = encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="fc" id="L390">          output[ptr++] = encode((input[i + 1] &amp; 0xF) &lt;&lt; 2);</span>
<span class="fc" id="L391">          output[ptr++] = '=';</span>
<span class="fc" id="L392">          break;</span>
        default:
<span class="fc" id="L394">          output[ptr++] = encode(input[i] &gt;&gt; 2);</span>
<span class="fc" id="L395">          output[ptr++] = encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="fc" id="L398">          output[ptr++] = encode(</span>
                  ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
                  | ((input[i + 2] &gt;&gt; 6) &amp; 0x3));
<span class="fc" id="L401">          output[ptr++] = encode(input[i + 2] &amp; 0x3F);</span>
          break;
      }
    }
<span class="fc" id="L405">    return ptr;</span>
  }

  /**
   * Encodes a byte array into another byte array by first doing base64 encoding then encoding the result in ASCII.
   *
   * The caller must supply a big enough buffer.
   *
   * @param input - the byte array to encode.
   * @param offset - the index of the first byte to encode.
   * @param len - the number of bytes to encode.
   * @param out - the destination byte array that represents an ASCII string to encode to.
   * @param cptr - the index of the first byte in the destination array to encode to.
   * @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
   * bytes should be placed.
   */
  public static int encodeBase64(final byte[] input, final int offset, final int len,
          final byte[] out, final int cptr) {
<span class="nc" id="L423">    int ptr = cptr;</span>
<span class="nc" id="L424">    byte[] buf = out;</span>
<span class="nc" id="L425">    int max = len + offset;</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">    for (int i = offset; i &lt; max; i += 3) {</span>
<span class="nc bnc" id="L427" title="All 3 branches missed.">      switch (max - i) {</span>
        case 1:
<span class="nc" id="L429">          buf[ptr++] = encodeByte(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L430">          buf[ptr++] = encodeByte(((input[i]) &amp; 0x3) &lt;&lt; 4);</span>
<span class="nc" id="L431">          buf[ptr++] = '=';</span>
<span class="nc" id="L432">          buf[ptr++] = '=';</span>
<span class="nc" id="L433">          break;</span>
        case 2:
<span class="nc" id="L435">          buf[ptr++] = encodeByte(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L436">          buf[ptr++] = encodeByte(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="nc" id="L439">          buf[ptr++] = encodeByte((input[i + 1] &amp; 0xF) &lt;&lt; 2);</span>
<span class="nc" id="L440">          buf[ptr++] = '=';</span>
<span class="nc" id="L441">          break;</span>
        default:
<span class="nc" id="L443">          buf[ptr++] = encodeByte(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L444">          buf[ptr++] = encodeByte(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="nc" id="L447">          buf[ptr++] = encodeByte(</span>
                  ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
                  | ((input[i + 2] &gt;&gt; 6) &amp; 0x3));
<span class="nc" id="L450">          buf[ptr++] = encodeByte(input[i + 2] &amp; 0x3F);</span>
          break;
      }
    }

<span class="nc" id="L455">    return ptr;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>