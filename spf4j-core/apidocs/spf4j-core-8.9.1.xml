<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Thu Nov 11 08:40:11 EST 2021 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="spf4j-core-8.9.1"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /Users/zoly/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/Users/zoly/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/Users/zoly/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/Users/zoly/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /Users/zoly/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/Users/zoly/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/Users/zoly/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/Users/zoly/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname spf4j-core-8.9.1 -apidir /Users/zoly/NetBeansProjects/spf4j/spf4j-core/target/site/apidocs -classpath /Users/zoly/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/Users/zoly/.m2/repository/net/java/dev/jna/jna/4.5.0/jna-4.5.0.jar:/Users/zoly/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/Users/zoly/.m2/repository/org/threeten/threeten-extra/1.5.0/threeten-extra-1.5.0.jar:/Users/zoly/.m2/repository/com/google/guava/guava/30.0-jre/guava-30.0-jre.jar:/Users/zoly/.m2/repository/org/apache/avro/avro/1.10.0.2p/avro-1.10.0.2p.jar:/Users/zoly/.m2/repository/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/Users/zoly/.m2/repository/args4j/args4j/2.33/args4j-2.33.jar:/Users/zoly/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.11.3/jackson-databind-2.11.3.jar:/Users/zoly/.m2/repository/org/spf4j/avro/core-schema/1.0.4/core-schema-1.0.4.jar:/Users/zoly/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.11.3/jackson-annotations-2.11.3.jar:/Users/zoly/.m2/repository/net/java/dev/jna/jna-platform/4.5.0/jna-platform-4.5.0.jar:/Users/zoly/.m2/repository/com/google/code/findbugs/findbugs-annotations/3.0.1/findbugs-annotations-3.0.1.jar:/Users/zoly/.m2/repository/com/google/errorprone/error_prone_annotations/2.3.4/error_prone_annotations-2.3.4.jar:/Users/zoly/.m2/repository/org/spf4j/spf4j-core/8.9.1/spf4j-core-8.9.1.jar:/Users/zoly/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/Users/zoly/.m2/repository/net/sf/trove4j/trove4j/3.0.3/trove4j-3.0.3.jar:/Users/zoly/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.11.3/jackson-core-2.11.3.jar:/Users/zoly/.m2/repository/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/Users/zoly/.m2/repository/org/yaml/snakeyaml/1.26/snakeyaml-1.26.jar:/Users/zoly/.m2/repository/org/checkerframework/checker-qual/3.5.0/checker-qual-3.5.0.jar:/Users/zoly/.m2/repository/com/fasterxml/jackson/dataformat/jackson-dataformat-yaml/2.11.3/jackson-dataformat-yaml-2.11.3.jar -sourcepath /var/folders/xj/26t4l20j05740l2k5ng_4v3h0000gp/T/jdiff907467583130558954/spf4j-core/8.9.1/sources -->
<package name="org.spf4j.security">
  <!-- start interface org.spf4j.security.AbacAuthorizer -->
  <interface name="AbacAuthorizer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="canAccess" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.security.Principal"/>
      <param name="resource" type="java.util.Properties"/>
      <param name="action" type="java.util.Properties"/>
      <param name="env" type="java.util.Properties"/>
      <doc>
      <![CDATA[Attribute bases access control, see https://en.wikipedia.org/wiki/Attribute-based_access_control
 @param user the user requesting access.
 @param resource  the properties of the accessed resource.
 @param action the properties of the action attempted.
 @param env environment params.
 @return]]>
      </doc>
    </method>
    <field name="NO_ACCESS" type="org.spf4j.security.AbacAuthorizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ALL_ACCESS" type="org.spf4j.security.AbacAuthorizer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Attribute based access control. (https://en.wikipedia.org/wiki/Attribute-based_access_control)
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.security.AbacAuthorizer -->
  <!-- start interface org.spf4j.security.AbacSecurityContext -->
  <interface name="AbacSecurityContext"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.security.RbacSecurityContext"/>
    <method name="resource" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <param name="id" type="java.lang.String"/>
    </method>
    <method name="action" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.lang.String"/>
    </method>
    <method name="env" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="env" type="java.lang.String"/>
    </method>
    <method name="from" return="org.spf4j.security.AbacSecurityContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rbac" type="org.spf4j.security.RbacSecurityContext"/>
      <param name="abacAuth" type="org.spf4j.security.AbacAuthorizer"/>
    </method>
    <method name="canAccess" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resource" type="java.util.Properties"/>
      <param name="action" type="java.util.Properties"/>
      <param name="env" type="java.util.Properties"/>
      <doc>
      <![CDATA[Attribute bases access control, see https://en.wikipedia.org/wiki/Attribute-based_access_control
 @param resource  the properties of the accessed resource.
 @param action the properties of the action attempted.
 @param env environment params.
 @return]]>
      </doc>
    </method>
    <field name="RESOURCE_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RESOURCE_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ACTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENVIRONMENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOAUTH" type="org.spf4j.security.AbacSecurityContext"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.security.AbacSecurityContext -->
  <!-- start class org.spf4j.security.AesEncryptorDecryptor -->
  <class name="AesEncryptorDecryptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.security.EncryptorDecryptor"/>
    <constructor name="AesEncryptorDecryptor" type="java.security.Key"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="randomKeyInstance" return="org.spf4j.security.AesEncryptorDecryptor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decrypt" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <method name="encrypt" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.security.AesEncryptorDecryptor -->
  <!-- start class org.spf4j.security.EncryptedBytes -->
  <class name="EncryptedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="EncryptedBytes" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.security.EncryptedBytes -->
  <!-- start class org.spf4j.security.EncryptedString -->
  <class name="EncryptedString" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="EncryptedString" type="char[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A string implementation where the content is encrypted with a random key. This maybe a "better" way of storing
 secrets in memory. Secrets life in memory should be "minimized" as such the use of char[] must be done combined with
 immediate clear after use. The less time secrets spend in memory, the less chance they might be miss-appropriated.

 Using the class encrypts the content, and decrypts it every time it is needed to access. The problem with this class
 is that the key is also in memory, so if you get ahold of the content of this class and the key (like a heap dump)
 you will be able to decrypt the content. (although through a extra step)

 Using this class, will help you avoid accidental leakage of the secret though into logs (toString will not output the
 content) or other similar places.

 This class is NOT a replacement to storing keys in hardware secure enclaves.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.security.EncryptedString -->
  <!-- start interface org.spf4j.security.EncryptorDecryptor -->
  <interface name="EncryptorDecryptor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="decrypt" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <method name="encrypt" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.security.EncryptorDecryptor -->
  <!-- start interface org.spf4j.security.RbacSecurityContext -->
  <interface name="RbacSecurityContext"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUserPrincipal" return="java.security.Principal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a <code>java.security.Principal</code> object containing the name of the current authenticated user. If the
 user has not been authenticated, the method returns null.

 @return a <code>java.security.Principal</code> containing the name of the user making this request; null if the
 user has not been authenticated
 @throws java.lang.IllegalStateException if called outside the scope of a request]]>
      </doc>
    </method>
    <method name="isUserInRole" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="role" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a boolean indicating whether the authenticated user is included in the specified logical "role". If the
 user has not been authenticated, the method returns <code>false</code>.

 @param role a <code>String</code> specifying the name of the role
 @return a <code>boolean</code> indicating whether the user making the request belongs to a given role;
 <code>false</code> if the user has not been authenticated
 @throws java.lang.IllegalStateException if called outside the scope of a request]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Role based access control: https://en.wikipedia.org/wiki/Role-based_access_control
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.security.RbacSecurityContext -->
</package>
<package name="org.spf4j.perf.impl.ms">
  <!-- start class org.spf4j.perf.impl.ms.Flusher -->
  <class name="Flusher" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="flushEvery"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="intervalMillis" type="int"/>
      <param name="store" type="org.spf4j.perf.MeasurementStore"/>
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.Flusher -->
  <!-- start class org.spf4j.perf.impl.ms.Id2Info -->
  <class name="Id2Info" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getId" return="long"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.spf4j.perf.MeasurementsInfo"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="long"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.Id2Info -->
  <!-- start class org.spf4j.perf.impl.ms.MultiStore -->
  <class name="MultiStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="MultiStore" type="org.spf4j.perf.MeasurementStore[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getStores" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multi store implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.MultiStore -->
  <!-- start interface org.spf4j.perf.impl.ms.StoreFactory -->
  <interface name="StoreFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="org.spf4j.perf.MeasurementStore"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.impl.ms.StoreFactory -->
  <!-- start class org.spf4j.perf.impl.ms.StoreType -->
  <class name="StoreType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.perf.impl.ms.StoreType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.perf.impl.ms.StoreType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="fromString" return="org.spf4j.perf.MeasurementStore"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <field name="TSDB" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TSDB_AVRO" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TSDB_TXT" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GRAPHITE_UDP" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GRAPHITE_TCP" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOP_STORE" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CUSTOM" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WRAPPER" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.StoreType -->
</package>
<package name="org.spf4j.net">
  <!-- start class org.spf4j.net.SntpClient -->
  <class name="SntpClient" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="requestTimeHA" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="int"/>
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="requestTimeHA" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="int"/>
      <param name="ntpResponseTimeoutMillis" type="int"/>
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Request NTP time with retries.

 @param hosts NTP server hosts.
 @param timeoutMillis Max time to attempt to get NTP time
 @param ntpResponseTimeoutMillis the time after which if we do not receive a response from the NTP server,
 we consider the call failed (and will retry until timeoutMillis.
 @return Ntp timing info.
 @throws IOException - thrown in case of time server connectivity issues.
 @throws InterruptedException - thrown if exec interrupted.]]>
      </doc>
    </method>
    <method name="requestTimeHA" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="int"/>
      <param name="ntpResponseTimeoutMillis" type="int"/>
      <param name="port" type="int"/>
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="requestTimeHA" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="int"/>
      <param name="ntpResponseTimeoutMillis" type="int"/>
      <param name="port" type="int"/>
      <param name="hosts" type="java.net.InetAddress[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="requestTime" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="timeoutMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="requestTime" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="timeoutMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="requestTime" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get NTP time.

 @param host - NTP server host name.
 @param timeoutMillis - the socket timeout.
 @return - NTP server timing info.
 @throws IOException - thrown in case of time server connectivity issues.]]>
      </doc>
    </method>
    <method name="requestTime" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get NTP time.

 @param address - NTP server addr.
 @param timeoutMillis - the socket timeout.
 @return - NTP server timing info.
 @throws IOException - thrown in case of time server connectivity issues.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple NTP client. Inspired by Android Sntp client. For how to use, see SntpClientTest.java.
 https://tools.ietf.org/html/rfc1361

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.net.SntpClient -->
  <!-- start class org.spf4j.net.Timing -->
  <class name="Timing" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Timing" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNtpTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNtpTimeReference" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRoundTripTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current Time based on the NTP timing info.
 @return current time, as number of millis since EPOCH.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.net.Timing -->
</package>
<package name="org.spf4j.perf.io">
  <!-- start class org.spf4j.perf.io.MeasuredInputStream -->
  <class name="MeasuredInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MeasuredInputStream" type="java.io.InputStream, java.lang.String, org.spf4j.perf.MeasurementRecorderSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.io.MeasuredInputStream -->
  <!-- start class org.spf4j.perf.io.MeasuredOutputStream -->
  <class name="MeasuredOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MeasuredOutputStream" type="java.io.OutputStream, java.lang.String, org.spf4j.perf.MeasurementRecorderSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.io.MeasuredOutputStream -->
  <!-- start class org.spf4j.perf.io.OpenFilesSampler -->
  <class name="OpenFilesSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
      <param name="shutdownOnError" type="boolean"/>
    </method>
    <method name="getWarnLsofDetail" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWarnLsofTime" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
      <param name="warnThreshold" type="long"/>
      <param name="errorThreshold" type="long"/>
      <param name="shutdownOnError" type="boolean"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLsof" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxNrOpenFiles" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrOpenFiles" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWarnThreshold" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getErrorThreshold" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class allows you to poll and recordAt to a file the heap commitxted and heap used for your java process. start
 data recording by calling the startMemoryUsageSampling method, stop the data recording by calling the method:
 startMemoryUsageSampling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.io.OpenFilesSampler -->
</package>
<package name="org.spf4j.io.appenders">
  <!-- start class org.spf4j.io.appenders.ArrayBooleanAppender -->
  <class name="ArrayBooleanAppender" extends="org.spf4j.io.appenders.json.ArrayBooleanJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayBooleanAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayBooleanAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayBytesAppender -->
  <class name="ArrayBytesAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayBytesAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="byte[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="byte[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayBytesAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayCharsAppender -->
  <class name="ArrayCharsAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayCharsAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="char[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="char[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayCharsAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayDoubleAppender -->
  <class name="ArrayDoubleAppender" extends="org.spf4j.io.appenders.json.ArrayDoubleJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayDoubleAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayDoubleAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayFloatAppender -->
  <class name="ArrayFloatAppender" extends="org.spf4j.io.appenders.json.ArrayFloatJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFloatAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayFloatAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayIntAppender -->
  <class name="ArrayIntAppender" extends="org.spf4j.io.appenders.json.ArrayIntJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayIntAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayIntAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayLongAppender -->
  <class name="ArrayLongAppender" extends="org.spf4j.io.appenders.json.ArrayLongJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayLongAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayLongAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayObjectAppender -->
  <class name="ArrayObjectAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayObjectAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="java.lang.Object[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayObjectAppender -->
  <!-- start class org.spf4j.io.appenders.ArrayShortAppender -->
  <class name="ArrayShortAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayShortAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="short[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="short[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ArrayShortAppender -->
  <!-- start class org.spf4j.io.appenders.CalendarAppender -->
  <class name="CalendarAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="CalendarAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instant" type="java.util.Calendar"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.CalendarAppender -->
  <!-- start class org.spf4j.io.appenders.CharsequenceAppender -->
  <class name="CharsequenceAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="CharsequenceAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.CharSequence"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.CharsequenceAppender -->
  <!-- start class org.spf4j.io.appenders.CollectionAppender -->
  <class name="CollectionAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="CollectionAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.util.Collection"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.CollectionAppender -->
  <!-- start class org.spf4j.io.appenders.DateAppender -->
  <class name="DateAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="DateAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="java.util.Date"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.DateAppender -->
  <!-- start class org.spf4j.io.appenders.GenericRecordAppender -->
  <class name="GenericRecordAppender" extends="org.spf4j.io.appenders.json.GenericRecordJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericRecordAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.GenericRecordAppender -->
  <!-- start class org.spf4j.io.appenders.InstantAppender -->
  <class name="InstantAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="InstantAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.time.Instant"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.InstantAppender -->
  <!-- start class org.spf4j.io.appenders.LocalDateAppender -->
  <class name="LocalDateAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="LocalDateAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="java.time.LocalDate"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.LocalDateAppender -->
  <!-- start class org.spf4j.io.appenders.MapAppender -->
  <class name="MapAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="MapAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.util.Map"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.MapAppender -->
  <!-- start class org.spf4j.io.appenders.NumberAppender -->
  <class name="NumberAppender" extends="org.spf4j.io.appenders.json.NumberJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NumberAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.NumberAppender -->
  <!-- start class org.spf4j.io.appenders.PathAppender -->
  <class name="PathAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="PathAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.PathAppender -->
  <!-- start class org.spf4j.io.appenders.SampleNodeAppender -->
  <class name="SampleNodeAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SampleNodeAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.spf4j.io.appenders.SampleNodeAppender -->
  <!-- start class org.spf4j.io.appenders.SpecificRecordAppender -->
  <class name="SpecificRecordAppender" extends="org.spf4j.io.appenders.json.SpecificRecordJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SpecificRecordAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.SpecificRecordAppender -->
  <!-- start class org.spf4j.io.appenders.SpecificRecordBaseAppender -->
  <class name="SpecificRecordBaseAppender" extends="org.spf4j.io.appenders.json.SpecificRecordBaseJsonAppender"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SpecificRecordBaseAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.SpecificRecordBaseAppender -->
  <!-- start class org.spf4j.io.appenders.SqlDateAppender -->
  <class name="SqlDateAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SqlDateAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="java.sql.Date"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.SqlDateAppender -->
  <!-- start class org.spf4j.io.appenders.ThrowableAppender -->
  <class name="ThrowableAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ThrowableAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Throwable"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.ThrowableAppender -->
  <!-- start class org.spf4j.io.appenders.WriteableAppender -->
  <class name="WriteableAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="WriteableAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.base.Writeable"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.WriteableAppender -->
</package>
<package name="org.spf4j.perf.impl.ms.graphite">
  <!-- start class org.spf4j.perf.impl.ms.graphite.GraphiteTcpStore -->
  <class name="GraphiteTcpStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="GraphiteTcpStore" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
    </constructor>
    <constructor name="GraphiteTcpStore" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="GraphiteTcpStore" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="GraphiteTcpStore" type="java.lang.String, int, javax.net.SocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.graphite.GraphiteTcpStore -->
  <!-- start class org.spf4j.perf.impl.ms.graphite.GraphiteUdpStore -->
  <class name="GraphiteUdpStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="GraphiteUdpStore" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
    </constructor>
    <constructor name="GraphiteUdpStore" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="GraphiteUdpStore" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMetric"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementInfo" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="measurementName" type="java.lang.String"/>
      <param name="measurement" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="os" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write with the plaintext protocol: https://graphite.readthedocs.io/en/0.9.10/feeding-carbon.html

 @param measurementInfo measuremrnt info
 @param measurementName measurement name
 @param measurement measurement value
 @param timeStampMillis timestamp millis since epoch.
 @param os the output writer to write to.
 @throws IOException]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="MAX_UDP_MSG_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.graphite.GraphiteUdpStore -->
</package>
<package name="org.spf4j.recyclable.impl">
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers -->
  <class name="ArraySuppliers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers -->
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers.Bytes -->
  <class name="ArraySuppliers.Bytes" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="TL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_NEW" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers.Bytes -->
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers.Chars -->
  <class name="ArraySuppliers.Chars" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="TL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_NEW" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers.Chars -->
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers.Objects -->
  <class name="ArraySuppliers.Objects" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="TL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers.Objects -->
  <!-- start class org.spf4j.recyclable.impl.CollectableThreadLocalRecyclingSupplier -->
  <class name="CollectableThreadLocalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.NonValidatingRecyclingSupplier"/>
    <constructor name="CollectableThreadLocalRecyclingSupplier" type="org.spf4j.base.ReferenceType, java.util.function.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.CollectableThreadLocalRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.impl.LeaseImpl -->
  <class name="LeaseImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Lease"/>
    <constructor name="LeaseImpl" type="org.spf4j.recyclable.RecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.LeaseImpl -->
  <!-- start class org.spf4j.recyclable.impl.ObjectHolder -->
  <class name="ObjectHolder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getObj" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="borrowOrCreateObjectIfPossible" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="borrowObjectIfAvailable" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="returnObject"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
    </method>
    <method name="validateObjectIfNotBorrowed"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="disposeIfNotBorrowed" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFactory" return="org.spf4j.recyclable.RecyclingSupplier.Factory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[this is not a thread safe implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ObjectHolder -->
  <!-- start class org.spf4j.recyclable.impl.ObjectHolderFactory -->
  <class name="ObjectHolderFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.RecyclingSupplier.Factory"/>
    <constructor name="ObjectHolderFactory" type="int, org.spf4j.recyclable.RecyclingSupplier.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="create" return="org.spf4j.recyclable.impl.ObjectHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.recyclable.impl.ObjectHolder"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="validate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.recyclable.impl.ObjectHolder"/>
      <param name="e" type="java.lang.Exception"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ObjectHolderFactory -->
  <!-- start class org.spf4j.recyclable.impl.Powerof2SizedGlobalRecyclingSupplier -->
  <class name="Powerof2SizedGlobalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.SizedRecyclingSupplier"/>
    <constructor name="Powerof2SizedGlobalRecyclingSupplier" type="org.spf4j.recyclable.SizedRecyclingSupplier.Factory, org.spf4j.base.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[recycling supplier that allows you to recycle objects.
 Recycling objects is dangerous business, care should be used.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.Powerof2SizedGlobalRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.impl.Powerof2ThreadLocalRecyclingSupplier -->
  <class name="Powerof2ThreadLocalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.SizedRecyclingSupplier"/>
    <constructor name="Powerof2ThreadLocalRecyclingSupplier" type="org.spf4j.recyclable.SizedRecyclingSupplier.Factory, org.spf4j.base.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[recycling supplier that allows you to recycle objects.
 Recycling objects is dangerous business, care should be used.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.Powerof2ThreadLocalRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.impl.RecyclingSupplierBuilder -->
  <class name="RecyclingSupplierBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="RecyclingSupplierBuilder" type="int, org.spf4j.recyclable.RecyclingSupplier.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="unfair" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withInitialSize" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pinitialSize" type="int"/>
    </method>
    <method name="withMaintenance" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pexec" type="java.util.concurrent.ScheduledExecutorService"/>
      <param name="pmaintenanceIntervalMillis" type="long"/>
      <param name="pcollectBorrowed" type="boolean"/>
    </method>
    <method name="withGetHook" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="phook" type="org.spf4j.base.Handler"/>
    </method>
    <method name="withRecycleHook" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="phook" type="org.spf4j.base.Handler"/>
    </method>
    <method name="build" return="org.spf4j.recyclable.RecyclingSupplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.RecyclingSupplierBuilder -->
  <!-- start class org.spf4j.recyclable.impl.SharingObjectPool -->
  <class name="SharingObjectPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.RecyclingSupplier"/>
    <constructor name="SharingObjectPool" type="org.spf4j.recyclable.RecyclingSupplier.Factory, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="SharingObjectPool" type="org.spf4j.recyclable.RecyclingSupplier.Factory, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="tryGet" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="tryDispose" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[a object sharing pool. this pool allows for non exclusive object sharing.
 will always return the least shared object.
 TODO: synchronization is too coarse, can be
 improved.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.SharingObjectPool -->
  <!-- start class org.spf4j.recyclable.impl.SharingObjectPool.SharedObject -->
  <class name="SharingObjectPool.SharedObject" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SharedObject" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SharedObject" type="java.lang.Object, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrTimesShared" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.recyclable.impl.SharingObjectPool.SharedObject -->
  <!-- start class org.spf4j.recyclable.impl.SizedThreadLocalRecyclingSupplier -->
  <class name="SizedThreadLocalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.SizedRecyclingSupplier"/>
    <constructor name="SizedThreadLocalRecyclingSupplier" type="org.spf4j.recyclable.SizedRecyclingSupplier.Factory, org.spf4j.base.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[recycling supplier that allows you to recycle objects.
 Recycling objects is dangerous business, care should be used.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.SizedThreadLocalRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.impl.ThreadLocalRecyclingSupplier -->
  <class name="ThreadLocalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.NonValidatingRecyclingSupplier"/>
    <constructor name="ThreadLocalRecyclingSupplier" type="java.util.function.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ThreadLocalRecyclingSupplier -->
</package>
<package name="org.spf4j.perf.memory">
  <!-- start class org.spf4j.perf.memory.GCUsageSampler -->
  <class name="GCUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMBEANS" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGCTimeDiff" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gcBeans" type="java.lang.Iterable"/>
      <param name="lastValues" type="gnu.trove.map.TObjectLongMap"/>
    </method>
    <method name="getGCTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gcBeans" type="java.lang.Iterable"/>
    </method>
    <method name="getGCTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class allows you to poll and recordAt to a file the heap committed and heap used for your java process. start
 data recording by calling the startMemoryUsageSampling method, stop the data recording by calling the method:
 startMemoryUsageSampling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.memory.GCUsageSampler -->
  <!-- start class org.spf4j.perf.memory.MemoryUsageSampler -->
  <class name="MemoryUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMilis" type="long"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMilis" type="int"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMilis" type="int"/>
      <param name="accumulateIntervalMillis" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="dumpHeap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="liveObjectOnly" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHotspotDiagnosticBean" return="com.sun.management.HotSpotDiagnosticMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class allows you to poll and recordAt to a file the heap committed and heap used for your java process. start
 data recording by calling the startMemoryUsageSampling method, stop the data recording by calling the method:
 startMemoryUsageSampling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.memory.MemoryUsageSampler -->
</package>
<package name="org.spf4j.io.csv">
  <!-- start class org.spf4j.io.csv.CharSeparatedValues -->
  <class name="CharSeparatedValues" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharSeparatedValues" type="char"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CharSeparatedValues" type="char, char[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toCsvRowString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="java.lang.Object[]"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow2"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="long[]"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Iterable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="java.lang.Iterable"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvRowHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readNoBom" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[reads CSV format until EOF of reader.

 @param <T>
 @param preader
 @param handler
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="asIterable" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <doc>
      <![CDATA[read a CSV stream, as a Iterable over rows.
 the List<String> instance is reused during iteration, you will need to copy content into
 own data structure.
 @param preader
 @return]]>
      </doc>
    </method>
    <method name="singleRow" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <doc>
      <![CDATA[Iterate through the first row of your CSV.
 the CharSequence is a re-0used char buffer you either need to parse the content out of copy it.
 @param preader
 @return]]>
      </doc>
    </method>
    <method name="reader" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readerILEL" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use reader">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[will ignore last empty line.
 @param preader
 @return
 @throws IOException
 @deprecated use reader]]>
      </doc>
    </method>
    <method name="readerNoBOM" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
      <doc>
      <![CDATA[assumes there is not BOM. (byte order marker)
 @param reader
 @return]]>
      </doc>
    </method>
    <method name="readerNoBOMILEL" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use readerNoBOM.">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
      <doc>
      <![CDATA[reader that there is not BOM. (byte order marker) and will ignore last empty line.
 @param reader
 @return
 @deprecated use readerNoBOM.]]>
      </doc>
    </method>
    <method name="writer" return="org.spf4j.io.csv.CsvWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
    </method>
    <method name="writeCsvElement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeQuotedCsvElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeQuotedElementContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeQuotedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toCsvElement" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
    </method>
    <method name="toCsvElement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.String"/>
    </method>
    <method name="readCsvElement" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="addElemTo" type="java.lang.StringBuilder"/>
      <param name="lineNr" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[returns next character.

 @param reader
 @param addElemTo
 @return - next character or -1 if eof has been reached.
 @throws IOException]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="UTF_BOM" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[http://unicode.org/faq/utf_bom.html#BOM]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Supports Character Separated values format as described at: https://en.wikipedia.org/wiki/Comma-separated_values.
 either of \n \r or \r\n generalized to custom separator character.
 are valid end of line delimiters

 why another implementation? because I need one that is as fast as possible, and as flexible as possible.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.CharSeparatedValues -->
  <!-- start interface org.spf4j.io.csv.CsvHandler -->
  <interface name="CsvHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="startRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowNr" type="long"/>
    </method>
    <method name="startRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="element"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[@param elem - the CharSequence instance is being reused, between invocations. value should be copied or parsed into
 a new object.]]>
      </doc>
    </method>
    <method name="endRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="eof" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvHandler -->
  <!-- start interface org.spf4j.io.csv.CsvMapHandler -->
  <interface name="CsvMapHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="row"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="row" type="java.util.Map"/>
    </method>
    <method name="eof" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvMapHandler -->
  <!-- start class org.spf4j.io.csv.CsvParseException -->
  <class name="CsvParseException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CsvParseException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvParseException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvParseException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvParseException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.CsvParseException -->
  <!-- start interface org.spf4j.io.csv.CsvReader -->
  <interface name="CsvReader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="next" return="org.spf4j.io.csv.CsvReader.TokenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[read next CSV element, and return its type.

 @return return CSV element type.
 @throws IOException exception is something goes wrong.]]>
      </doc>
    </method>
    <method name="current" return="org.spf4j.io.csv.CsvReader.TokenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the currently parsed token type,  null if no current token is available (next has never been called)
 @throws IOException
 @throws CsvParseException]]>
      </doc>
    </method>
    <method name="getElement" return="java.lang.CharSequence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the CSV element string. the underlying instance is reused, so you will need to make a copy of this if planning to
 use it.

 @return CharSequence representing a csv cell.]]>
      </doc>
    </method>
    <method name="currentLineNumber" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Current CSV line number.
 @return]]>
      </doc>
    </method>
    <method name="skipRow" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.Consumer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="toReader" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="it" type="java.util.Iterator"/>
    </method>
    <doc>
    <![CDATA[Char separated value file Reader.
 A newly created reader will initially be positioned at START_DOCUMENT. (current())
 A example Token sequence will be:
 START_DOCUMENT, ELEMENT, ELEMENT, END_ROW, ELEMENT, ELEMENT, END_ROW, END_DOCUMENT

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvReader -->
  <!-- start class org.spf4j.io.csv.CsvReader.TokenType -->
  <class name="CsvReader.TokenType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.io.csv.CsvReader.TokenType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.io.csv.CsvReader.TokenType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="START_DOCUMENT" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ELEMENT" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="END_ROW" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="END_DOCUMENT" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.csv.CsvReader.TokenType -->
  <!-- start class org.spf4j.io.csv.CsvReader2Iterator -->
  <class name="CsvReader2Iterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <constructor name="CsvReader2Iterator" type="org.spf4j.io.csv.CsvReader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.csv.CsvReader2Iterator -->
  <!-- start interface org.spf4j.io.csv.CsvRowHandler -->
  <interface name="CsvRowHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="element"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
    </method>
    <method name="eof" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvRowHandler -->
  <!-- start class org.spf4j.io.csv.CsvRuntimeException -->
  <class name="CsvRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CsvRuntimeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.CsvRuntimeException -->
  <!-- start interface org.spf4j.io.csv.CsvWriter -->
  <interface name="CsvWriter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeElement"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Will start a element, and write it.
 @param cs
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeEol"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[should be called when writing a row is done.
 @throws IOException]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This will flush to underlying destination.
 @throws IOException]]>
      </doc>
    </method>
    <method name="startQuotedElement" return="org.spf4j.io.csv.ElementAppendable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRawElement" return="java.lang.Appendable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvWriter -->
  <!-- start interface org.spf4j.io.csv.ElementAppendable -->
  <interface name="ElementAppendable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Appendable"/>
    <implements name="java.io.Closeable"/>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.ElementAppendable -->
  <!-- start class org.spf4j.io.csv.OneRowIterator -->
  <class name="OneRowIterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <constructor name="OneRowIterator" type="org.spf4j.io.csv.CsvReader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.OneRowIterator -->
  <!-- start class org.spf4j.io.csv.UncheckedCsvParseException -->
  <class name="UncheckedCsvParseException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedCsvParseException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedCsvParseException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedCsvParseException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedCsvParseException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.UncheckedCsvParseException -->
</package>
<package name="org.spf4j.stackmonitor">
  <!-- start class org.spf4j.stackmonitor.FastStackCollector -->
  <class name="FastStackCollector" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.ISampler"/>
    <constructor name="FastStackCollector" type="boolean, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FastStackCollector" type="boolean, boolean, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FastStackCollector" type="boolean, boolean, java.lang.Thread[], java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FastStackCollector" type="java.util.function.Predicate, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param threadFilter when returns true the thread is being ignored]]>
      </doc>
    </constructor>
    <method name="createNameBasedFilter" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collectRunnableThreadsOnly" type="boolean"/>
      <param name="collectForMain" type="boolean"/>
      <param name="ignored" type="java.lang.Thread[]"/>
      <param name="xtraIgnoredThreads" type="java.lang.String[]"/>
    </method>
    <method name="getThreads" return="java.lang.Thread[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use Threads.getThreads">
      <doc>
      <![CDATA[@deprecated use Threads.getThreads]]>
      </doc>
    </method>
    <method name="getStackTraces" return="java.lang.StackTraceElement[][]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use Threads.getStackTraces">
      <param name="threads" type="java.lang.Thread[]"/>
      <doc>
      <![CDATA[@deprecated use Threads.getStackTraces]]>
      </doc>
    </method>
    <method name="dumpToPrintStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use Threads.dumpToPrintStream">
      <param name="stream" type="java.io.PrintStream"/>
      <doc>
      <![CDATA[@deprecated use Threads.dumpToPrintStream]]>
      </doc>
    </method>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollectionsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollections" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is a high performance sampling collector. The goal is for the sampling overhead to be minimal. This is better
 than the SimpleStackCollector in 2 ways: 1) No HashMap is created during sampling. Resulting in less garbage
 generated by sampling. 2) Stack trace for the sampling Thread is not created at all, saving some time and creating
 less garbage.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.FastStackCollector -->
  <!-- start class org.spf4j.stackmonitor.FastStackCollector.ThreadNamesPredicate -->
  <class name="FastStackCollector.ThreadNamesPredicate" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Predicate"/>
    <constructor name="ThreadNamesPredicate" type="java.util.Set"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Thread"/>
    </method>
  </class>
  <!-- end class org.spf4j.stackmonitor.FastStackCollector.ThreadNamesPredicate -->
  <!-- start class org.spf4j.stackmonitor.GCFakeStackUtil -->
  <class name="GCFakeStackUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createFakeGCSamples" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prevGCTimeMillis" type="long"/>
      <param name="gcTimeMillis" type="long"/>
      <param name="stMs" type="long"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.GCFakeStackUtil -->
  <!-- start interface org.spf4j.stackmonitor.ISampler -->
  <interface name="ISampler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sample"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollectionsAndReset" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollections" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.stackmonitor.ISampler -->
  <!-- start class org.spf4j.stackmonitor.MethodMap -->
  <class name="MethodMap" extends="org.spf4j.stackmonitor.THashMap"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MethodMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MethodMap" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
      <doc>
      <![CDATA[optimized hashing.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
      <param name="two" type="java.lang.Object"/>
      <doc>
      <![CDATA[equals is used for both keys and values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A custom hashcode and eequals map implementation
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.MethodMap -->
  <!-- start class org.spf4j.stackmonitor.Monitor -->
  <class name="Monitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <exception name="NoSuchMethodException" type="java.lang.NoSuchMethodException"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
      <exception name="InvocationTargetException" type="java.lang.reflect.InvocationTargetException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.Monitor -->
  <!-- start class org.spf4j.stackmonitor.MxStackCollector -->
  <class name="MxStackCollector" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.ISampler"/>
    <constructor name="MxStackCollector" type="java.lang.Thread"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollectionsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollections" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.MxStackCollector -->
  <!-- start class org.spf4j.stackmonitor.ProfiledExecutionContext -->
  <class name="ProfiledExecutionContext" extends="org.spf4j.base.BasicExecutionContext"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProfiledExecutionContext" type="java.lang.String, java.lang.CharSequence, org.spf4j.base.ExecutionContext, org.spf4j.base.ExecutionContext.Relation, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAndClearStackSamples" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStackSamples" return="org.spf4j.base.StackSamples"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samples" type="org.spf4j.base.StackSamples"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.ProfiledExecutionContext -->
  <!-- start class org.spf4j.stackmonitor.ProfiledExecutionContextFactory -->
  <class name="ProfiledExecutionContextFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.ExecutionContextFactory"/>
    <constructor name="ProfiledExecutionContextFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="start" return="org.spf4j.stackmonitor.ProfiledExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="id" type="java.lang.CharSequence"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="relation" type="org.spf4j.base.ExecutionContext.Relation"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.ProfiledExecutionContextFactory -->
  <!-- start class org.spf4j.stackmonitor.ProfilingTLAttacher -->
  <class name="ProfilingTLAttacher" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.ThreadLocalContextAttacher"/>
    <constructor name="ProfilingTLAttacher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentThreads" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentThreadContexts" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="attach" return="org.spf4j.base.ThreadLocalContextAttacher.Attached"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.ProfilingTLAttacher -->
  <!-- start class org.spf4j.stackmonitor.SampleNode -->
  <class name="SampleNode" extends="org.spf4j.stackmonitor.MethodMap"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <implements name="org.spf4j.base.StackSamples"/>
    <constructor name="SampleNode" type="int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SampleNode" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SampleNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSampleNode" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="addToSampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="getSubNodes" return="gnu.trove.map.TMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="aggregateNullable" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node1" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="node2" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="aggregate" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node1" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="node2" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="aggregateNullableUnsafe" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node1" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="node2" type="org.spf4j.stackmonitor.SampleNode"/>
      <doc>
      <![CDATA[Aggregation implementation where parts of node1 and node2 will be re-used.
 @param node1
 @param node2
 @return]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.stackmonitor.SampleNode"/>
      <doc>
      <![CDATA[add other samples to this one.
 other will not be usable after this operation since it will be linked directly where possible.
 @param other]]>
      </doc>
    </method>
    <method name="getSampleCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="height" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrNodes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[to do: have to remove recursion...

 @return the total number of nodes in this tree.]]>
      </doc>
    </method>
    <method name="filteredBy" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[creates a copy filtered by predicate.
 @param predicate
 @return]]>
      </doc>
    </method>
    <method name="writeJsonTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeD3JsonTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A Json format compatible with: https://github.com/spiermar/d3-flame-graph
 @param appendable
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeD3JsonFormatTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A Json format compatible with: https://github.com/spiermar/d3-flame-graph
 @param m
 @param appendable
 @throws IOException]]>
      </doc>
    </method>
    <method name="traverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="handler" type="org.spf4j.stackmonitor.SampleNode.Invocation"/>
    </method>
    <method name="traverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="handler" type="org.spf4j.stackmonitor.SampleNode.Invocation"/>
      <param name="breadthFirst" type="boolean"/>
    </method>
    <method name="traverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="handler" type="org.spf4j.stackmonitor.SampleNode.Invocation"/>
      <param name="func" type="java.util.function.Function"/>
    </method>
    <method name="parse" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.io.Reader"/>
      <param name="root" type="org.spf4j.stackmonitor.SampleNode"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonP" type="com.fasterxml.jackson.core.JsonParser"/>
      <param name="parentNode" type="org.spf4j.stackmonitor.SampleNode"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseD3Json" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.SampleNode -->
  <!-- start interface org.spf4j.stackmonitor.SampleNode.Invocation -->
  <interface name="SampleNode.Invocation"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="invocation" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="org.spf4j.base.avro.Method"/>
      <param name="to" type="org.spf4j.base.avro.Method"/>
      <param name="nrSamples" type="int"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.stackmonitor.SampleNode.Invocation -->
  <!-- start class org.spf4j.stackmonitor.Sampler -->
  <class name="Sampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Sampler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, org.spf4j.stackmonitor.SamplerSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="org.spf4j.stackmonitor.SamplerSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int, org.spf4j.stackmonitor.SamplerSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int, org.spf4j.stackmonitor.SamplerSupplier, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int, org.spf4j.stackmonitor.SamplerSupplier, java.io.File, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int, org.spf4j.stackmonitor.SamplerSupplier, java.io.File, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSampler" return="org.spf4j.stackmonitor.Sampler"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="int"/>
      <param name="dumpTimeMillis" type="int"/>
      <param name="dumpFolder" type="java.io.File"/>
      <param name="dumpFilePrefix" type="java.lang.String"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getSampler" return="org.spf4j.stackmonitor.Sampler"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="int"/>
      <param name="dumpTimeMillis" type="int"/>
      <param name="collector" type="org.spf4j.stackmonitor.SamplerSupplier"/>
      <param name="dumpFolder" type="java.io.File"/>
      <param name="dumpFilePrefix" type="java.lang.String"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCompressDumps" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCompressDumps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="compressDumps" type="boolean"/>
    </method>
    <method name="dumpToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dumpToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Dumps the sampled stacks to file. the collected samples are reset

 @param id - id will be added to file name returns the name of the file.
 @return - the file name where the data was persisted or null if there was no data to persist. The file name
 will be of format: [filePrefix](_[id])?_["yyyyMMdd'T'HHmmssSSSz]_["yyyyMMdd'T'HHmmssSSSz]_[label].ssdump2(.gz)?
 or [filePrefix](_[id])?_["yyyyMMdd'T'HHmmssSSSz]_["yyyyMMdd'T'HHmmssSSSz].ssdump3(.gz)?
 @throws IOException - io issues while persisting data.]]>
      </doc>
    </method>
    <method name="dumpToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="destinationFolder" type="java.io.File"/>
      <param name="pbaseFileName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Dump  collected samples to disk.
 @param destinationFolder the destination folder.
 @param pbaseFileName file name base, will be URLEncoded.
 The appropriate extension will be added depending on situation.
 either ssdump2 or ssdump3 will be used depending on the number of sample aggregate groups.
 additionally .gz will be added if compression is enabled.
 in case of ssdump2 the label will be appended to the file name like _[label].ssdump2

 @return the saved file, or null if no collected samples to save.
 @throws IOException]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getSampleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setSampleTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="isStopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStackCollectionsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStackCollections" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getDumpTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDumpTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dumpTimeMillis" type="int"/>
    </method>
    <method name="getFilePrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDumpFolder" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastDumpTime" return="java.util.Date"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_SS_DUMP_FOLDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_SS_DUMP_FILE_NAME_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility to sample stack traces. Stack traces can be persisted for later analysis.

 please read http://sape.inf.usi.ch/sites/default/files/publication/pldi10.pdf pure java stack sampling will probably
 have safepoint bias.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.Sampler -->
  <!-- start interface org.spf4j.stackmonitor.SamplerSupplier -->
  <interface name="SamplerSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.spf4j.stackmonitor.ISampler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samplingThread" type="java.lang.Thread"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.stackmonitor.SamplerSupplier -->
  <!-- start class org.spf4j.stackmonitor.SimpleStackCollector -->
  <class name="SimpleStackCollector" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.ISampler"/>
    <constructor name="SimpleStackCollector" type="java.lang.Thread"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollectionsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollections" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.SimpleStackCollector -->
  <!-- start class org.spf4j.stackmonitor.Spf4jProfilerException -->
  <class name="Spf4jProfilerException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spf4jProfilerException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Spf4jProfilerException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Spf4jProfilerException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Spf4jProfilerException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.Spf4jProfilerException -->
  <!-- start interface org.spf4j.stackmonitor.StackCollector -->
  <interface name="StackCollector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAndReset" return="org.spf4j.stackmonitor.SampleNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.spf4j.stackmonitor.SampleNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="collect"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.stackmonitor.StackCollector -->
  <!-- start class org.spf4j.stackmonitor.StackCollectorImpl -->
  <class name="StackCollectorImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.StackCollector"/>
    <constructor name="StackCollectorImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAndReset" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="collect"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrNodes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.StackCollectorImpl -->
  <!-- start class org.spf4j.stackmonitor.StackTrace -->
  <class name="StackTrace" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="StackTrace" type="java.lang.StackTraceElement[], int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="org.spf4j.stackmonitor.StackTrace"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
      <param name="relevantFramesStart" type="int"/>
    </method>
    <method name="getStackTrace" return="java.lang.StackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="EMPTY_STACK_TRACE" type="java.lang.StackTraceElement[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.StackTrace -->
  <!-- start class org.spf4j.stackmonitor.StackVisualizer -->
  <class name="StackVisualizer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="generateHtmlTable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.base.StackSamples"/>
      <param name="tableWidth" type="int"/>
      <param name="maxDepth" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="generateSvg"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="width" type="int"/>
      <param name="maxDepth" type="int"/>
      <param name="idPfx" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="generateSubSvg"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.base.StackSamples"/>
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="width" type="int"/>
      <param name="maxDepth" type="int"/>
      <param name="idPfx" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[utility class to generate svg and html out of stack samples.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.StackVisualizer -->
  <!-- start class org.spf4j.stackmonitor.THash -->
  <class name="THash" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Externalizable"/>
    <constructor name="THash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>THash</code> instance with the default
 capacity and load factor.]]>
      </doc>
    </constructor>
    <constructor name="THash" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>THash</code> instance with a prime capacity
 at or near the minimum needed to hold <tt>initialCapacity</tt>
 elements with load factor <tt>loadFactor</tt> without triggering
 a rehash.

 @param initialCapacity an <code>int</code> value
 @param loadFactor      a <code>float</code> value]]>
      </doc>
    </constructor>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tells whether this set is currently holding any elements.

 @return a <code>boolean</code> value]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of distinct elements in this collection.

 @return an <code>int</code> value]]>
      </doc>
    </method>
    <method name="capacity" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the current physical capacity of the hash table.]]>
      </doc>
    </method>
    <method name="ensureCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desiredCapacity" type="int"/>
      <doc>
      <![CDATA[Ensure that this hashtable has sufficient capacity to hold
 <tt>desiredCapacity<tt> <b>additional</b> elements without
 requiring a rehash.  This is a tuning method you can call
 before doing a large insert.

 @param desiredCapacity an <code>int</code> value]]>
      </doc>
    </method>
    <method name="removeAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Delete the record at <tt>index</tt>.  Reduces the size of the
 collection by one.

 @param index an <code>int</code> value]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Empties the collection.]]>
      </doc>
    </method>
    <method name="setUp" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[initializes the hashtable to a prime capacity which is at least
 <tt>initialCapacity + 1</tt>.

 @param initialCapacity an <code>int</code> value
 @return the actual capacity chosen]]>
      </doc>
    </method>
    <method name="rehash"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="newCapacity" type="int"/>
      <doc>
      <![CDATA[Rehashes the set.

 @param newCapacity an <code>int</code> value]]>
      </doc>
    </method>
    <method name="computeMaxSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Computes the values of maxSize. There will always be at least
 one free slot required.

 @param capacity an <code>int</code> value]]>
      </doc>
    </method>
    <method name="postInsertHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After an insert, this hook is called to adjust the size/free
 values of the set and to perform rehashing if necessary.

 @param usedFreeSlot the slot]]>
      </doc>
    </method>
    <method name="calculateGrownCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <field name="DEFAULT_LOAD_FACTOR" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the load above which rehashing occurs.]]>
      </doc>
    </field>
    <field name="DEFAULT_CAPACITY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the default initial capacity for the hash table.  This is one
 less than a prime value because one is added to it when
 searching for a prime capacity to account for the free slot
 required by open addressing. Thus, the real default capacity is
 11.]]>
      </doc>
    </field>
    <field name="_size" type="int"
      transient="true" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the current number of occupied slots in the hash.]]>
      </doc>
    </field>
    <field name="_maxSize" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The maximum number of elements allowed without allocating more
 space.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Base class for hashtables that use open addressing to resolve
 collisions.
 removed compaction element to reduce memory footprint.
 use case for this implementation does not have removes.

 Created: Wed Nov 28 21:11:16 2001

 @author Eric D. Friedman
 @author Rob Eden (auto-compaction)
 @author Jeff Randall
 @author zfarkas

 @version $Id: THash.java,v 1.1.2.4 2010/03/02 00:55:34 robeden Exp $]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.THash -->
  <!-- start class org.spf4j.stackmonitor.THashMap -->
  <class name="THashMap" extends="org.spf4j.stackmonitor.TObjectHash"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="gnu.trove.map.TMap"/>
    <implements name="java.io.Externalizable"/>
    <constructor name="THashMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>THashMap</code> instance with the default
 capacity and load factor.]]>
      </doc>
    </constructor>
    <constructor name="THashMap" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>THashMap</code> instance with a prime
 capacity equal to or greater than <tt>initialCapacity</tt> and
 with the default load factor.

 @param initialCapacity an <code>int</code> value]]>
      </doc>
    </constructor>
    <constructor name="THashMap" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>THashMap</code> instance which contains the
 key/value pairs in <tt>map</tt>.

 @param map a <code>Map</code> value]]>
      </doc>
    </constructor>
    <constructor name="THashMap" type="org.spf4j.stackmonitor.THashMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>THashMap</code> instance which contains the
 key/value pairs in <tt>map</tt>.

 @param map a <code>Map</code> value]]>
      </doc>
    </constructor>
    <method name="setUp" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[initialize the value array of the map.

 @param initialCapacity an <code>int</code> value
 @return an <code>int</code> value]]>
      </doc>
    </method>
    <method name="put" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts a key/value pair into the map.

 @param key   an <code>Object</code> value
 @param value an <code>Object</code> value
 @return the previous value associated with <tt>key</tt>,
         or {@code null} if none was found.]]>
      </doc>
    </method>
    <method name="putIfAbsent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts a key/value pair into the map if the specified key is not already
 associated with a value.

 @param key   an <code>Object</code> value
 @param value an <code>Object</code> value
 @return the previous value associated with <tt>key</tt>,
         or {@code null} if none was found.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares this map with another map for equality of their stored
 entries.

 @param other an <code>Object</code> value
 @return a <code>boolean</code> value]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="forEachKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="procedure" type="gnu.trove.procedure.TObjectProcedure"/>
      <doc>
      <![CDATA[Executes <tt>procedure</tt> for each key in the map.

 @param procedure a <code>TObjectProcedure</code> value
 @return false if the loop over the keys terminated because
         the procedure returned false for some key.]]>
      </doc>
    </method>
    <method name="forEachValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="procedure" type="gnu.trove.procedure.TObjectProcedure"/>
      <doc>
      <![CDATA[Executes <tt>procedure</tt> for each value in the map.

 @param procedure a <code>TObjectProcedure</code> value
 @return false if the loop over the values terminated because
         the procedure returned false for some value.]]>
      </doc>
    </method>
    <method name="forEachEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="procedure" type="gnu.trove.procedure.TObjectObjectProcedure"/>
      <doc>
      <![CDATA[Executes <tt>procedure</tt> for each key/value entry in the
 map.

 @param procedure a <code>TObjectObjectProcedure</code> value
 @return false if the loop over the entries terminated because
         the procedure returned false for some entry.]]>
      </doc>
    </method>
    <method name="retainEntries" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="procedure" type="gnu.trove.procedure.TObjectObjectProcedure"/>
      <doc>
      <![CDATA[Retains only those entries in the map for which the procedure
 returns a true value.

 @param procedure determines which entries to keep
 @return true if the map was modified.]]>
      </doc>
    </method>
    <method name="transformValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="gnu.trove.function.TObjectFunction"/>
      <doc>
      <![CDATA[Transform the values in this map using <tt>function</tt>.

 @param function a <code>TObjectFunction</code> value]]>
      </doc>
    </method>
    <method name="rehash"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="newCapacity" type="int"/>
      <doc>
      <![CDATA[rehashes the map to the new capacity.

 @param newCapacity an <code>int</code> value]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[retrieves the value for <tt>key</tt>

 @param key an <code>Object</code> value
 @return the value of <tt>key</tt> or null if no such mapping exists.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Empties the map.]]>
      </doc>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Deletes a key/value pair from the map.

 @param key an <code>Object</code> value
 @return an <code>Object</code> value]]>
      </doc>
    </method>
    <method name="removeAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[removes the mapping at <tt>index</tt> from the map.

 @param index an <code>int</code> value]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view on the values of the map.

 @return a <code>Collection</code> value]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[returns a Set view on the keys of the map.

 @return a <code>Set</code> value]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a Set view on the entries of the map.

 @return a <code>Set</code> value]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="java.lang.Object"/>
      <doc>
      <![CDATA[checks for the presence of <tt>val</tt> in the values of the map.

 @param val an <code>Object</code> value
 @return a <code>boolean</code> value]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[checks for the present of <tt>key</tt> in the keys of the map.

 @param key an <code>Object</code> value
 @return a <code>boolean</code> value]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map"/>
      <doc>
      <![CDATA[copies the key/value mappings in <tt>map</tt> into this map.

 @param map a <code>Map</code> value]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <field name="_values" type="java.lang.Object[]"
      transient="true" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the values of the  map]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An implementation of the Map interface which uses an open addressed
 hash table to store its contents.
 <p/>
 Created: Sun Nov  4 08:52:45 2001

 @author Eric D. Friedman
 @author Rob Eden
 @author Jeff Randall
 @version $Id: THashMap.java,v 1.1.2.8 2010/03/02 04:09:50 robeden Exp $]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.THashMap -->
  <!-- start class org.spf4j.stackmonitor.THashMap.EntryView -->
  <class name="THashMap.EntryView" extends="org.spf4j.stackmonitor.THashMap.MapBackedView"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="EntryView"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry"/>
    </method>
    <method name="containsElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry"/>
    </method>
    <method name="valueForEntry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry"/>
    </method>
    <method name="keyForEntry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry"/>
    </method>
    <doc>
    <![CDATA[a view onto the entries of the map.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.THashMap.EntryView -->
  <!-- start class org.spf4j.stackmonitor.THashMap.KeyView -->
  <class name="THashMap.KeyView" extends="org.spf4j.stackmonitor.THashMap.MapBackedView"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="KeyView"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[a view onto the keys of the map.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.THashMap.KeyView -->
  <!-- start class org.spf4j.stackmonitor.THashMap.ValueView -->
  <class name="THashMap.ValueView" extends="org.spf4j.stackmonitor.THashMap.MapBackedView"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ValueView"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="removeElement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[a view onto the values of the map.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.THashMap.ValueView -->
  <!-- start class org.spf4j.stackmonitor.ThreadSpecificTracingExecutionContextHandler -->
  <class name="ThreadSpecificTracingExecutionContextHandler" extends="org.spf4j.stackmonitor.TracingExecutionContexSampler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThreadSpecificTracingExecutionContextHandler" type="java.util.function.Supplier, java.util.function.Function"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ThreadSpecificTracingExecutionContextHandler" type="int, java.util.function.Supplier, java.util.function.Function"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="prepareThreadsAndContexts" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="currentThreads" type="java.lang.Iterable"/>
    </method>
  </class>
  <!-- end class org.spf4j.stackmonitor.ThreadSpecificTracingExecutionContextHandler -->
  <!-- start class org.spf4j.stackmonitor.ThreadStackSampler -->
  <class name="ThreadStackSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.ISampler"/>
    <constructor name="ThreadStackSampler" type="java.util.function.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ThreadStackSampler" type="int, java.util.function.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollectionsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollections" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A stack sample collector that collects samples only for suppllied threads.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.ThreadStackSampler -->
  <!-- start class org.spf4j.stackmonitor.TObjectHash -->
  <class name="TObjectHash" extends="org.spf4j.stackmonitor.THash"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TObjectHash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>TObjectHash</code> instance with the
 default capacity and load factor.]]>
      </doc>
    </constructor>
    <constructor name="TObjectHash" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new <code>TObjectHash</code> instance whose capacity
 is the next highest prime above <tt>initialCapacity + 1</tt>
 unless that value is already prime.

 @param initialCapacity an <code>int</code> value]]>
      </doc>
    </constructor>
    <method name="capacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="setUp" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[initializes the Object set of this hash table.

 @param initialCapacity an <code>int</code> value
 @return an <code>int</code> value]]>
      </doc>
    </method>
    <method name="forEach" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="procedure" type="gnu.trove.procedure.TObjectProcedure"/>
      <doc>
      <![CDATA[Executes <tt>procedure</tt> for each element in the set.

 @param procedure a <code>TObjectProcedure</code> value
 @return false if the loop over the set terminated because
         the procedure returned false for some value.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Searches the set for <tt>obj</tt>

 @param obj an <code>Object</code> value
 @return a <code>boolean</code> value]]>
      </doc>
    </method>
    <method name="index" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Locates the index of <tt>obj</tt>.

 @param obj an <code>Object</code> value
 @return the index of <tt>obj</tt> or -1 if it isn't in the set.]]>
      </doc>
    </method>
    <method name="insertionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="use {@link #insertKey} instead">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Alias introduced to avoid breaking the API. The new method name insertKey() reflects the
 changes made to the logic.

 @param obj
 @return
 @deprecated use {@link #insertKey} instead]]>
      </doc>
    </method>
    <method name="insertKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Locates the index at which <tt>key</tt> can be inserted.  if
 there is already a value equal()ing <tt>key</tt> in the set,
 returns that value's index as <tt>-index - 1</tt>.
 <p/>
 If a slot is found the value is inserted. When a FREE slot is used the consumeFreeSlot field is
 set to true. This field should be used in the method invoking insertKey() to pass to postInsertHook()

 @param key an <code>Object</code> value
 @return the index of a FREE slot at which key can be inserted
         or, if key is already stored in the hash, the negative value of
         that index, minus 1: -index -1.]]>
      </doc>
    </method>
    <method name="throwObjectContractViolation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="o1" type="java.lang.Object"/>
      <param name="o2" type="java.lang.Object"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Convenience methods for subclasses to use in throwing exceptions about
 badly behaved user objects employed as keys.  We have to throw an
 IllegalArgumentException with a rather verbose message telling the
 user that they need to fix their object implementation to conform
 to the general contract for java.lang.Object.


 @param o1 the first of the equal elements with unequal hash codes.
 @param o2 the second of the equal elements with unequal hash codes.
 @throws IllegalArgumentException the whole point of this method.]]>
      </doc>
    </method>
    <method name="throwObjectContractViolation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="o1" type="java.lang.Object"/>
      <param name="o2" type="java.lang.Object"/>
      <param name="size" type="int"/>
      <param name="oldSize" type="int"/>
      <param name="oldKeys" type="java.lang.Object[]"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Convenience methods for subclasses to use in throwing exceptions about
 badly behaved user objects employed as keys.  We have to throw an
 IllegalArgumentException with a rather verbose message telling the
 user that they need to fix their object implementation to conform
 to the general contract for java.lang.Object.


 @param o1 the first of the equal elements with unequal hash codes.
 @param o2 the second of the equal elements with unequal hash codes.
 @param size
@param oldSize
 @param oldKeys @throws IllegalArgumentException the whole point of this method.]]>
      </doc>
    </method>
    <method name="buildObjectContractViolation" return="java.lang.IllegalArgumentException"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="o1" type="java.lang.Object"/>
      <param name="o2" type="java.lang.Object"/>
      <param name="extra" type="java.lang.String"/>
      <doc>
      <![CDATA[Convenience methods for subclasses to use in throwing exceptions about
 badly behaved user objects employed as keys.  We have to throw an
 IllegalArgumentException with a rather verbose message telling the
 user that they need to fix their object implementation to conform
 to the general contract for java.lang.Object.


 @param o1 the first of the equal elements with unequal hash codes.
 @param o2 the second of the equal elements with unequal hash codes.
 @throws IllegalArgumentException the whole point of this method.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
      <param name="two" type="java.lang.Object"/>
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
    </method>
    <method name="reportPotentialConcurrentMod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="newSize" type="int"/>
      <param name="oldSize" type="int"/>
    </method>
    <method name="dumpExtraInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="newVal" type="java.lang.Object"/>
      <param name="oldVal" type="java.lang.Object"/>
      <param name="currentSize" type="int"/>
      <param name="oldSize" type="int"/>
      <param name="oldKeys" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@param newVal the key being inserted
 @param oldVal the key already stored at that position
 @param currentSize size of the key set during rehashing
 @param oldSize size of the key set before rehashing
 @param oldKeys the old key set]]>
      </doc>
    </method>
    <method name="objectInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <field name="serialVersionUID" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="_set" type="java.lang.Object[]"
      transient="true" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the set of Objects]]>
      </doc>
    </field>
    <field name="REMOVED" type="java.lang.Object"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FREE" type="java.lang.Object"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An open addressed hashing implementation for Object types.
 <p/>
 Created: Sun Nov  4 08:56:06 2001

 @author Eric D. Friedman
 @author Rob Eden
 @author Jeff Randall
 @version $Id: TObjectHash.java,v 1.1.2.6 2009/11/07 03:36:44 robeden Exp $]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.TObjectHash -->
  <!-- start class org.spf4j.stackmonitor.TracingExecutionContexSampler -->
  <class name="TracingExecutionContexSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.ISampler"/>
    <constructor name="TracingExecutionContexSampler" type="java.util.function.Supplier, java.util.function.Function"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TracingExecutionContexSampler" type="int, java.util.function.Supplier, java.util.function.Function"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="prepareThreadsAndContexts" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="currentThreads" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Overwrite to filter what to sample
 @param currentThreads
 @return]]>
      </doc>
    </method>
    <method name="getCollectionsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCollections" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@inherited]]>
      </doc>
    </method>
    <field name="requestFor" type="java.lang.Thread[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="contexts" type="org.spf4j.base.ExecutionContext[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A stack sample collector that collects samples only for code executed within a execution context.
 Plus this collector will attach the samples to the contexts.

 This context requires ProfiledExecutionContextFactory wrapper.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.TracingExecutionContexSampler -->
</package>
<package name="org.spf4j.ssdump2">
  <!-- start class org.spf4j.ssdump2.Converter -->
  <class name="Converter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createLabeledSsdump2FileName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="baseFileName" type="java.lang.String"/>
      <param name="label" type="java.lang.String"/>
    </method>
    <method name="getLabelFromSsdump2FileName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
    </method>
    <method name="convert" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samples" type="java.util.Iterator"/>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="collected" type="org.spf4j.stackmonitor.SampleNode"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="load" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="load" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fis" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="saveLabeledDumps"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="pcollected" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="loadLabeledDumps" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Load samples forrm file containing multiple labeled stack samples.
 @param file the ssdump3 file.
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="loadLabels"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="labalsConsumer" type="java.util.function.Consumer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Load the labels from a ssdump3 file.
 @param file the ssdump3 file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="loadLabeledDump" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="label" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Load samples forrm file containing multiple labeled stack samples.
 @param file the ssdump3 file.
 @return
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ssdump2.Converter -->
</package>
<package name="org.spf4j.failsafe">
  <!-- start interface org.spf4j.failsafe.AsyncRetryExecutor -->
  <interface name="AsyncRetryExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.SyncRetryExecutor"/>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
      <param name="futureSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
    </method>
    <method name="execute"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="defaultAsyncRetryExecutor" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="noRetryAsyncExecutor" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.AsyncRetryExecutor -->
  <!-- start class org.spf4j.failsafe.FibonacciRetryDelaySupplier -->
  <class name="FibonacciRetryDelaySupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.RetryDelaySupplier"/>
    <constructor name="FibonacciRetryDelaySupplier" type="int, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextDelay" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.FibonacciRetryDelaySupplier -->
  <!-- start class org.spf4j.failsafe.GuavaRateLimiter -->
  <class name="GuavaRateLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.PermitSupplier"/>
    <constructor name="GuavaRateLimiter" type="com.google.common.util.concurrent.RateLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getLimiter" return="com.google.common.util.concurrent.RateLimiter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.GuavaRateLimiter -->
  <!-- start class org.spf4j.failsafe.Hedge -->
  <class name="Hedge" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Hedge" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHedgeDelayNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHedgeCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NONE" type="org.spf4j.failsafe.Hedge"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.Hedge -->
  <!-- start interface org.spf4j.failsafe.HedgePolicy -->
  <interface name="HedgePolicy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getHedge" return="org.spf4j.failsafe.Hedge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <field name="NONE" type="org.spf4j.failsafe.HedgePolicy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT" type="org.spf4j.failsafe.HedgePolicy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.HedgePolicy -->
  <!-- start class org.spf4j.failsafe.InvalidRetryPolicyException -->
  <class name="InvalidRetryPolicyException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidRetryPolicyException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InvalidRetryPolicyException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.InvalidRetryPolicyException -->
  <!-- start class org.spf4j.failsafe.LimitingExecutor -->
  <class name="LimitingExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Executor"/>
    <constructor name="LimitingExecutor" type="org.spf4j.concurrent.PermitSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LimitingExecutor" type="org.spf4j.concurrent.Semaphore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LimitingExecutor" type="org.spf4j.failsafe.LimitingExecutor.RejectedExecutionHandler, org.spf4j.concurrent.Semaphore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="execute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="toLimitedCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="getRejectHandler" return="org.spf4j.failsafe.LimitingExecutor.RejectedExecutionHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSemaphore" return="org.spf4j.concurrent.Semaphore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.LimitingExecutor -->
  <!-- start interface org.spf4j.failsafe.LimitingExecutor.RejectedExecutionHandler -->
  <interface name="LimitingExecutor.RejectedExecutionHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="reject" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limiter" type="org.spf4j.failsafe.LimitingExecutor"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.failsafe.LimitingExecutor.RejectedExecutionHandler -->
  <!-- start class org.spf4j.failsafe.NotEnoughTimeToRetry -->
  <class name="NotEnoughTimeToRetry" extends="java.util.concurrent.TimeoutException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NotEnoughTimeToRetry" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NotEnoughTimeToRetry" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[An more specific exception, for the situation when a retry is not practical.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.NotEnoughTimeToRetry -->
  <!-- start interface org.spf4j.failsafe.PartialExceptionRetryPredicate -->
  <interface name="PartialExceptionRetryPredicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.PartialTypedExceptionRetryPredicate"/>
    <doc>
    <![CDATA[Chain-able Exception predicate.
 This predicate will not return a RetryDecision (null) when if want to deffer the retry decision.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.PartialExceptionRetryPredicate -->
  <!-- start interface org.spf4j.failsafe.PartialExceptionRetryPredicateSupplier -->
  <interface name="PartialExceptionRetryPredicateSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.TimedSupplier"/>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface to implement Exception retry rules to be loaded vi aServicveLoader mechanism.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.PartialExceptionRetryPredicateSupplier -->
  <!-- start interface org.spf4j.failsafe.PartialResultRetryPredicate -->
  <interface name="PartialResultRetryPredicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.BiFunction"/>
    <method name="getDecision" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="what" type="java.util.concurrent.Callable"/>
    </method>
    <method name="apply" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <param name="u" type="java.util.concurrent.Callable"/>
    </method>
    <doc>
    <![CDATA[Chainable Result predicate.
 This predicate will not return a RetryDecision (null) when if want to deffer the retry decision.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.PartialResultRetryPredicate -->
  <!-- start interface org.spf4j.failsafe.PartialResultRetryPredicateSupplier -->
  <interface name="PartialResultRetryPredicateSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.TimedSupplier"/>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface to implement Result retry rules
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.PartialResultRetryPredicateSupplier -->
  <!-- start interface org.spf4j.failsafe.PartialTypedExceptionRetryPredicate -->
  <interface name="PartialTypedExceptionRetryPredicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.BiFunction"/>
    <method name="getExceptionDecision" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Throwable"/>
      <param name="what" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[@param value the exception instance to evaluate.
 @param what the callable that failed with the exception.
 @return the retry decision, null implies that this predicate made no decision,
 and will defer to the next predicate]]>
      </doc>
    </method>
    <method name="apply" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="u" type="java.util.concurrent.Callable"/>
    </method>
    <doc>
    <![CDATA[A partial retry predicate for a Callable&lt;T&gt&
 @author Zoltan Farkas
 @param <T> the return type for the Callable that is retried.
 @param <C> the Callable that is retried.
 @param <E> The Exception type that this predicate applies to.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.PartialTypedExceptionRetryPredicate -->
  <!-- start class org.spf4j.failsafe.RateLimiter -->
  <class name="RateLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <implements name="org.spf4j.concurrent.PermitSupplier"/>
    <constructor name="RateLimiter" type="long, java.time.Duration, long, long, java.util.concurrent.TimeUnit"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RateLimiter" type="long, java.time.Duration, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RateLimiter" type="long, java.time.Duration, long, java.util.concurrent.ScheduledExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RateLimiter" type="long, java.time.Duration, long, java.util.concurrent.ScheduledExecutorService, java.util.function.LongSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RateLimiter" type="long, java.time.Duration, long, long, java.util.concurrent.TimeUnit, java.util.concurrent.ScheduledExecutorService, java.util.function.LongSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RateLimiter" type="long, java.time.Duration, long, long, java.util.concurrent.TimeUnit, java.util.concurrent.ScheduledExecutorService, java.util.function.LongSupplier, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[create the rate limiter.

 @param maxAvailablePermits the maximum number of permits that can accumulate.
 @param minReplenishInterval the minimum replenish interval, since a scheduler replenishes the tokens asynchronously
 there is a limit that is relative to the system clock resolution.
 @param tu the time unit of the minimum replenish interval.
 @param scheduler the scheduler to use to replenish the bucket.
 @param nanoTimeSupplier the time supplier.
 @param maxBackoffNanos expected concurrency level]]>
      </doc>
    </constructor>
    <constructor name="RateLimiter" type="long, java.time.Duration, long, long, long, java.util.concurrent.TimeUnit, java.util.concurrent.ScheduledExecutorService, java.util.function.LongSupplier, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[create the rate limiter.

 @param maxAvailablePermits the maximum number of permits that can accumulate.
 @param minReplenishInterval the minimum replenish interval, since a scheduler replenishes the tokens asynchronously
 there is a limit that is relative to the system clock resolution.
 @param tu the time unit of the minimum replenish interval.
 @param scheduler the scheduler to use to replenish the bucket.
 @param nanoTimeSupplier the time supplier.
 @param maxBackoffNanos expected concurrency level]]>
      </doc>
    </constructor>
    <method name="addPermits" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Try to acquire a permit if available.

 @return true if permit acquired. false otherwise.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
    </method>
    <method name="getNrPermits" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquireEx" return="org.spf4j.concurrent.PermitSupplier.Acquisition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquireEx" return="org.spf4j.concurrent.PermitSupplier.Acquisition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPermitsPerReplenishInterval" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPermitReplenishIntervalNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastReplenishmentNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Token bucket algorithm base call rate limiter. see https://en.wikipedia.org/wiki/Token_bucket for more detail.
 Unlike the Guava implementation, the token replenishment is done in a separate thread.
 As such permit acquisition methods have lower overhead
 (no System.nanotime invocation is made when permits available),
 This lower overhead comes at the cost of increasing the cost of RateLimiter object instance. (a scheduled runnable)
 This implementation also uses CAS to update the permit bucket which should yield better concurrency characteristics.
 there is a backoff to handle high contention better as well
 (see https://dzone.com/articles/wanna-get-faster-wait-bit)

 The different in performance can be observed in a benchmark where we try to limit 10000000 ops/s:

 Benchmark                                                                 Mode  Cnt        Score        Error  Units
 com.google.common.util.concurrent.GuavaRateLimiterBenchmark.acquire      thrpt   10  8197739.576 # 163437.214  ops/s
 org.spf4j.failsafe.Spf4jRateLimiterBenchmark.acquire                     thrpt   10  9791489.540 #  89480.010  ops/s

 The Guava implementation cannot really get as close to the desired rate as the spf4j implementation.

 The spf4j implementation tops of at about:

 Benchmark                               Mode  Cnt         Score        Error  Units
 Spf4jRateLimiterBenchmark.acquire      thrpt   10  15270385.653 # 507217.444  ops/s

 these benchmarks are artificial and really measure the overhead of permit acquisition alone without doing anything
 else, real use cases will accompany a permit acquision with some work which impacts the CAS/lock acquisition perf...

 Rate Limiter also implements the PermitSupplier abstraction along with GuavaRateLimiter allowing interchangeability
 between the 2 implementations based on what trade-of work better for you.
 PermitSupplier allows interchangeability and combination with Semaphore (extends PermitSupplier) implementations.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.RateLimiter -->
  <!-- start interface org.spf4j.failsafe.RetryDecision -->
  <interface name="RetryDecision"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="abort" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return abort retry decision, the execution will abort with the last return or exception.]]>
      </doc>
    </method>
    <method name="abortThrow" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Abort operation with a custom Exception.
 @param exception the custom exception.
 @return a Abort decision with a custom Exception.]]>
      </doc>
    </method>
    <method name="abortReturn" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.lang.Object"/>
      <doc>
      <![CDATA[Abort operation and return the provided Object.
 @param result
 @return]]>
      </doc>
    </method>
    <method name="retry" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="retry" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="retryNanos" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="retryDefault" return="org.spf4j.failsafe.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[The default retry algo will be used.
 @param <T>
 @param <C>
 @param callable
 @return]]>
      </doc>
    </method>
    <method name="getDecisionType" return="org.spf4j.failsafe.RetryDecision.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDelayNanos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The delay in nanoseconds, can be negative, if delay value is not decided.
 negative value can be returned only by a Partial retry predicate.]]>
      </doc>
    </method>
    <method name="getResult" return="org.spf4j.base.Either"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The result returned or thrown if applicable. When null the last result(or throwable) is returned.]]>
      </doc>
    </method>
    <method name="getNewCallable" return="java.util.concurrent.Callable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A retry decision the decides to retry, can provide a New Callable to retry.
 @return the Callable that will be retried.]]>
      </doc>
    </method>
    <field name="ABORT" type="org.spf4j.failsafe.RetryDecision.AbortRetryDecision"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.RetryDecision -->
  <!-- start class org.spf4j.failsafe.RetryDecision.AbortRetryDecision -->
  <class name="RetryDecision.AbortRetryDecision" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.RetryDecision"/>
    <method name="getDecisionType" return="org.spf4j.failsafe.RetryDecision.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDelayNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNewCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResult" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.failsafe.RetryDecision.AbortRetryDecision -->
  <!-- start class org.spf4j.failsafe.RetryDecision.Type -->
  <class name="RetryDecision.Type" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.failsafe.RetryDecision.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.failsafe.RetryDecision.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="Abort" type="org.spf4j.failsafe.RetryDecision.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do not retry operation]]>
      </doc>
    </field>
    <field name="Retry" type="org.spf4j.failsafe.RetryDecision.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retry operation]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.failsafe.RetryDecision.Type -->
  <!-- start interface org.spf4j.failsafe.RetryDecisionFactory -->
  <interface name="RetryDecisionFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="abort" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="abortThrow" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Throwable"/>
    </method>
    <method name="abortReturn" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="retry" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="retry" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="retryNanos" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="retryDefault" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.RetryDecisionFactory -->
  <!-- start interface org.spf4j.failsafe.RetryDelaySupplier -->
  <interface name="RetryDelaySupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.LongSupplier"/>
    <method name="nextDelay" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAsLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.RetryDelaySupplier -->
  <!-- start class org.spf4j.failsafe.RetryPolicies -->
  <class name="RetryPolicies" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getRetryPredicateSupplier" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getResultRetryPredicateSupplier" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resultName" type="java.lang.String"/>
      <param name="rp" type="org.spf4j.failsafe.avro.RetryParams"/>
      <param name="resultMatcherSupplier" type="org.spf4j.base.ResultMatchers.Supplier"/>
    </method>
    <method name="create" return="org.spf4j.failsafe.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="org.spf4j.failsafe.avro.RetryPolicy"/>
      <exception name="InvalidRetryPolicyException" type="org.spf4j.failsafe.InvalidRetryPolicyException"/>
    </method>
    <method name="create" return="org.spf4j.failsafe.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="org.spf4j.failsafe.avro.RetryPolicy"/>
      <param name="resultMatcherSupplier" type="org.spf4j.base.ResultMatchers.Supplier"/>
      <exception name="InvalidRetryPolicyException" type="org.spf4j.failsafe.InvalidRetryPolicyException"/>
      <doc>
      <![CDATA[Create a retry policy with a custom result MatcherSupplier.
 this allows use of custom resolution to result matcher names.
 @param <T>
 @param <C>
 @param policy the retry policy serializable representation.
 @param resultMatcherSupplier - a resolvers that resolvers the referenced named matchers in the policy
 @return
 @throws InvalidRetryPolicyException]]>
      </doc>
    </method>
    <method name="createBuilder" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="org.spf4j.failsafe.avro.RetryPolicy"/>
      <param name="resultMatcherSupplier" type="org.spf4j.base.ResultMatchers.Supplier"/>
      <exception name="InvalidRetryPolicyException" type="org.spf4j.failsafe.InvalidRetryPolicyException"/>
    </method>
    <method name="addRetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.spf4j.failsafe.RetryPolicy.Builder"/>
      <param name="policy" type="org.spf4j.failsafe.avro.RetryPolicy"/>
      <param name="resultMatcherSupplier" type="org.spf4j.base.ResultMatchers.Supplier"/>
      <exception name="InvalidRetryPolicyException" type="org.spf4j.failsafe.InvalidRetryPolicyException"/>
    </method>
    <method name="toInvocable" return="javax.script.Invocable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="engine" type="javax.script.ScriptEngine"/>
      <param name="script" type="java.lang.String"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
      <doc>
      <![CDATA[Scripted predicates are not there for application users to modify.
 Scripted predicates should be written by Operation engineers.
 The script engine choice needs to be carefully done as to not allow even ops to do bad stuff by mistake.
 (calling system.exit, etc...)
 The main reason for allowing scripted predicates is deployment speed.
 (a config change will propagates to your fleet several order of magnitudes faster than binaries,
 and will not require a process restart)
 Now this speed means also any stupid stuff can propagate faster, so canarying a config change is also a must.
 @param engine
 @param script
 @return
 @throws ScriptException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[a Factory with retry named retry Rules.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.RetryPolicies -->
  <!-- start class org.spf4j.failsafe.RetryPolicy -->
  <class name="RetryPolicy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.SyncRetryExecutor"/>
    <method name="noRetryPolicy" return="org.spf4j.failsafe.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="defaultPolicy" return="org.spf4j.failsafe.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="startNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="async" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="exec" type="org.spf4j.failsafe.concurrent.FailSafeExecutor"/>
    </method>
    <method name="async" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="hedgePolicy" type="org.spf4j.failsafe.HedgePolicy"/>
      <param name="exec" type="org.spf4j.failsafe.concurrent.FailSafeExecutor"/>
    </method>
    <method name="async" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="hedgePolicy" type="java.util.function.Function"/>
      <param name="exec" type="org.spf4j.failsafe.concurrent.FailSafeExecutor"/>
    </method>
    <method name="async" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="retry" type="java.util.function.Function"/>
      <param name="hedgePolicy" type="java.util.function.Function"/>
      <param name="exec" type="org.spf4j.failsafe.concurrent.FailSafeExecutor"/>
    </method>
    <method name="async" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRetryPredicate" return="org.spf4j.failsafe.RetryPredicate"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return string representation of policy.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a retry policy builder.

 @param <T> the Type returned by the retried callables.
 @param <C> the type of the Callable's returned.
 @return]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.spf4j.failsafe.RetryPolicy.Builder"/>
      <doc>
      <![CDATA[Create a retry policy builder copy.

 @param <T> the Type returned by the retried callables.
 @param <C> the type of the Callable's returned.
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.RetryPolicy -->
  <!-- start class org.spf4j.failsafe.RetryPolicy.Builder -->
  <class name="RetryPolicy.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="withRetryLogger" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="plog" type="org.slf4j.Logger"/>
    </method>
    <method name="withoutRetryLogger" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withDefaultThrowableRetryPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withDefaultThrowableRetryPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxNrRetries" type="int"/>
    </method>
    <method name="withRetryOnException" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="withRetryOnException" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="maxRetries" type="int"/>
    </method>
    <method name="withRetryOnException" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="maxTime" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="withExceptionPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="org.spf4j.failsafe.PartialExceptionRetryPredicate"/>
      <param name="maxTime" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="withExceptionPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="org.spf4j.failsafe.PartialExceptionRetryPredicate"/>
    </method>
    <method name="withExceptionPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="predicate" type="org.spf4j.failsafe.PartialTypedExceptionRetryPredicate"/>
    </method>
    <method name="withExceptionPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="predicate" type="org.spf4j.failsafe.PartialTypedExceptionRetryPredicate"/>
      <param name="maxRetries" type="int"/>
    </method>
    <method name="withExceptionPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="org.spf4j.failsafe.PartialExceptionRetryPredicate"/>
      <param name="maxRetries" type="int"/>
    </method>
    <method name="withExceptionPartialPredicateSupplier" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="withExceptionStatefulPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="withExceptionPartialPredicateSupplier" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="org.spf4j.failsafe.TimedSupplier"/>
    </method>
    <method name="withExceptionStatefulPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="org.spf4j.failsafe.TimedSupplier"/>
    </method>
    <method name="withRetryOnResult" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.lang.Object"/>
      <param name="maxRetries" type="int"/>
    </method>
    <method name="withResultPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="org.spf4j.failsafe.PartialResultRetryPredicate"/>
    </method>
    <method name="withResultPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="predicate" type="org.spf4j.failsafe.PartialResultRetryPredicate"/>
    </method>
    <method name="withResultPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="org.spf4j.failsafe.PartialResultRetryPredicate"/>
      <param name="maxRetries" type="int"/>
    </method>
    <method name="withResultPartialPredicateSupplier" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="withResultStatefulPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="withResultPartialPredicateSupplier" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="org.spf4j.failsafe.TimedSupplier"/>
    </method>
    <method name="withResultStatefulPartialPredicate" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicateSupplier" type="org.spf4j.failsafe.TimedSupplier"/>
    </method>
    <method name="withJitterFactor" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jitterfactor" type="double"/>
    </method>
    <method name="withInitialRetries" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use withInitialImmediateRetries instead.">
      <param name="retries" type="int"/>
      <doc>
      <![CDATA[@deprecated use withInitialImmediateRetries instead.]]>
      </doc>
    </method>
    <method name="withInitialImmediateRetries" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="retries" type="int"/>
    </method>
    <method name="withInitialDelay" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="withMaxDelay" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="withMaxExceptionChain" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxExChain" type="int"/>
    </method>
    <method name="copy" return="org.spf4j.failsafe.RetryPolicy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.spf4j.failsafe.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildAsync" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildAsync" return="org.spf4j.failsafe.AsyncRetryExecutor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="es" type="org.spf4j.failsafe.concurrent.FailSafeExecutor"/>
    </method>
  </class>
  <!-- end class org.spf4j.failsafe.RetryPolicy.Builder -->
  <!-- start interface org.spf4j.failsafe.RetryPredicate -->
  <interface name="RetryPredicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDecision" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="what" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[Get the RetryDecision for the result value returned by Callable C.
 @param value the operation result.
 @param what the operation.
 @return the retry decision.]]>
      </doc>
    </method>
    <method name="getExceptionDecision" return="org.spf4j.failsafe.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Throwable"/>
      <param name="what" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[Get the retryDecision for the exceptional result of a Callable C.
 @param value the Exception instance.
 @param what the callable that failed.
 @return the retry decision.]]>
      </doc>
    </method>
    <field name="NORETRY" type="org.spf4j.failsafe.RetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Simple predicate that does not retry anything.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A retry predicate.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.RetryPredicate -->
  <!-- start interface org.spf4j.failsafe.SyncRetryExecutor -->
  <interface name="SyncRetryExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="startNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="java.util.concurrent.Callable"/>
      <param name="retryPredicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <param name="maxExceptionChain" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Naive implementation of execution with retry logic. a callable will be executed and retry attempted in current
 thread if the result and exception predicates. before retry, a callable can be executed that can abort the retry
 and finish the function with the previous result.

 @param <T> - The type of callable to retry result;
 @param <EX> - the exception thrown by the callable to retry.
 @param pwhat - the callable to retry.
 @return the result of the retried callable if successful.
 @throws java.lang.InterruptedException - thrown if retry interrupted.
 @throws EX - the exception thrown by callable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.SyncRetryExecutor -->
  <!-- start interface org.spf4j.failsafe.TimedSupplier -->
  <interface name="TimedSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="constant" return="org.spf4j.failsafe.TimedSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="fromSupplier" return="org.spf4j.failsafe.TimedSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="java.util.function.Supplier"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.TimedSupplier -->
  <!-- start class org.spf4j.failsafe.TimeoutRelativeHedge -->
  <class name="TimeoutRelativeHedge" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.HedgePolicy"/>
    <constructor name="TimeoutRelativeHedge" type="int, long, long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimeoutRelativeHedge" type="org.spf4j.failsafe.avro.TimeoutRelativeHedgePolicy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHedge" return="org.spf4j.failsafe.Hedge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.TimeoutRelativeHedge -->
  <!-- start class org.spf4j.failsafe.TypeBasedRetryDelaySupplier -->
  <class name="TypeBasedRetryDelaySupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Function"/>
    <constructor name="TypeBasedRetryDelaySupplier" type="java.util.function.Function"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="apply" return="org.spf4j.failsafe.RetryDelaySupplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A retry Delay supplier that will provide the same instance of a RetryDelaySupplier for a
 particular java class.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.TypeBasedRetryDelaySupplier -->
</package>
<package name="org.spf4j.perf.impl.acc">
  <!-- start class org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator -->
  <class name="AbstractMeasurementAccumulator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementAccumulator"/>
    <constructor name="AbstractMeasurementAccumulator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="recordAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long"/>
    </method>
    <method name="getMinTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator -->
  <!-- start class org.spf4j.perf.impl.acc.AddAndCountAccumulator -->
  <class name="AddAndCountAccumulator" extends="org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AddAndCountAccumulator" type="java.lang.Object, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="increment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.acc.AddAndCountAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.impl.acc.AddAndCountAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.AddAndCountAccumulator -->
  <!-- start class org.spf4j.perf.impl.acc.CountAccumulator -->
  <class name="CountAccumulator" extends="org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountAccumulator" type="java.lang.Object, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="increment"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.acc.CountAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.impl.acc.CountAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.CountAccumulator -->
  <!-- start class org.spf4j.perf.impl.acc.DirectStoreAccumulator -->
  <class name="DirectStoreAccumulator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.CloseableMeasurementRecorder"/>
    <implements name="org.spf4j.perf.JmxSupport"/>
    <constructor name="DirectStoreAccumulator" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DirectStoreAccumulator" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore, org.spf4j.tsdb2.avro.MeasurementType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DirectStoreAccumulator" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore, org.spf4j.tsdb2.avro.MeasurementType, org.spf4j.tsdb2.avro.Aggregation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="recordAt"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long"/>
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRecorded" return="org.spf4j.perf.impl.acc.DirectStoreAccumulator.RecordedValue"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.DirectStoreAccumulator -->
  <!-- start class org.spf4j.perf.impl.acc.DirectStoreAccumulator.RecordedValue -->
  <class name="DirectStoreAccumulator.RecordedValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="RecordedValue" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTs" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.DirectStoreAccumulator.RecordedValue -->
  <!-- start class org.spf4j.perf.impl.acc.DirectStoreMultiAccumulator -->
  <class name="DirectStoreMultiAccumulator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MultiMeasurementRecorder"/>
    <implements name="java.io.Closeable"/>
    <implements name="org.spf4j.perf.JmxSupport"/>
    <constructor name="DirectStoreMultiAccumulator" type="org.spf4j.perf.MeasurementsInfo, org.spf4j.perf.MeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long[]"/>
    </method>
    <method name="recordAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long[]"/>
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRecorded" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.DirectStoreMultiAccumulator -->
  <!-- start class org.spf4j.perf.impl.acc.MinMaxAvgAccumulator -->
  <class name="MinMaxAvgAccumulator" extends="org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MinMaxAvgAccumulator" type="java.lang.Object, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.acc.MinMaxAvgAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.impl.acc.MinMaxAvgAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.MinMaxAvgAccumulator -->
  <!-- start class org.spf4j.perf.impl.acc.QuantizedAccumulator -->
  <class name="QuantizedAccumulator" extends="org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="QuantizedAccumulator" type="java.lang.Object, java.lang.String, java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a quantized accumulator.
 factor = 10
 lowMagnitude = -2
 higherMagnitude = 2
 quantasPerMagnitude = 10

 results in -100 -90 -80 .. -10 -9 -8  .. -1 0 1 2 .. 9 10 20 30 .. 100

 @param measuredEntity - and object representing the thing we accumulate measurements for.
 @param description - description of the thing we accumulate measurements for.
 @param unitOfMeasurement - unit of measurement.
 @param factor
 @param lowerMagnitude the lower end of the quantized recording (lowerMagnitude/lowerMagnitude) * factor ^
 |lowerMagnitude|
 @param higherMagnitude the higher end of the quantized recording (higherMagnitude/higherMagnitude) * factor ^
 |higherMagnitude|
 @param quantasPerMagnitude number of buckets / magnitude]]>
      </doc>
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.acc.QuantizedAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.impl.acc.QuantizedAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxMeasurement" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementCount" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementTotal" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMinMeasurement" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQuatizedMeasurements" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[inspired by DTrace LLQUANTIZE

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.acc.QuantizedAccumulator -->
</package>
<package name="org.spf4j.ssdump2.avro">
</package>
<package name="org.spf4j.concurrent">
  <!-- start class org.spf4j.concurrent.AtomicReferenceExt -->
  <class name="AtomicReferenceExt" extends="java.util.concurrent.atomic.AtomicReference"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomicReferenceExt" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AtomicReferenceExt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="update" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="java.util.function.UnaryOperator"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.AtomicReferenceExt -->
  <!-- start class org.spf4j.concurrent.Atomics -->
  <class name="Atomics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="update" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ar" type="java.util.concurrent.atomic.AtomicReference"/>
      <param name="function" type="java.util.function.UnaryOperator"/>
    </method>
    <method name="maybeAccumulate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dval" type="java.util.concurrent.atomic.AtomicLong"/>
      <param name="x" type="double"/>
      <param name="accumulatorFunction" type="java.util.function.DoubleBinaryOperator"/>
      <param name="maxBackoffNanos" type="int"/>
    </method>
    <method name="accumulate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dval" type="java.util.concurrent.atomic.AtomicLong"/>
      <param name="x" type="double"/>
      <param name="accumulatorFunction" type="java.util.function.DoubleBinaryOperator"/>
      <param name="maxBackoffNanos" type="int"/>
    </method>
    <method name="accumulate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dval" type="java.util.concurrent.atomic.AtomicLong"/>
      <param name="x" type="long"/>
      <param name="accumulatorFunction" type="java.util.function.LongBinaryOperator"/>
      <param name="maxBackoffNanos" type="int"/>
    </method>
    <method name="maybeAccumulate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dval" type="java.util.concurrent.atomic.AtomicLong"/>
      <param name="accumulatorFunction" type="java.util.function.DoubleUnaryOperator"/>
      <param name="maxBackoffNanos" type="int"/>
    </method>
    <method name="maybeAccumulate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dval" type="java.util.concurrent.atomic.AtomicLong"/>
      <param name="val" type="long"/>
      <param name="accumulatorFunction" type="java.util.function.LongBinaryOperator"/>
      <param name="maxBackoffNanos" type="int"/>
    </method>
    <field name="MAX_BACKOFF_NANOS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.Atomics -->
  <!-- start class org.spf4j.concurrent.AtomicSequence -->
  <class name="AtomicSequence" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Sequence"/>
    <constructor name="AtomicSequence" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="next" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.AtomicSequence -->
  <!-- start class org.spf4j.concurrent.CompoundPermitSupplier -->
  <class name="CompoundPermitSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.PermitSupplier"/>
    <constructor name="CompoundPermitSupplier" type="org.spf4j.concurrent.PermitSupplier[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquireEx" return="org.spf4j.concurrent.PermitSupplier.Acquisition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[allows to combine various resource limiters/semahores
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.CompoundPermitSupplier -->
  <!-- start class org.spf4j.concurrent.CompoundSemaphore -->
  <class name="CompoundSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="CompoundSemaphore" type="org.spf4j.concurrent.Semaphore[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getSemaphores" return="org.spf4j.concurrent.Semaphore[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[allows to combine various resource limiters/semahores
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.CompoundSemaphore -->
  <!-- start class org.spf4j.concurrent.ConcurrentStack -->
  <class name="ConcurrentStack" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConcurrentStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="java.lang.Object"/>
    </method>
    <method name="pop" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Treiber stack.
 @author Zoltan Farkas
 @param <E>]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ConcurrentStack -->
  <!-- start class org.spf4j.concurrent.ContextPropagatingCompletableFuture -->
  <class name="ContextPropagatingCompletableFuture" extends="org.spf4j.concurrent.InterruptibleCompletableFuture"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContextPropagatingCompletableFuture" type="org.spf4j.base.ExecutionContext, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="thenApply" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="thenApplyAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="thenApplyAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="thenAccept" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.Consumer"/>
    </method>
    <method name="thenAcceptAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.Consumer"/>
    </method>
    <method name="thenAcceptAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.Consumer"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="thenRun" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.lang.Runnable"/>
    </method>
    <method name="thenRunAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.lang.Runnable"/>
    </method>
    <method name="thenRunAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="thenCombine" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="fn" type="java.util.function.BiFunction"/>
    </method>
    <method name="thenCombineAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="fn" type="java.util.function.BiFunction"/>
    </method>
    <method name="thenCombineAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="fn" type="java.util.function.BiFunction"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="thenAcceptBoth" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.util.function.BiConsumer"/>
    </method>
    <method name="thenAcceptBothAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.util.function.BiConsumer"/>
    </method>
    <method name="thenAcceptBothAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.util.function.BiConsumer"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="runAfterBoth" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.lang.Runnable"/>
    </method>
    <method name="runAfterBothAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.lang.Runnable"/>
    </method>
    <method name="runAfterBothAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="applyToEither" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="applyToEitherAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="applyToEitherAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="fn" type="java.util.function.Function"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="acceptEither" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.util.function.Consumer"/>
    </method>
    <method name="acceptEitherAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.util.function.Consumer"/>
    </method>
    <method name="acceptEitherAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.util.function.Consumer"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="runAfterEither" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.lang.Runnable"/>
    </method>
    <method name="runAfterEitherAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.lang.Runnable"/>
    </method>
    <method name="runAfterEitherAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.util.concurrent.CompletionStage"/>
      <param name="action" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="thenCompose" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="thenComposeAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="thenComposeAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="exceptionally" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.Function"/>
    </method>
    <method name="whenComplete" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.BiConsumer"/>
    </method>
    <method name="whenCompleteAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.BiConsumer"/>
    </method>
    <method name="whenCompleteAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.BiConsumer"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="handle" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.BiFunction"/>
    </method>
    <method name="handleAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.BiFunction"/>
    </method>
    <method name="handleAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fn" type="java.util.function.BiFunction"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="toCompletableFuture" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="completeAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="java.util.function.Supplier"/>
      <doc>
      <![CDATA[JDK 11.]]>
      </doc>
    </method>
    <method name="completeAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="java.util.function.Supplier"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[JDK 11.]]>
      </doc>
    </method>
    <method name="newIncompleteFuture" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[JDK 11!]]>
      </doc>
    </method>
    <method name="supplyAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.util.function.Supplier"/>
    </method>
    <method name="supplyAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.util.function.Supplier"/>
      <param name="e" type="java.util.concurrent.Executor"/>
    </method>
    <method name="supplyAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.util.function.Supplier"/>
      <param name="e" type="java.util.concurrent.Executor"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="supplyAsync" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.util.function.Supplier"/>
      <param name="current" type="org.spf4j.base.ExecutionContext"/>
      <param name="e" type="java.util.concurrent.Executor"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="completedFuture" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="completedFuture" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentContext" type="org.spf4j.base.ExecutionContext"/>
      <param name="deadlinenanos" type="long"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A Completable future that will wrap all Functions to properly propagate ExecutionContext.
 see CompletableFuture javadoc for more detail.

 This works properly only in JDK 11.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ContextPropagatingCompletableFuture -->
  <!-- start class org.spf4j.concurrent.ContextPropagatingExecutorService -->
  <class name="ContextPropagatingExecutorService" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <implements name="org.spf4j.base.Wrapper"/>
    <constructor name="ContextPropagatingExecutorService" type="java.util.concurrent.ExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <method name="invokeAll" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAll" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAny" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="invokeAny" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWrapped" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Overwrite as needed for a ScheduledExecutorService, etc]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ContextPropagatingExecutorService -->
  <!-- start class org.spf4j.concurrent.ContextPropagatingScheduledExecutorService -->
  <class name="ContextPropagatingScheduledExecutorService" extends="org.spf4j.concurrent.ContextPropagatingExecutorService"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ScheduledExecutorService"/>
    <constructor name="ContextPropagatingScheduledExecutorService" type="java.util.concurrent.ScheduledExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="schedule" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="schedule" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="scheduleAtFixedRate" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="initialDelay" type="long"/>
      <param name="period" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="scheduleWithFixedDelay" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="initialDelay" type="long"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getWrapped" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Execution context propagating Scheduled executor.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ContextPropagatingScheduledExecutorService -->
  <!-- start interface org.spf4j.concurrent.ContextPropagator -->
  <interface name="ContextPropagator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="wrap" return="java.util.concurrent.Callable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.concurrent.Callable"/>
    </method>
    <method name="wrap" return="java.lang.Runnable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="wrap" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
    </method>
    <method name="wrap" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.ContextPropagator -->
  <!-- start class org.spf4j.concurrent.CustomThreadFactory -->
  <class name="CustomThreadFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ThreadFactory"/>
    <constructor name="CustomThreadFactory" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CustomThreadFactory" type="java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The default thread factory]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.CustomThreadFactory -->
  <!-- start class org.spf4j.concurrent.DefaultContextAwareExecutor -->
  <class name="DefaultContextAwareExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="instance" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultContextAwareExecutor -->
  <!-- start class org.spf4j.concurrent.DefaultContextAwareScheduledExecutor -->
  <class name="DefaultContextAwareScheduledExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="instance" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultContextAwareScheduledExecutor -->
  <!-- start class org.spf4j.concurrent.DefaultExecutor -->
  <class name="DefaultExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="instance" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="java.util.concurrent.ExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This executor aims to be a general purpose executor for async tasks. (equivalent to ForkJoinPool.commonPool())

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultExecutor -->
  <!-- start class org.spf4j.concurrent.DefaultScheduler -->
  <class name="DefaultScheduler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="instance" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listenableInstance" return="com.google.common.util.concurrent.ListeningScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="scheduleAllignedAtFixedRateMillis" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="millisInterval" type="long"/>
      <doc>
      <![CDATA[this will schedule a runnable aligned to the hour or day at a fixed rate.

 @param command - the Runnable to execute.
 @param millisInterval - the schedule interval in milliseconds.
 @return - Future that allows to cancel the schedule.]]>
      </doc>
    </method>
    <field name="INSTANCE" type="java.util.concurrent.ScheduledExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LISTENABLE_INSTANCE" type="com.google.common.util.concurrent.ListeningScheduledExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultScheduler -->
  <!-- start class org.spf4j.concurrent.FileBasedLock -->
  <class name="FileBasedLock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.locks.Lock"/>
    <implements name="java.io.Closeable"/>
    <method name="extractPosixPermissions" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileAttributes" type="java.nio.file.attribute.FileAttribute[]"/>
    </method>
    <method name="getLock" return="org.spf4j.concurrent.FileBasedLock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockFile" type="java.io.File"/>
      <param name="fileAttributes" type="java.nio.file.attribute.FileAttribute[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a FileBasedLock implementation.

 FileBasedLock will hold onto a File Descriptor during the entire life of the instance.
 FileBasedLock is a reentrant lock. (it can be acquired multiple times by the same thread)

 @param lockFile the file to lock on.
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLock" return="org.spf4j.concurrent.FileBasedLock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lockInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newCondition" return="java.util.concurrent.locks.Condition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[will release lock if owned, will not nothing if not owned.]]>
      </doc>
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Throwable" type="java.lang.Throwable"/>
    </method>
    <method name="getContextInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLocalHoldCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isHeldByCurrentThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_FILE_ATTRS" type="java.nio.file.attribute.FileAttribute[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[File based Lock implementation, that can be used as IPC method.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.FileBasedLock -->
  <!-- start class org.spf4j.concurrent.FutureBean -->
  <class name="FutureBean" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="use FutureTask instead.">
    <implements name="java.util.concurrent.Future"/>
    <constructor name="FutureBean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
      <doc>
      <![CDATA[May overwrite if extra actions on cancel are desired.]]>
      </doc>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResultStore" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="processResult" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.spf4j.base.Either"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="setExceptionResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="setCancelationResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.util.concurrent.CancellationException"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[bean like implementation of a future that is not cancellable.
 @author zoly
 @deprecated use FutureTask instead.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.FutureBean -->
  <!-- start class org.spf4j.concurrent.Futures -->
  <class name="Futures" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
      <param name="from" type="int"/>
    </method>
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="iterator" type="java.util.Iterator"/>
    </method>
    <method name="getAll" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="consumer" type="java.util.function.BiConsumer"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
      <doc>
      <![CDATA[@param deadlineNanos
 @param futures
 @return]]>
      </doc>
    </method>
    <method name="getAllWithDeadlineNanosRetVoid" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
      <doc>
      <![CDATA[Gets all futures resuls for futures that return Void (no return).

 @param deadlineNanos
 @param futures
 @return]]>
      </doc>
    </method>
    <method name="getAll" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="consumer" type="java.util.function.BiConsumer"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <method name="timedOutFutures" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="copies" type="int"/>
      <param name="ex" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.Futures -->
  <!-- start class org.spf4j.concurrent.InterruptibleCompletableFuture -->
  <class name="InterruptibleCompletableFuture" extends="java.util.concurrent.CompletableFuture"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InterruptibleCompletableFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="setToCancel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toCancel" type="java.util.concurrent.Future"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Overwrite as needed.
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A completable Future that wraps a Future that will provide the results for this.
 When the wrapped Future completes it will invoke complete to complete this task.
 see CompletableFuture for more info.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.InterruptibleCompletableFuture -->
  <!-- start interface org.spf4j.concurrent.LifoThreadPool -->
  <interface name="LifoThreadPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <method name="exportJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCoreThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadPriority" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[See LifoThreadPoolBuilder for creating lifo  thread pools.

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.LifoThreadPool -->
  <!-- start class org.spf4j.concurrent.LifoThreadPoolBuilder -->
  <class name="LifoThreadPoolBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withPoolName" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="poolName" type="java.lang.String"/>
    </method>
    <method name="withCoreSize" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coreSize" type="int"/>
    </method>
    <method name="withMaxSize" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxSize" type="int"/>
    </method>
    <method name="withMaxIdleTimeMillis" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="withQueueSizeLimit" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="withDaemonThreads" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="withSpinLockCount" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spinLockCount" type="int"/>
    </method>
    <method name="withRejectionHandler" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rejectionHandler" type="org.spf4j.concurrent.RejectedExecutionHandler"/>
    </method>
    <method name="withThreadPriority" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <method name="mutable" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enableJmx" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.spf4j.concurrent.LifoThreadPool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildMutable" return="org.spf4j.concurrent.MutableLifoThreadPool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LifoThreadPoolBuilder -->
  <!-- start class org.spf4j.concurrent.LifoThreadPoolExecutorSQP -->
  <class name="LifoThreadPoolExecutorSQP" extends="java.util.concurrent.AbstractExecutorService"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.MutableLifoThreadPool"/>
    <constructor name="LifoThreadPoolExecutorSQP" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean, org.spf4j.concurrent.RejectedExecutionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean, org.spf4j.concurrent.RejectedExecutionHandler, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="exportJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCoreThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDaemonThreads"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="setMaxIdleTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="setMaxThreadCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxThreadCount" type="int"/>
    </method>
    <method name="setCoreThreadCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coreThreadCount" type="int"/>
    </method>
    <method name="setQueueSizeLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="setThreadPriority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadPriority" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[LIFO scheduled java thread pool, this behavior is identical  with the JDK's fork join pool, but different from the
 older jdk ThreadPoolExecutor implementations.

 This implementation behaves differently compared with a java Thread pool in that it prefers to spawn a
 thread if possible instead of queueing a task when nr of threads has room to grow.

 Performance of this pool implementation is similar to ThreadPoolExecutor however due to LIFO scheduling,
 it will have lower resource usage in most use cases.

 The JDK Fork Join pool's performance is superior to this implementation, however unlike this implementation,
 with the fork join pool you will not be able to cancel+interrupt running tasks.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LifoThreadPoolExecutorSQP -->
  <!-- start class org.spf4j.concurrent.LocalSemaphore -->
  <class name="LocalSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="LocalSemaphore" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A process level semaphore implementation based on the JDK semaphore.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LocalSemaphore -->
  <!-- start class org.spf4j.concurrent.LockRuntimeException -->
  <class name="LockRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LockRuntimeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LockRuntimeException -->
  <!-- start interface org.spf4j.concurrent.MutableLifoThreadPool -->
  <interface name="MutableLifoThreadPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.LifoThreadPool"/>
    <method name="setDaemonThreads"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="setMaxIdleTimeMillis"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="setCoreThreadCount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coreThreadCount" type="int"/>
    </method>
    <method name="setMaxThreadCount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxThreadCount" type="int"/>
    </method>
    <method name="setQueueSizeLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="setThreadPriority"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.MutableLifoThreadPool -->
  <!-- start interface org.spf4j.concurrent.PermitSupplier -->
  <interface name="PermitSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Acquire one permit.

 @param timeout time to wait for permit to become available.
 @param unit units of time.
 @throws InterruptedException - operation interrupted.
 @throws TimeoutException - timed out.]]>
      </doc>
    </method>
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Acquire a arbitrary number of permits.

 @param nrPermits - numer of permits to acquire.
 @param timeout - time to wait for permit to become available.
 @param unit - units of time.
 @throws InterruptedException - operation interrupted.
 @throws TimeoutException - timed out.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[try to acquire a permit.

 @param timeout time to wait for permit to become available.
 @param unit units of time.
 @return true if permit acquired, false if timed out.
 @throws InterruptedException - operation interrupted.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[try to acquire a number of permits.

 @param nrPermits number of permits to acquire.
 @param timeout time to wait for permits to become available.
 @param unit units of time.
 @return true if permits acquired, false if timed out.
 @throws InterruptedException - operation interrupted.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquireEx" return="org.spf4j.concurrent.PermitSupplier.Acquisition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryAcquireEx" return="org.spf4j.concurrent.PermitSupplier.Acquisition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="addPermits" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <doc>
      <![CDATA[@param nrPermits
 @return true if at least one permit is added.]]>
      </doc>
    </method>
    <method name="toSemaphore" return="org.spf4j.concurrent.Semaphore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="UNLIMITED" type="org.spf4j.concurrent.PermitSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY" type="org.spf4j.concurrent.PermitSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.PermitSupplier -->
  <!-- start interface org.spf4j.concurrent.PermitSupplier.Acquisition -->
  <interface name="PermitSupplier.Acquisition"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="failed" return="org.spf4j.concurrent.PermitSupplier.Acquisition"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nanosUntilAvailable" type="long"/>
    </method>
    <method name="isSuccess" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true is permit acquisition request successful. false otherwise.]]>
      </doc>
    </method>
    <method name="permitAvailableEstimateInNanos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return if acquisition not successful the number of nanos in which permits will be available. -1L if N/A]]>
      </doc>
    </method>
    <field name="SUCCESS" type="org.spf4j.concurrent.PermitSupplier.Acquisition"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.concurrent.PermitSupplier.Acquisition -->
  <!-- start interface org.spf4j.concurrent.RejectedExecutionHandler -->
  <interface name="RejectedExecutionHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="rejectedExecution"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
      <param name="executor" type="org.spf4j.concurrent.LifoThreadPool"/>
    </method>
    <field name="REJECT_EXCEPTION_EXEC_HANDLER" type="org.spf4j.concurrent.RejectedExecutionHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RUN_IN_CALLER_EXEC_HANDLER" type="org.spf4j.concurrent.RejectedExecutionHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.RejectedExecutionHandler -->
  <!-- start interface org.spf4j.concurrent.RestartableService -->
  <interface name="RestartableService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <implements name="java.lang.AutoCloseable"/>
    <method name="getServiceName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[THis is only a marker interface that will let you know that this Guava service is restartable.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.RestartableService -->
  <!-- start class org.spf4j.concurrent.RestartableServiceImpl -->
  <class name="RestartableServiceImpl" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.RestartableService"/>
    <constructor name="RestartableServiceImpl" type="com.google.common.base.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerToJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jmxStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jmxStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.RestartableServiceImpl -->
  <!-- start class org.spf4j.concurrent.ScalableSequence -->
  <class name="ScalableSequence" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Sequence"/>
    <constructor name="ScalableSequence" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="next" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ScalableSequence -->
  <!-- start interface org.spf4j.concurrent.Semaphore -->
  <interface name="Semaphore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.PermitSupplier"/>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[release 1 permit.]]>
      </doc>
    </method>
    <method name="release"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <doc>
      <![CDATA[release a number of permits.
 @param nrPermits  the number of permits to release.]]>
      </doc>
    </method>
    <method name="toSemaphore" return="org.spf4j.concurrent.Semaphore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A interface that abstracts a semaphore.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.Semaphore -->
  <!-- start interface org.spf4j.concurrent.Sequence -->
  <interface name="Sequence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="next" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return next number in sequence. if result is negative an overflow happened.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.concurrent.Sequence -->
  <!-- start class org.spf4j.concurrent.ThreadLocalBufferedConsumer -->
  <class name="ThreadLocalBufferedConsumer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <implements name="java.io.Closeable"/>
    <constructor name="ThreadLocalBufferedConsumer" type="int, java.util.function.Consumer, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ThreadLocalBufferedConsumer -->
  <!-- start class org.spf4j.concurrent.UIDGenerator -->
  <class name="UIDGenerator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, com.google.common.io.BaseEncoding, long, char, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a UID Generator

 @param sequence
 @param baseEncoding - if null MAC address based ID will not be included.]]>
      </doc>
    </constructor>
    <method name="generateIdBase" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="separator" type="char"/>
    </method>
    <method name="generateIdBase" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="separator" type="char"/>
      <param name="customEpoch" type="long"/>
    </method>
    <method name="generateIdBase" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="baseEncoding" type="com.google.common.io.BaseEncoding"/>
      <param name="separator" type="char"/>
      <param name="customEpoch" type="long"/>
    </method>
    <method name="getMaxSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Unique ID Generator Based on the assumptions: 1. host MAC address is used. (each network interface has a Unique ID)
 (encoded with provided encoder) 2. process id is used + current epoch seconds. it is assumed the PID is not recycled
 within a second. 3. A process sequence is used. UIDs will cycle after Long.MaxValue is reached.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UIDGenerator -->
  <!-- start class org.spf4j.concurrent.UnboundedLoadingCache -->
  <class name="UnboundedLoadingCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedLoadingCache" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache" type="java.util.Comparator, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Will use a ConcurrentSkipListMap to store the underlying data.
 @param comparator
 @param loader]]>
      </doc>
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeysLoaded" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[custom build high performance implementation for a unbounded guava cache: UnboundedLoadingCache is implemented with
 JDK concurrent map UnboundedLoadingCache2 is using the JDK 1.8 computing map functionality, but benchmarks show worse
 performance.

 Benchmark Mode Cnt Score Error Units CacheBenchmark.guavaCache thrpt 15 29011674.275 # 710672.413 ops/s
 CacheBenchmark.spf4j2Cache thrpt 15 30567248.015 # 807965.535 ops/s CacheBenchmark.spf4jCache thrpt 15 37961593.882 #
 1136244.254 ops/s CacheBenchmark.spf4jRacyCache thrpt 15 37553655.751 # 855349.501 ops/s

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedLoadingCache -->
  <!-- start class org.spf4j.concurrent.UnboundedLoadingCache2 -->
  <class name="UnboundedLoadingCache2" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedLoadingCache2" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache2" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Simple adapter that adapts a java ConcurrentMap to a guava cache. See UnboundedLoadingCache for rationale and
 benchmark data to see why this is not the default implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedLoadingCache2 -->
  <!-- start class org.spf4j.concurrent.UnboundedRacyLoadingCache -->
  <class name="UnboundedRacyLoadingCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="use UnboundedLoadingCache instead.">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedRacyLoadingCache" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedRacyLoadingCache" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly
 @deprecated use UnboundedLoadingCache instead.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedRacyLoadingCache -->
  <!-- start class org.spf4j.concurrent.UpdateResult -->
  <class name="UpdateResult" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="updated" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="same" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="isObjectUpdated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getObj" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UpdateResult -->
</package>
<package name="org.spf4j.base">
  <!-- start class org.spf4j.base.AbstractRunnable -->
  <class name="AbstractRunnable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="AbstractRunnable" type="boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create runnable lenient or not with a specific thread name during its execution.

 @param lenient - If lenient is true, it means that nobody is waiting for this runnable's result(finish) so To not
 loose the exception, the runnable will LOG it as an error, and not retrow it
 @param threadName - the thread name during the execution of this runnable.]]>
      </doc>
    </constructor>
    <constructor name="AbstractRunnable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[create runnable.

 @param lenient - If lenient is true, it means that nobody is waiting for this runnable's result(finish) so To not
 loose the exception, the runnable will LOG it as an error, and not retrow it]]>
      </doc>
    </constructor>
    <constructor name="AbstractRunnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractRunnable" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doRun"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="ERROR_EXIT_CODE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOP" type="java.lang.Runnable"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.AbstractRunnable -->
  <!-- start class org.spf4j.base.AlmostSafe -->
  <class name="AlmostSafe" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="USF" type="sun.misc.Unsafe"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Expose
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.AlmostSafe -->
  <!-- start class org.spf4j.base.AppendableUtils -->
  <class name="AppendableUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="escapeJsonString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toEscape" type="java.lang.CharSequence"/>
      <param name="jsonString" type="java.lang.StringBuilder"/>
      <doc>
      <![CDATA[Utility method to escape java strings to json strings.

 @param toEscape - the java string to escape.
 @param jsonString - the destination json String builder.]]>
      </doc>
    </method>
    <method name="escapeJsonString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toEscape" type="java.lang.CharSequence"/>
      <param name="jsonString" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendJsonStringEscapedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="jsonString" type="java.lang.StringBuilder"/>
    </method>
    <method name="appendJsonStringEscapedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="jsonString" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendUnsignedStringPadded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
      <param name="padTo" type="int"/>
    </method>
    <method name="appendUnsignedStringPadded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.Appendable"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
      <param name="padTo" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendUnsignedString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="long"/>
      <param name="shift" type="int"/>
    </method>
    <method name="appendUnsignedString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
    </method>
    <method name="appendSpaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="nrSpaces" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendSpaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.StringBuilder"/>
      <param name="nrSpaces" type="int"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.AppendableUtils -->
  <!-- start class org.spf4j.base.ArrayBuilder -->
  <class name="ArrayBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayBuilder" type="int, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ArrayBuilder -->
  <!-- start class org.spf4j.base.Arrays -->
  <class name="Arrays" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getColumnAsDoubles" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="long[][]"/>
      <param name="columnNumber" type="int"/>
    </method>
    <method name="getColumn" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="double[][]"/>
      <param name="columnNumber" type="int"/>
    </method>
    <method name="toDoubleArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="larr" type="long[]"/>
    </method>
    <method name="toObjectArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="larr" type="long[]"/>
    </method>
    <method name="divide" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arr1" type="double[]"/>
      <param name="arr2" type="double[]"/>
    </method>
    <method name="deepEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a1" type="java.lang.Object[]"/>
      <param name="a2" type="java.lang.Object[]"/>
      <param name="starting" type="int"/>
    </method>
    <method name="deepEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a1" type="java.lang.Object[]"/>
      <param name="a2" type="java.lang.Object[]"/>
      <param name="starting" type="int"/>
      <param name="ending" type="int"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte[]"/>
      <param name="b" type="byte[]"/>
      <param name="a1" type="int"/>
      <param name="b1" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="search" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="c" type="char"/>
    </method>
    <method name="moveOfRange" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="original" type="java.lang.Object[]"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
    </method>
    <method name="append" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="preppend" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="preppend" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="values" type="java.lang.Object[]"/>
    </method>
    <method name="append" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="values" type="java.lang.Object[]"/>
    </method>
    <method name="concat" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="java.lang.Object[][]"/>
    </method>
    <method name="concat" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="byte[][]"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="content" type="java.lang.Object"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[implementation which significantly faster for large arrays (> 500).]]>
      </doc>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[implementation which is significantly faster for large arrays (> 500).
 Bechmark results:
 Benchmark                                      Mode Cnt Score            Error           Units
 ArraysBenchmark.testSpf4jFillSmall(10)         thrpt 10 1048892782.375   # 29976629.818  ops/s
 ArraysBenchmark.testjdkFillSmall(10)           thrpt 10 1046330835.509   # 47577260.717  ops/s
 ArraysBenchmark.testSpf4jFillMedium(100)       thrpt 10 123724912.161    # 4049077.779   ops/s
 ArraysBenchmark.testjdkFillMedium(100)         thrpt 10 124143139.498    # 2044760.427   ops/s
 ArraysBenchmark.testSpf4jFillLarge(1000)       thrpt 10 20335282.192     # 592359.181    ops/s
 ArraysBenchmark.testjdkFillLarge(1000)         thrpt 10 12661975.522     # 170457.046    ops/s
 ArraysBenchmark.testSpf4jFillVeryLarge(10000)  thrpt 10 2767351.098      # 74871.147     ops/s
 ArraysBenchmark.testjdkFillVeryLarge(10000     thrpt 10 1045099.669      # 30044.505     ops/s]]>
      </doc>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="char"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="int"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="long"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="double"/>
    </method>
    <method name="charsToBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="char[]"/>
    </method>
    <method name="bytesToChars" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
    </method>
    <field name="EMPTY_OBJ_ARRAY" type="java.lang.Object[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_ANNOT_ARRAY" type="java.lang.annotation.Annotation[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_CLASS_ARRAY" type="java.lang.Class[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_STRING_ARRAY" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_BYTE_ARRAY" type="byte[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_CHAR_ARRAY" type="char[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_BOOLEAN_ARRAY" type="boolean[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_LONG_ARRAY" type="long[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_INT_ARRAY" type="int[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Array utilities.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Arrays -->
  <!-- start interface org.spf4j.base.ArrayWriter -->
  <interface name="ArrayWriter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <implements name="java.io.Closeable"/>
    <implements name="java.util.function.Consumer"/>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ArrayWriter -->
  <!-- start class org.spf4j.base.Base64 -->
  <class name="Base64" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <param name="from" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="decodeBase64V2" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <param name="from" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[@param text base64Binary data is likely to be long, and decoding requires each character to be accessed twice (once
 for counting length, another for decoding.)
 @param from the index of the first character in the sequence.
 @param len - the number of characters to decode.
 @return - the decoded byte array.]]>
      </doc>
    </method>
    <method name="decodeBase64V2" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
    </method>
    <method name="decodeInto" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="len" type="int"/>
      <param name="out" type="byte[]"/>
      <param name="outStartIdx" type="int"/>
    </method>
    <method name="decodeInto2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
      <param name="out" type="byte[]"/>
      <param name="outStartIdx" type="int"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="char[]"/>
      <param name="from" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="encode" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="encodeByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="encodeBase64" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
    </method>
    <method name="encodeBase64" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="encodeBase64V2" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Alternate implementation, should be better for large data.

 @param input - the byte array to encode
 @param offset - the index of the first byte that is to be encoded.
 @param len - the number of bytes to encode.
 @return - the encoded String.]]>
      </doc>
    </method>
    <method name="encodeBase64"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="result" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="encodeBase64" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="output" type="char[]"/>
      <param name="cptr" type="int"/>
      <doc>
      <![CDATA[Encodes a byte array into a char array by doing base64 encoding.

 The caller must supply a big enough buffer.

 @param input - the byte array to encode.
 @param offset - the index of the first byte to encode.
 @param len - the number of bytes to encode.
 @param output - the destination character array to encode to.
 @param cptr - the index of the first character to encode to.
 @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
 bytes should be placed.]]>
      </doc>
    </method>
    <method name="encodeBase64" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="out" type="byte[]"/>
      <param name="cptr" type="int"/>
      <doc>
      <![CDATA[Encodes a byte array into another byte array by first doing base64 encoding then encoding the result in ASCII.

 The caller must supply a big enough buffer.

 @param input - the byte array to encode.
 @param offset - the index of the first byte to encode.
 @param len - the number of bytes to encode.
 @param out - the destination byte array that represents an ASCII string to encode to.
 @param cptr - the index of the first byte in the destination array to encode to.
 @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
 bytes should be placed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA["improved" implementation based on DataTypeConverterImpl performance should be same/slightly faster than the JDK
 equivalent But most importantly you can encode/decode parts of a String, which should reduce the need of copying
 objects and reduce the amount of garbage created.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Base64 -->
  <!-- start class org.spf4j.base.BasicExecutionContext -->
  <class name="BasicExecutionContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.ExecutionContext"/>
    <constructor name="BasicExecutionContext" type="java.lang.String, java.lang.CharSequence, org.spf4j.base.ExecutionContext, org.spf4j.base.ExecutionContext.Relation, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartTimeNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
    </method>
    <method name="getContextAndValue" return="org.spf4j.base.ContextValue"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
    </method>
    <method name="getLocal" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
    </method>
    <method name="compute" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="compute" type="java.util.function.BiFunction"/>
    </method>
    <method name="getSource" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Close might be overridable to close any additional stuff added in the extended class.]]>
      </doc>
    </method>
    <method name="detach"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isAttached" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="attach"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Overwrite as needed for debug string.]]>
      </doc>
    </method>
    <method name="writeJsonTo"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Overwrite this method to change default json format.
 @param appendable]]>
      </doc>
    </method>
    <method name="addLog"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.spf4j.log.Slf4jLogRecord"/>
    </method>
    <method name="addCloseable"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.lang.AutoCloseable"/>
    </method>
    <method name="addLogs"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="pLogs" type="java.util.Collection"/>
    </method>
    <method name="streamLogs"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.util.function.Consumer"/>
    </method>
    <method name="streamLogs"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.util.function.Consumer"/>
      <param name="maxNr" type="int"/>
    </method>
    <method name="getContextMinLogLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
      <doc>
      <![CDATA[Overwrite for more configurable implementation.
 @param loggerName
 @return]]>
      </doc>
    </method>
    <method name="getBackendMinLogLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
      <doc>
      <![CDATA[Overwrite for more configurable implementation.
 @param loggerName
 @return]]>
      </doc>
    </method>
    <method name="setBackendMinLogLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <doc>
      <![CDATA[Overwrite for more configurable implementation.
 @param loggerName
 @return]]>
      </doc>
    </method>
    <method name="getId" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextChildId" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.StackTraceElement[]"/>
      <doc>
      <![CDATA[Add a sample to this execution context.
 this implementation does not retain them.
 @param sample]]>
      </doc>
    </method>
    <method name="getAndClearStackSamples" return="org.spf4j.base.StackSamples"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the collected stack samples.
 This implementation will always return null.
 overwrite in a context that supports this functionality.
 @return]]>
      </doc>
    </method>
    <method name="getStackSamples" return="org.spf4j.base.StackSamples"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[overwrite in a context that supports this functionality.
 @return a copy of the collected samples.]]>
      </doc>
    </method>
    <method name="isClosed" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRelationToSource" return="org.spf4j.base.ExecutionContext.Relation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samples" type="org.spf4j.base.StackSamples"/>
      <doc>
      <![CDATA[add a bunch of samples to this context.
 @param samples]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The simplest execution context possible.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.BasicExecutionContext -->
  <!-- start class org.spf4j.base.Callables -->
  <class name="Callables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxWaitMillis" type="int"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[After the immediate retries are done, delayed retry with randomized Fibonacci values up to the specified max is
 executed.

 @param <T> - the type returned by the Callable that is retried.
 @param <EX> - the Exception thrown by the retried callable.
 @param what - the callable to retry.
 @param nrImmediateRetries - the number of immediate retries.
 @param maxWaitMillis - maximum wait time in between retries.
 @param retryOnReturnVal - predicate to control retry on return value;
 @param retryOnException - predicate to retry on thrown exception.
 @return the result of the callable.
 @throws java.lang.InterruptedException - thrown if interrupted.
 @throws EX - the exception declared to be thrown by the callable.
 @deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="rootClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="f" type="java.lang.Exception"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use RetryPolicy">
      <param name="pwhat" type="org.spf4j.base.Callables.CheckedCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.Callables.RetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.RetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Naive implementation of execution with retry logic. a callable will be executed and retry attempted in current
 thread if the result and exception predicates. before retry, a callable can be executed that can abort the retry
 and finish the function with the previous result.

 @param <T> - The type of callable to retry result;
 @param <EX> - the exception thrown by the callable to retry.
 @param pwhat - the callable to retry.
 @param retryOnReturnVal - the predicate to control retry on return value.
 @param retryOnException - the predicate to return on retry value.
 @return the result of the retried callable if successful.
 @throws java.lang.InterruptedException - thrown if retry interrupted.
 @throws EX - the exception thrown by callable.
 @deprecated use RetryPolicy]]>
      </doc>
    </method>
    <method name="synchronize" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="withName" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[This is a duplicate of guava Callables.threadRenaming ... will have to review for deprecation/removal.]]>
      </doc>
    </method>
    <method name="memorized" return="org.spf4j.base.MemorizedCallable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.util.concurrent.Callable"/>
    </method>
    <method name="constant" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="from" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Runnable"/>
    </method>
    <field name="RETRY_FOR_NULL_RESULT" type="org.spf4j.base.Callables.SimpleRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use RetryPolicy">
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </field>
    <field name="DEFAULT_EXCEPTION_RETRY" type="org.spf4j.base.Callables.AdvancedRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use RetryPolicy">
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </field>
    <field name="DEFAULT_EXCEPTION_RETRY_PREDICATE" type="java.util.function.Predicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use RetryPolicy">
      <doc>
      <![CDATA[@deprecated use RetryPolicy]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utility class for executing stuff with retry logic.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables -->
  <!-- start class org.spf4j.base.Callables.AdvancedAction -->
  <class name="Callables.AdvancedAction" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="use RetryPolicy">
    <method name="values" return="org.spf4j.base.Callables.AdvancedAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Callables.AdvancedAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="RETRY" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RETRY_IMMEDIATE" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RETRY_DELAYED" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ABORT" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables.AdvancedAction -->
  <!-- start interface org.spf4j.base.Callables.AdvancedRetryPredicate -->
  <interface name="Callables.AdvancedRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use RetryPolicy">
    <method name="apply" return="org.spf4j.base.Callables.AdvancedAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="deadline" type="long"/>
    </method>
    <method name="apply" return="org.spf4j.base.Callables.AdvancedAction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="NO_RETRY" type="org.spf4j.base.Callables.AdvancedRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Callables.AdvancedRetryPredicate -->
  <!-- start interface org.spf4j.base.Callables.CheckedCallable -->
  <interface name="Callables.CheckedCallable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Callable"/>
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[the method that is retried.

 @return
 @throws EX
 @throws InterruptedException
 @throws java.util.concurrent.TimeoutException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callable that will be retried.

 @param <T> - the type of the object returned by this callable.
 @param <EX> - the exception type returned by this callable.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Callables.CheckedCallable -->
  <!-- start class org.spf4j.base.Callables.FibonacciBackoffRetryPredicate -->
  <class name="Callables.FibonacciBackoffRetryPredicate" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="use RetryPolicy">
    <implements name="org.spf4j.base.Callables.RetryPredicate"/>
    <constructor name="FibonacciBackoffRetryPredicate" type="org.spf4j.base.Callables.AdvancedRetryPredicate, int, long, long, java.util.function.Function, long, java.util.function.LongSupplier, java.util.concurrent.TimeUnit"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables.FibonacciBackoffRetryPredicate -->
  <!-- start class org.spf4j.base.Callables.RetryDecision -->
  <class name="Callables.RetryDecision" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="use RetryPolicy">
    <method name="abort" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Exception"/>
    </method>
    <method name="retry" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="retryMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="abort" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecisionType" return="org.spf4j.base.Callables.RetryDecision.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDelayMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getException" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNewCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables.RetryDecision -->
  <!-- start class org.spf4j.base.Callables.RetryDecision.Type -->
  <class name="Callables.RetryDecision.Type" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Callables.RetryDecision.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Callables.RetryDecision.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="Abort" type="org.spf4j.base.Callables.RetryDecision.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="Retry" type="org.spf4j.base.Callables.RetryDecision.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.Callables.RetryDecision.Type -->
  <!-- start interface org.spf4j.base.Callables.RetryPredicate -->
  <interface name="Callables.RetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use RetryPolicy">
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[the number or millis of delay until the next retry, or -1 for abort.

 @param value
 @return]]>
      </doc>
    </method>
    <field name="NORETRY_DELAY_PREDICATE" type="org.spf4j.base.Callables.RetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Callables.RetryPredicate -->
  <!-- start class org.spf4j.base.Callables.SimpleAction -->
  <class name="Callables.SimpleAction" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="use RetryPolicy">
    <method name="values" return="org.spf4j.base.Callables.SimpleAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Callables.SimpleAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="RETRY" type="org.spf4j.base.Callables.SimpleAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ABORT" type="org.spf4j.base.Callables.SimpleAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables.SimpleAction -->
  <!-- start interface org.spf4j.base.Callables.SimpleRetryPredicate -->
  <interface name="Callables.SimpleRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use RetryPolicy">
    <method name="apply" return="org.spf4j.base.Callables.SimpleAction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Callables.SimpleRetryPredicate -->
  <!-- start class org.spf4j.base.Callables.TimeoutCallable -->
  <class name="Callables.TimeoutCallable" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use RetryPolicy">
    <implements name="org.spf4j.base.Callables.CheckedCallable"/>
    <constructor name="TimeoutCallable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimeoutCallable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadline" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@param deadline millis since epoch.]]>
      </doc>
    </method>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables.TimeoutCallable -->
  <!-- start interface org.spf4j.base.Callables.TimeoutRetryPredicate -->
  <interface name="Callables.TimeoutRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use RetryPolicy">
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="deadlineMillis" type="long"/>
      <param name="what" type="java.util.concurrent.Callable"/>
    </method>
    <field name="NORETRY_FOR_RESULT" type="org.spf4j.base.Callables.TimeoutRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated use RetryPolicy]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Callables.TimeoutRetryPredicate -->
  <!-- start class org.spf4j.base.CallablesNano -->
  <class name="CallablesNano" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="use RetryPolicy aNd_cHaR co.">
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitNanos" type="long"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitNanos" type="long"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxWaitNanos" type="long"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[After the immediate retries are done, delayed retry with randomized Fibonacci values up to the specified max is
 executed.

 @param <T> - the type returned by the Callable that is retried.
 @param <EX> - the Exception thrown by the retried callable.
 @param what - the callable to retry.
 @param nrImmediateRetries - the number of immediate retries.
 @param maxWaitNanos - maximum wait time in between retries.
 @param retryOnReturnVal - predicate to control retry on return value;
 @param retryOnException - predicate to retry on thrown exception.
 @return the result of the callable.
 @throws java.lang.InterruptedException - thrown if interrupted.
 @throws EX - the exception declared to be thrown by the callable.]]>
      </doc>
    </method>
    <method name="toDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutNanos" type="long"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="retryOnException" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[Utility class for executing stuff with retry logic.

 @author zoly
 @deprecated use RetryPolicy & co.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CallablesNano -->
  <!-- start class org.spf4j.base.CallablesNano.NanoTimeoutCallable -->
  <class name="CallablesNano.NanoTimeoutCallable" extends="org.spf4j.base.Callables.TimeoutCallable"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NanoTimeoutCallable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadline" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@param deadline System.nanoTime deadline.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.spf4j.base.CallablesNano.NanoTimeoutCallable -->
  <!-- start interface org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate -->
  <interface name="CallablesNano.TimeoutNanoRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="deadlineNanos" type="long"/>
      <param name="what" type="java.util.concurrent.Callable"/>
    </method>
    <field name="NORETRY_FOR_RESULT" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate -->
  <!-- start interface org.spf4j.base.CharArrayConsumer -->
  <interface name="CharArrayConsumer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.CharArrayConsumer -->
  <!-- start class org.spf4j.base.CharSequences -->
  <class name="CharSequences" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="distance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s1" type="java.lang.CharSequence"/>
      <param name="s2" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[function that calculates the number of operations that are needed to transform s1 into s2. operations are: char
 add, char delete, char modify See https://en.wikipedia.org/wiki/Levenshtein_distance for more info.

 @param s1
 @param s2
 @return the number of operations required to transform s1 into s2]]>
      </doc>
    </method>
    <method name="distance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c1" type="char"/>
      <param name="c2" type="char"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use compare.">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[compare s to t.

 @param s
 @param t
 @return
 @deprecated use compare.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="sLength" type="int"/>
      <param name="t" type="java.lang.CharSequence"/>
      <param name="tLength" type="int"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="sFrom" type="int"/>
      <param name="sLength" type="int"/>
      <param name="t" type="java.lang.CharSequence"/>
      <param name="tFrom" type="int"/>
      <param name="tLength" type="int"/>
      <doc>
      <![CDATA[compare 2 CharSequence fragments.

 @param s the charsequence to compare
 @param sFrom the index for the first chars to compare.
 @param sLength the number of characters to compare.
 @param t the charsequence to compare to
 @param tFrom the index for the first character to compare to.
 @param tLength the number of characters to compare to.
 @return]]>
      </doc>
    </method>
    <method name="equalsNullables" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="hashcode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <method name="subSequence" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
    </method>
    <method name="startsWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="prefix" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
    </method>
    <method name="endsWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qc" type="java.lang.CharSequence"/>
      <param name="with" type="java.lang.CharSequence"/>
    </method>
    <method name="lineNumbered" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="lineNumbered" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="appendable" type="java.lang.Appendable"/>
      <param name="ia" type="org.spf4j.base.IntAppender"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toLineNumbered" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="source" type="java.lang.CharSequence"/>
    </method>
    <method name="toLineNumbered" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="source" type="java.lang.CharSequence"/>
      <param name="ia" type="org.spf4j.base.IntAppender"/>
    </method>
    <method name="parseInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[A more flexible version of Integer.parseInt.

 @see java.lang.Integer.parseInt]]>
      </doc>
    </method>
    <method name="parseInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[A more flexible version of Integer.parseInt.

 @see java.lang.Integer.parseInt]]>
      </doc>
    </method>
    <method name="parseUnsignedInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <param name="idxFrom" type="int"/>
      <doc>
      <![CDATA[will parse a unsigned integer from a char sequence from idxFrom.
 @param cs
 @param radix
 @param idxFrom
 @return]]>
      </doc>
    </method>
    <method name="parseUnsignedInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <param name="idxFrom" type="int"/>
      <param name="idxTo" type="int"/>
      <doc>
      <![CDATA[will parse a unsigned integer from a char sequence from idxFrom.
 @param cs
 @param radix
 @param idxFrom
 @param idxTo
 @return]]>
      </doc>
    </method>
    <method name="parseUnsignedLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <param name="idxFrom" type="int"/>
    </method>
    <method name="parseUnsignedLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <param name="idxFrom" type="int"/>
      <param name="idxTo" type="int"/>
      <param name="strict" type="boolean"/>
    </method>
    <method name="parseLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[A more flexible version of Long.parseLong.

 @see java.lang.Long.parseLong]]>
      </doc>
    </method>
    <method name="parseLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[A more flexible version of Long.parseLong.

 @see java.lang.Long.parseLong]]>
      </doc>
    </method>
    <method name="containsAnyChar" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.CharSequence"/>
      <param name="chars" type="char[]"/>
    </method>
    <method name="containsAnyChar" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="chars" type="char[]"/>
    </method>
    <method name="isValidJavaId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.CharSequence"/>
    </method>
    <method name="isValidFileName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.CharSequence"/>
    </method>
    <method name="validatedFileName" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.CharSequence"/>
    </method>
    <method name="regionMatches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
      <param name="other" type="java.lang.CharSequence"/>
      <param name="ooffset" type="int"/>
      <param name="plen" type="int"/>
      <doc>
      <![CDATA[Equivalent to String.regionMatches.]]>
      </doc>
    </method>
    <method name="regionMatchesIgnoreCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ta" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
      <param name="pa" type="java.lang.CharSequence"/>
      <param name="ooffset" type="int"/>
      <param name="plen" type="int"/>
      <doc>
      <![CDATA[Equivalent/based on to String.regionMatches.]]>
      </doc>
    </method>
    <method name="match" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wildcard" type="java.lang.CharSequence"/>
      <param name="cs2Match" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[regular wildcard matcher. * matches any number of consecutive characters. ? matches any single character.

 @param wildcard
 @param cs2Match
 @return]]>
      </doc>
    </method>
    <method name="getJavaRegexpStr" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wildcard" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Transform a wildcard expression 2 a java regular expression. * matches any number of consecutive characters. ?
 matches any single character.

 @param wildcard
 @return]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
      <param name="c" type="char"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
      <param name="cp" type="java.util.function.IntPredicate"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
      <param name="chars" type="char[]"/>
    </method>
    <method name="containsIgnoreCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.CharSequence"/>
      <param name="searchStr" type="java.lang.CharSequence"/>
    </method>
    <method name="lastIndexOfIgnoreCase" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.CharSequence"/>
      <param name="searchStr" type="java.lang.CharSequence"/>
    </method>
    <method name="indexOfIgnoreCase" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.CharSequence"/>
      <param name="searchStr" type="java.lang.CharSequence"/>
      <param name="idxStart" type="int"/>
    </method>
    <method name="countIgnoreCase" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.CharSequence"/>
      <param name="searchStr" type="java.lang.CharSequence"/>
    </method>
    <method name="reader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <doc>
    <![CDATA[Special methods to use for character sequences...

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CharSequences -->
  <!-- start class org.spf4j.base.CheckedRunnable -->
  <class name="CheckedRunnable" extends="org.spf4j.base.AbstractRunnable"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CheckedRunnable" type="boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CheckedRunnable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CheckedRunnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CheckedRunnable" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doRun"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CheckedRunnable -->
  <!-- start class org.spf4j.base.CloneFailedException -->
  <class name="CloneFailedException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CloneFailedException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CloneFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CloneFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CloneFailedException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CloneFailedException -->
  <!-- start interface org.spf4j.base.CloseableIterable -->
  <interface name="CloseableIterable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="java.lang.Iterable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="from" return="org.spf4j.base.CloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="org.spf4j.base.CloseableIterator"/>
    </method>
    <method name="from" return="org.spf4j.base.CloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="it" type="java.lang.Iterable"/>
    </method>
    <method name="from" return="org.spf4j.base.CloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="it" type="java.lang.Iterable"/>
      <param name="close" type="java.lang.AutoCloseable"/>
    </method>
    <method name="toStream" return="java.util.stream.Stream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toStream" return="java.util.stream.Stream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parallel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[need to extend java.io.Closeable so that jaxrs does not interfere.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.CloseableIterable -->
  <!-- start interface org.spf4j.base.CloseableIterator -->
  <interface name="CloseableIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <implements name="java.io.Closeable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="from" return="org.spf4j.base.CloseableIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="it" type="java.util.Iterator"/>
    </method>
    <method name="from" return="org.spf4j.base.CloseableIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="it" type="java.util.Iterator"/>
      <param name="close" type="java.lang.AutoCloseable"/>
    </method>
    <method name="toStreamRemaining" return="java.util.stream.Stream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toStreamRemaining" return="java.util.stream.Stream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parallel" type="boolean"/>
    </method>
    <doc>
    <![CDATA[need to extend java.io.Closeable so that jaxrs does not interfere.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.CloseableIterator -->
  <!-- start class org.spf4j.base.Closeables -->
  <class name="Closeables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.lang.AutoCloseable[]"/>
    </method>
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.lang.Exception"/>
      <param name="closeables" type="java.lang.AutoCloseable[]"/>
    </method>
    <method name="closeAll" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.io.Closeable[]"/>
    </method>
    <method name="closeAll" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.lang.Exception"/>
      <param name="closeables" type="java.io.Closeable[]"/>
    </method>
    <method name="closeAll" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.io.Closeable[]"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
    </method>
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.lang.Iterable"/>
    </method>
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.lang.Exception"/>
      <param name="closeables" type="java.lang.Iterable"/>
    </method>
    <method name="closeSelectorChannels" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selector" type="java.nio.channels.Selector"/>
    </method>
    <method name="closeSelectorChannels" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.io.IOException"/>
      <param name="selector" type="java.nio.channels.Selector"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Closeables -->
  <!-- start class org.spf4j.base.ComparablePair -->
  <class name="ComparablePair" extends="org.spf4j.base.SerializablePair"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="ComparablePair" type="java.lang.Comparable, java.lang.Comparable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.ComparablePair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable"/>
      <param name="second" type="java.lang.Comparable"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.base.ComparablePair"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ComparablePair -->
  <!-- start class org.spf4j.base.Comparables -->
  <class name="Comparables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="min" return="java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrs" type="java.lang.Object[]"/>
    </method>
    <method name="max" return="java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrs" type="java.lang.Object[]"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable"/>
      <param name="second" type="java.lang.Comparable"/>
    </method>
    <method name="compareArrays" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable[]"/>
      <param name="second" type="java.lang.Comparable[]"/>
    </method>
    <method name="compareArrays" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable[]"/>
      <param name="second" type="java.lang.Comparable[]"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Comparables -->
  <!-- start class org.spf4j.base.ContextValue -->
  <class name="ContextValue" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContextValue" type="org.spf4j.base.ExecutionContext, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContext" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ContextValue -->
  <!-- start class org.spf4j.base.CoreTextMediaType -->
  <class name="CoreTextMediaType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.CoreTextMediaType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSubType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="TEXT_PLAIN" type="org.spf4j.base.CoreTextMediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_JSON" type="org.spf4j.base.CoreTextMediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CoreTextMediaType -->
  <!-- start class org.spf4j.base.DateTimeFormats -->
  <class name="DateTimeFormats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="DEFAULT_ZONE" type="java.time.ZoneId"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TS_FORMAT" type="java.time.format.DateTimeFormatter"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COMPACT_TS_FORMAT" type="java.time.format.DateTimeFormatter"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DT_FORMAT" type="java.time.format.DateTimeFormatter"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.DateTimeFormats -->
  <!-- start class org.spf4j.base.Either -->
  <class name="Either" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isLeft" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRight" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeft" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRight" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="left" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
    </method>
    <method name="right" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="java.lang.Object"/>
    </method>
    <method name="processResult" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.spf4j.base.Either"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <field name="value" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Either -->
  <!-- start class org.spf4j.base.Either.Left -->
  <class name="Either.Left" extends="org.spf4j.base.Either"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Left" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isLeft" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeft" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRight" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Either.Left -->
  <!-- start class org.spf4j.base.Either.Right -->
  <class name="Either.Right" extends="org.spf4j.base.Either"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Right" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isLeft" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeft" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRight" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Either.Right -->
  <!-- start class org.spf4j.base.Env -->
  <class name="Env" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="envname" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
    </method>
    <method name="getValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="envname" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
    </method>
    <method name="getValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="envname" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
    </method>
    <method name="getValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="envname" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
    </method>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="envname" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="envname" type="java.lang.String"/>
      <param name="defaultValue" type="java.util.function.Supplier"/>
    </method>
    <method name="getSystemProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="deprecatedAliases" type="java.lang.String[]"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getSystemProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="deprecatedAliases" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Env -->
  <!-- start class org.spf4j.base.EqualsPredicate -->
  <class name="EqualsPredicate" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Predicate"/>
    <constructor name="EqualsPredicate" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.EqualsPredicate -->
  <!-- start class org.spf4j.base.EscapeJsonStringAppendableWrapper -->
  <class name="EscapeJsonStringAppendableWrapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Appendable"/>
    <constructor name="EscapeJsonStringAppendableWrapper" type="java.lang.Appendable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pcsq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.EscapeJsonStringAppendableWrapper -->
  <!-- start interface org.spf4j.base.ESupplier -->
  <interface name="ESupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Throwable" type="java.lang.Throwable"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ESupplier -->
  <!-- start interface org.spf4j.base.ExecutionContext -->
  <interface name="ExecutionContext"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <implements name="org.spf4j.base.JsonWriteable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getId" return="java.lang.CharSequence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartTimeNanos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeadlineNanos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSource" return="org.spf4j.base.ExecutionContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRoot" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the top source. will return this is current is root.
 will follow all relationship types.]]>
      </doc>
    </method>
    <method name="getRootParent" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Adam of this current context. will return this is current is Adam.
 follows only CHILD_OF relationships.]]>
      </doc>
    </method>
    <method name="getNotClosedParent" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return will return the first not closed parent. null if no parent is available.]]>
      </doc>
    </method>
    <method name="addLog"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.spf4j.log.Slf4jLogRecord"/>
    </method>
    <method name="addLogs"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="java.util.Collection"/>
    </method>
    <method name="addCloseable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.lang.AutoCloseable"/>
      <doc>
      <![CDATA[Attach a AutoCloseable to execution context.
 All of them will be closed when context is closed, in reverse registration order.
 @param closeable]]>
      </doc>
    </method>
    <method name="getContextMinLogLevel" return="org.spf4j.log.Level"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
      <doc>
      <![CDATA[The minimum log level accepted by this execution context;
 The logs that we will store in this context.
 @return]]>
      </doc>
    </method>
    <method name="getContextMinLogLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBackendMinLogLevel" return="org.spf4j.log.Level"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
      <doc>
      <![CDATA[The minimum log level overwrite.
 An execution context can overwrite the backend configured log level.
 @return null if not specified.]]>
      </doc>
    </method>
    <method name="getBackendMinLogLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setBackendMinLogLevel" return="org.spf4j.log.Level"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
      <param name="level" type="org.spf4j.log.Level"/>
    </method>
    <method name="setBackendMinLogLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="org.spf4j.log.Level"/>
    </method>
    <method name="streamLogs"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.util.function.Consumer"/>
    </method>
    <method name="streamLogs"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.util.function.Consumer"/>
      <param name="nrLogs" type="int"/>
    </method>
    <method name="detach"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Detach this execution context from the current Thread.]]>
      </doc>
    </method>
    <method name="attach"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Attach execution context to the current thread.
 A thread will typically have a stack of execution contexts attached to it.]]>
      </doc>
    </method>
    <method name="isAttached" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if execution context is attached to a thread or not.]]>
      </doc>
    </method>
    <method name="getTimeToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getUncheckedTimeToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeRelativeToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getMillisToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getSecondsToDeadline" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <doc>
      <![CDATA[Method to get context associated data.
 if current context does not have baggage, the parent context is queried if tag is inherited.
 This is done recursively.
 @param <T> type of data.
 @param key key of data.
 @return the data]]>
      </doc>
    </method>
    <method name="getContextAndValue" return="org.spf4j.base.ContextValue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <doc>
      <![CDATA[Method to get context associated data.
 if current context does not have baggage, the parent context is queried if tag is inherited.
 This is done recursively, and both the context and the value are returned.
 @param <T> type of data.
 @param key key of data.
 @return the data]]>
      </doc>
    </method>
    <method name="getLocal" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <doc>
      <![CDATA[Method to get context associated data.
 will ignore inheritance tag attribute.
 @param <T> type of data.
 @param key key of data.
 @return the data]]>
      </doc>
    </method>
    <method name="put" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Method to put context associated data.
 @param <T> type of data.
 @param key the key of data.
 @param data the data.
 @return existing data if there.]]>
      </doc>
    </method>
    <method name="combine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use accumulate.">
      <param name="tag" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[@deprecated use accumulate.]]>
      </doc>
    </method>
    <method name="accumulate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
    </method>
    <method name="accumulateComponent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
    </method>
    <method name="putToRootParent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Method to put context associated data to the root context.
 @param <T> type of data.
 @param key the key of data.
 @param data the data.
 @return existing data if there.]]>
      </doc>
    </method>
    <method name="compute" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="compute" type="java.util.function.BiFunction"/>
      <doc>
      <![CDATA[Compute context associated data.
 @param <K>
 @param <V>
 @param key
 @param compute
 @return]]>
      </doc>
    </method>
    <method name="addToRootParent" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.spf4j.base.ExecutionContext.Tag"/>
      <param name="data" type="java.lang.Object"/>
    </method>
    <method name="startChild" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operationName" type="java.lang.String"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="startChild" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operationName" type="java.lang.String"/>
    </method>
    <method name="detachedChild" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operationName" type="java.lang.String"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="detachedChild" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operationName" type="java.lang.String"/>
    </method>
    <method name="nextChildId" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="add"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samples" type="org.spf4j.base.StackSamples"/>
    </method>
    <method name="getAndClearStackSamples" return="org.spf4j.base.StackSamples"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStackSamples" return="org.spf4j.base.StackSamples"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isClosed" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRelationToSource" return="org.spf4j.base.ExecutionContext.Relation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDebugDetail" return="org.spf4j.base.avro.DebugDetail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="java.lang.String"/>
      <param name="throwable" type="java.lang.Throwable"/>
    </method>
    <method name="getDebugDetail" return="org.spf4j.base.avro.DebugDetail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="java.lang.String"/>
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="addStackSamples" type="boolean"/>
    </method>
    <method name="getDebugDetail" return="org.spf4j.base.avro.DebugDetail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="java.lang.String"/>
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="addStackSamples" type="boolean"/>
      <param name="maxNrLogs" type="int"/>
    </method>
    <doc>
    <![CDATA[Execution context information encapsulated a place to store execution related information:
 <ul>
 <li>deadline/timeout</li>
 <li>context logs/overrides</li>
 <li>tagged attachments (profiling info, etc..)</li>
 </ul>
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ExecutionContext -->
  <!-- start class org.spf4j.base.ExecutionContext.Relation -->
  <class name="ExecutionContext.Relation" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.ExecutionContext.Relation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.ExecutionContext.Relation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="CHILD_OF" type="org.spf4j.base.ExecutionContext.Relation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FOLLOWS" type="org.spf4j.base.ExecutionContext.Relation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.ExecutionContext.Relation -->
  <!-- start interface org.spf4j.base.ExecutionContext.SimpleTag -->
  <interface name="ExecutionContext.SimpleTag"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.ExecutionContext.Tag"/>
  </interface>
  <!-- end interface org.spf4j.base.ExecutionContext.SimpleTag -->
  <!-- start interface org.spf4j.base.ExecutionContext.Tag -->
  <interface name="ExecutionContext.Tag"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInherited" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="relation" type="org.spf4j.base.ExecutionContext.Relation"/>
      <doc>
      <![CDATA[if true, a child execution context will check parent execution contexts
 for tag values if not local values exist.]]>
      </doc>
    </method>
    <method name="pushOnClose" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[push this tag/values to the parent context when current context is closed.
 only child -> parent will be pushed, follows relationships will not be considered.]]>
      </doc>
    </method>
    <method name="accumulate" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="existing" type="java.lang.Object"/>
      <param name="newVal" type="java.lang.Object"/>
    </method>
    <method name="accumulateComponent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="existing" type="java.lang.Object"/>
      <param name="component" type="java.lang.Object"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.base.ExecutionContext.Tag -->
  <!-- start interface org.spf4j.base.ExecutionContextFactory -->
  <interface name="ExecutionContextFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="id" type="java.lang.CharSequence"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="relation" type="org.spf4j.base.ExecutionContext.Relation"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
      <doc>
      <![CDATA[Create a ExecutionContext.
 @param name name of the context.
 @param parent parent execution context. (null if this is root)
 @param deadlineNanos the deadline of the context.
 @param onClose a callback that needs to be executed when context is closed.
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ExecutionContextFactory -->
  <!-- start class org.spf4j.base.ExecutionContexts -->
  <class name="ExecutionContexts" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="defaultThreadLocalAttacher" return="org.spf4j.base.ThreadLocalContextAttacher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="threadLocalAttacher" return="org.spf4j.base.ThreadLocalContextAttacher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="genId" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContextFactory" return="org.spf4j.base.ExecutionContextFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="current" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="inCurrentThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="clearCurrentThread"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
      <doc>
      <![CDATA[start a execution context.

 @param deadlineNanos the deadline for this context. (System.nanotime)
 @return the execution context.]]>
      </doc>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[start a execution context.

 @param timeout
 @param tu
 @return]]>
      </doc>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="opname" type="java.lang.String"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="opname" type="java.lang.String"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="id" type="java.lang.CharSequence"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="createDetached" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="id" type="java.lang.CharSequence"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="start" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="id" type="java.lang.CharSequence"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="relation" type="org.spf4j.base.ExecutionContext.Relation"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="createDetached" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="createDetached" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="relation" type="org.spf4j.base.ExecutionContext.Relation"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="createDetached" return="org.spf4j.base.ExecutionContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="id" type="java.lang.CharSequence"/>
      <param name="parent" type="org.spf4j.base.ExecutionContext"/>
      <param name="relation" type="org.spf4j.base.ExecutionContext.Relation"/>
      <param name="startTimeNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="getContextDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContextDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="currentTime" type="long"/>
    </method>
    <method name="getTimeRelativeToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getTimeToDeadlineUnchecked" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeToDeadlineInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getMillisToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getSecondsToDeadline" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="computeDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="computeTimeout" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="computeDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use variant where the value and unit are it the natural order.">
      <param name="current" type="org.spf4j.base.ExecutionContext"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="timeout" type="long"/>
      <doc>
      <![CDATA[@deprecated use variant where the value and unit are it the natural order.]]>
      </doc>
    </method>
    <method name="computeDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="current" type="org.spf4j.base.ExecutionContext"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="computeDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTimeNanos" type="long"/>
      <param name="current" type="org.spf4j.base.ExecutionContext"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="timeout" type="long"/>
    </method>
    <method name="computeTimeoutDeadline" return="org.spf4j.base.TimeoutDeadline"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="current" type="org.spf4j.base.ExecutionContext"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="timeout" type="long"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Compute the actual timeout taking in consideration the context deadline.
 @param current the context
 @param unit timeout unit
 @param timeout timeout value
 @return the earliest timeout (of the provided and context one)
 @throws TimeoutException]]>
      </doc>
    </method>
    <method name="propagatingCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="propagatingCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="propagatingCallables" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
    </method>
    <method name="propagatingCallables" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="deadlinedPropagatingCallables" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="deadlinedPropagatingCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingRunnable" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="propagatingRunnable" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
    </method>
    <method name="propagatingRunnable" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingFunction" return="java.util.function.Function"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.function.Function"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingBiFunction" return="java.util.function.BiFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.function.BiFunction"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingConsumer" return="java.util.function.Consumer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.function.Consumer"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingSupplier" return="java.util.function.Supplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.function.Supplier"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="propagatingBiConsumer" return="java.util.function.BiConsumer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.function.BiConsumer"/>
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="name" type="java.lang.String"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <field name="DEFAULT_TIMEOUT_NANOS" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ExecutionContexts -->
  <!-- start class org.spf4j.base.ExitException -->
  <class name="ExitException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExitException" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ExitException -->
  <!-- start interface org.spf4j.base.Handler -->
  <interface name="Handler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="deadlineMillis" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Handler -->
  <!-- start interface org.spf4j.base.HandlerNano -->
  <interface name="HandlerNano"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.HandlerNano -->
  <!-- start class org.spf4j.base.Holder -->
  <class name="Holder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Holder" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Holder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="org.spf4j.base.Holder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="OF_NULL" type="org.spf4j.base.Holder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Type holder, supports holding nulls. (unlike optional)
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Holder -->
  <!-- start class org.spf4j.base.InstrumentationHelper -->
  <class name="InstrumentationHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="premain"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String"/>
      <param name="inst" type="java.lang.instrument.Instrumentation"/>
    </method>
    <method name="getObjectSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.InstrumentationHelper -->
  <!-- start interface org.spf4j.base.IntAppender -->
  <interface name="IntAppender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="append"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.IntAppender -->
  <!-- start class org.spf4j.base.IntAppender.CommentNumberAppender -->
  <class name="IntAppender.CommentNumberAppender" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntAppender"/>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.base.IntAppender.CommentNumberAppender"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.IntAppender.CommentNumberAppender -->
  <!-- start class org.spf4j.base.IntAppender.SimplePrefixNumberAppender -->
  <class name="IntAppender.SimplePrefixNumberAppender" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntAppender"/>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.base.IntAppender.SimplePrefixNumberAppender"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.IntAppender.SimplePrefixNumberAppender -->
  <!-- start class org.spf4j.base.IntMath -->
  <class name="IntMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="closestPowerOf2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
    </method>
    <method name="closestPowerOf2Number" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.IntMath -->
  <!-- start class org.spf4j.base.IntMath.XorShift128 -->
  <class name="IntMath.XorShift128" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntSequence"/>
    <constructor name="XorShift128"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift128 -->
  <!-- start class org.spf4j.base.IntMath.XorShift32 -->
  <class name="IntMath.XorShift32" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntSequence"/>
    <constructor name="XorShift32"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A very fast Pseudo random generator.
 use of this random is appropriate when you need the fastest random that you plan to use in a single
 thread.
 If you need a thread-safe random, please use JDK ThreadLocalRandom, which will be your best option.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift32 -->
  <!-- start class org.spf4j.base.IntMath.XorShift32ThreadSafe -->
  <class name="IntMath.XorShift32ThreadSafe" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="please use JDK java.util.concurrent.ThreadLocalRandom instead.
 The JDK implementation uses local fields in the Thread class instead of a classic ThreadLocal,
 which makes it faster...">
    <implements name="org.spf4j.base.IntSequence"/>
    <constructor name="XorShift32ThreadSafe"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated please use JDK java.util.concurrent.ThreadLocalRandom instead.
 The JDK implementation uses local fields in the Thread class instead of a classic ThreadLocal,
 which makes it faster...]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift32ThreadSafe -->
  <!-- start class org.spf4j.base.IntMath.XorShift32ThreadSafe.Singleton -->
  <class name="IntMath.XorShift32ThreadSafe.Singleton" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Singleton"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="INSTANCE" type="org.spf4j.base.IntMath.XorShift32ThreadSafe"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift32ThreadSafe.Singleton -->
  <!-- start interface org.spf4j.base.IntSequence -->
  <interface name="IntSequence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="nextInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.IntSequence -->
  <!-- start interface org.spf4j.base.Invocation -->
  <interface name="Invocation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="invoke" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Invocation -->
  <!-- start class org.spf4j.base.Iterables -->
  <class name="Iterables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="forAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itterable" type="java.lang.Iterable"/>
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <method name="forAll2"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itterable" type="java.lang.Iterable"/>
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Iterables -->
  <!-- start class org.spf4j.base.JavaUtils -->
  <class name="JavaUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isJavaIdentifier" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.JavaUtils -->
  <!-- start class org.spf4j.base.JNA -->
  <class name="JNA" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="haveJnaPlatform" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="haveJnaPlatformClib" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[JNA utilitties.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.JNA -->
  <!-- start class org.spf4j.base.Json -->
  <class name="Json" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="jsonWritableSerializer" return="com.fasterxml.jackson.databind.JsonSerializer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toStringJsonWritableSerializer" return="com.fasterxml.jackson.databind.JsonSerializer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="FACTORY" type="com.fasterxml.jackson.core.JsonFactory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAPPER" type="com.fasterxml.jackson.databind.ObjectMapper"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Json -->
  <!-- start interface org.spf4j.base.JsonReader -->
  <interface name="JsonReader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="readFrom" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.io.Reader"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.JsonReader -->
  <!-- start interface org.spf4j.base.JsonWriteable -->
  <interface name="JsonWriteable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Writeable"/>
    <method name="writeJsonTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeJsonTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.JsonWriteable -->
  <!-- start class org.spf4j.base.LangIdEncDec -->
  <class name="LangIdEncDec" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="lossyEncode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.CharSequence"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="lossyEncode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Encoder that encodes an arbitrary string to an ID.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.LangIdEncDec -->
  <!-- start interface org.spf4j.base.MapWriter -->
  <interface name="MapWriter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <implements name="java.util.function.BiConsumer"/>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.MapWriter -->
  <!-- start class org.spf4j.base.MemorizedCallable -->
  <class name="MemorizedCallable" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Callable"/>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="clear" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfMemorized" return="org.spf4j.base.NullAbleOptional"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[use Callables.memorize to create a instance.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.MemorizedCallable -->
  <!-- start class org.spf4j.base.Methods -->
  <class name="Methods" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writeHtml"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="w" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMethod" return="org.spf4j.base.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.StackTraceElement"/>
    </method>
    <method name="getMethod" return="org.spf4j.base.avro.Method"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
      <param name="methodName" type="java.lang.String"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="w" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
      <param name="w" type="java.lang.StringBuilder"/>
    </method>
    <method name="toCharSequence" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="org.spf4j.base.avro.Method"/>
    </method>
    <method name="from" return="org.spf4j.base.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <method name="from" return="org.spf4j.base.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
    </method>
    <field name="ROOT" type="org.spf4j.base.avro.Method"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Methods -->
  <!-- start class org.spf4j.base.MutableHolder -->
  <class name="MutableHolder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
    <constructor name="MutableHolder" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="use MutableHolder.of">
      <doc>
      <![CDATA[@deprecated use MutableHolder.of]]>
      </doc>
    </constructor>
    <constructor name="MutableHolder"
      static="false" final="false" visibility="public"
      deprecated="use MutableHolder.of">
      <doc>
      <![CDATA[@deprecated use MutableHolder.of]]>
      </doc>
    </constructor>
    <method name="of" return="org.spf4j.base.MutableHolder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="of" return="org.spf4j.base.MutableHolder.ComparableHolder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Comparable"/>
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.MutableHolder -->
  <!-- start class org.spf4j.base.MutableHolder.ComparableHolder -->
  <class name="MutableHolder.ComparableHolder" extends="org.spf4j.base.MutableHolder"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="ComparableHolder" type="java.lang.Comparable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ComparableHolder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.MutableHolder.ComparableHolder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Comparable"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.base.MutableHolder.ComparableHolder"/>
    </method>
  </class>
  <!-- end class org.spf4j.base.MutableHolder.ComparableHolder -->
  <!-- start class org.spf4j.base.MutableInteger -->
  <class name="MutableInteger" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableInteger" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.MutableInteger -->
  <!-- start class org.spf4j.base.NameValue -->
  <class name="NameValue" extends="org.spf4j.base.Pair"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NameValue" type="java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.NameValue"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.NameValue -->
  <!-- start class org.spf4j.base.NoExitSecurityManager -->
  <class name="NoExitSecurityManager" extends="java.lang.SecurityManager"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoExitSecurityManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="java.security.Permission"/>
    </method>
    <method name="checkPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="java.security.Permission"/>
      <param name="context" type="java.lang.Object"/>
    </method>
    <method name="checkExit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.NoExitSecurityManager -->
  <!-- start class org.spf4j.base.NullAbleOptional -->
  <class name="NullAbleOptional" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullAbleOptional"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="empty" return="org.spf4j.base.NullAbleOptional"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPresent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="org.spf4j.base.NullAbleOptional"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="EMPTY" type="org.spf4j.base.NullAbleOptional"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.NullAbleOptional -->
  <!-- start class org.spf4j.base.Objects -->
  <class name="Objects" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="clone" return="java.io.Serializable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Objects -->
  <!-- start class org.spf4j.base.Operations -->
  <class name="Operations" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getOperations" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operationName" type="java.lang.String"/>
      <doc>
      <![CDATA[Method that will return the provided operation and all its sub-operations recursively.
 @param operationName
 @return operation and all its sub-operations recursively]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Operations -->
  <!-- start class org.spf4j.base.PackageInfo -->
  <class name="PackageInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="errorNoPackageDetail"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="getPackageInfoDirect" return="org.spf4j.base.avro.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="getPackageInfoDirect" return="org.spf4j.base.avro.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aClass" type="java.lang.Class"/>
    </method>
    <method name="getPackageInfo" return="org.spf4j.base.avro.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="getJarSourceUrl" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Useful to get the jar URL where a particular class is located.

 @param clasz
 @return]]>
      </doc>
    </method>
    <field name="NONE" type="org.spf4j.base.avro.PackageInfo"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.PackageInfo -->
  <!-- start class org.spf4j.base.Pair -->
  <class name="Pair" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map.Entry"/>
    <implements name="org.spf4j.base.Writeable"/>
    <constructor name="Pair" type="java.lang.Object, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
    </method>
    <method name="from" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringPair" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a pair from a str1,str2 pair.

 @param stringPair - pair in the format (a,b) csv pair.
 @return null if this is not a pair.]]>
      </doc>
    </method>
    <method name="getFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSecond" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Overwrite to change string image.
 @return]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toList" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pairs" type="org.spf4j.base.Pair[]"/>
    </method>
    <method name="getKey" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="first" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="second" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Pair -->
  <!-- start class org.spf4j.base.ParameterizedException -->
  <class name="ParameterizedException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ParameterizedException" type="java.lang.Throwable, java.lang.String, java.io.Serializable[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getArgs" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessageFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[a exception type with parameterized message.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ParameterizedException -->
  <!-- start interface org.spf4j.base.ParameterizedSupplier -->
  <interface name="ParameterizedSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameter" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ParameterizedSupplier -->
  <!-- start class org.spf4j.base.ReferenceType -->
  <class name="ReferenceType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.ReferenceType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.ReferenceType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="create" return="java.lang.ref.Reference"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <field name="WEAK" type="org.spf4j.base.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SOFT" type="org.spf4j.base.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.ReferenceType -->
  <!-- start class org.spf4j.base.Reflections -->
  <class name="Reflections" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getParameterTypes" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Optimized alternative of Method.getParameterTypes that steals the parameterTypeArry from method
 instead of copying it.

 Here is the benchmark comparison for a 5 arg method:

 Benchmark                                       Mode  Cnt           Score          Error  Units
 ReflectionsBenchmark.normalGetTypes            thrpt   10   227015245.933 #  2725143.765  ops/s
 ReflectionsBenchmark.optimizedGetTypes         thrpt   10  1159407471.306 # 21204385.301  ops/s

 @param m
 @return]]>
      </doc>
    </method>
    <method name="getParameterTypes" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Constructor"/>
    </method>
    <method name="primitiveToWrapper" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="primitiveToWrapper" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="wrapperToPrimitive" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="isWrappableOrWrapper" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="getAnnotationAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annot" type="java.lang.annotation.Annotation"/>
      <param name="attributeName" type="java.lang.String"/>
    </method>
    <method name="getDeclaredMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Equivalent to Class.getDeclaredMethod which returns a null instead of throwing an exception.
 returned method is also made accessible.

 @param c
 @param methodName
 @param paramTypes
 @return]]>
      </doc>
    </method>
    <method name="getMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Equivalent to Class.getDeclaredMethod which returns a null instead of throwing an exception.
 returned method is also made accessible.

 @param c
 @param methodName
 @param paramTypes
 @return]]>
      </doc>
    </method>
    <method name="getConstructor" return="java.lang.reflect.Constructor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Equivalent to Class.getDeclaredConstructor, only that it does not throw an exception if no constructor,
 it returns null instead, also makes all constructors accessible..]]>
      </doc>
    </method>
    <method name="getCompatibleMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Method lookup utility that looks up a method declaration that is compatible. (taking in consideration boxed
 primitives and varargs)

 @param c
 @param methodName
 @param paramTypes
 @return]]>
      </doc>
    </method>
    <method name="getCompatibleMethodHandle" return="java.lang.invoke.MethodHandle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Method"/>
      <param name="object" type="java.lang.Object"/>
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
      <exception name="InvocationTargetException" type="java.lang.reflect.InvocationTargetException"/>
    </method>
    <method name="canAssign" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Class"/>
      <param name="from" type="java.lang.Class"/>
    </method>
    <method name="getCompatibleMethodCached" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
    </method>
    <method name="getCompatibleMethodHandleCached" return="java.lang.invoke.MethodHandle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
    </method>
    <method name="getManifest" return="java.util.jar.Manifest"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jarUrl" type="java.net.URL"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the manifest of a jar file.

 @param jarUrl
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="implementStatic" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[create a proxy instance that will proxy interface methods to static methods on the target class.
 @param <T>
 @param clasz
 @param target
 @return]]>
      </doc>
    </method>
    <method name="implement" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="target" type="java.lang.Object"/>
    </method>
    <method name="getLoadedClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cl" type="java.lang.ClassLoader"/>
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="forName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[utility method that will work for primittives as well.
 @param name the class name
 @return
 @throws ClassNotFoundException]]>
      </doc>
    </method>
    <method name="forName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="loader" type="java.lang.ClassLoader"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[utility method that will work for primitives as well.
 @param name the class name
 @param loader the class loader
 @return
 @throws ClassNotFoundException]]>
      </doc>
    </method>
    <method name="getImplementedGenericInterfaces" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="getInheritedAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationClass" type="java.lang.Class"/>
      <param name="element" type="java.lang.reflect.AnnotatedElement"/>
      <doc>
      <![CDATA[Annotation access with extended inheritance semantics.
 Class level annotations are inherited to methods.
 superclass and implemented interface annotations are inherited.
 package level annotations are inherited to class and methods as well.
 @param <A>
 @param annotationClass
 @param element
 @return]]>
      </doc>
    </method>
  </class>
  <!-- end class org.spf4j.base.Reflections -->
  <!-- start class org.spf4j.base.RemoteException -->
  <class name="RemoteException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RemoteException" type="java.lang.String, java.lang.String, java.lang.String, java.io.Serializable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RemoteException" type="java.lang.String, java.lang.String, java.lang.String, java.io.Serializable, java.lang.Throwable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getOrigin" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRemoteDetail" return="java.io.Serializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRemoteClass" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return string representation. (Class name + origin + message)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.RemoteException -->
  <!-- start class org.spf4j.base.ResultMatchers -->
  <class name="ResultMatchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="operationsFromConfigValue" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="operationfromConfigValue" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="getThrowableResultMatcher" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reason" type="java.lang.String"/>
    </method>
    <method name="toSupplier" return="org.spf4j.base.ResultMatchers.Supplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toPredicate" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="org.spf4j.base.avro.ThrowablePattern"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="toPredicate" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="org.spf4j.base.avro.ObjectPattern"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicates" type="java.util.Map"/>
      <param name="patterns" type="java.util.Map"/>
      <param name="lenient" type="boolean"/>
    </method>
    <method name="add2"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicates" type="java.util.Map"/>
      <param name="patterns" type="java.util.Map"/>
      <param name="lenient" type="boolean"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ResultMatchers -->
  <!-- start interface org.spf4j.base.ResultMatchers.Supplier -->
  <interface name="ResultMatchers.Supplier"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Function"/>
    <method name="chain" return="org.spf4j.base.ResultMatchers.Supplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fallback" type="org.spf4j.base.ResultMatchers.Supplier"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.base.ResultMatchers.Supplier -->
  <!-- start class org.spf4j.base.Runnables -->
  <class name="Runnables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="runAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnables" type="java.lang.Runnable[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Runnables -->
  <!-- start class org.spf4j.base.Runtime -->
  <class name="Runtime" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getAppVersion" return="org.spf4j.base.Version"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAppVersionString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationInfo" return="org.spf4j.base.avro.ApplicationInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns application information.
 Information is retrieved from the app jar manifest.
 Manifest can be generated with maven like:

 <pre>
 {@code
   <plugin>
     <groupId>org.apache.maven.plugins</groupId>
     <artifactId>maven-jar-plugin</artifactId>
     <version>3.1.1</version>
     <configuration>
       <archive>
         <index>true</index>
         <manifest>
           <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
           <addClasspath>true</addClasspath>
           <classpathPrefix>lib/</classpathPrefix>
           <mainClass>org.spf4j.demo.Main</mainClass>
         </manifest>
         <manifestEntries>
           <Implementation-Vendor>${project.groupId}</Implementation-Vendor>
           <Implementation-Vendor-Id>${project.groupId}</Implementation-Vendor-Id>
           <Implementation-Title>${project.artifactId}</Implementation-Title>
           <Implementation-Version>${project.version}</Implementation-Version>
           <Implementation-Description>${project.description}</Implementation-Description>
           <Implementation-Url>${project.url}</Implementation-Url>
           <Implementation-Org>${project.organization.name}</Implementation-Org>
           <Implementation-Org-Url>${project.organization.url}</Implementation-Org-Url>
           <Implementation-Build>${buildNumber}</Implementation-Build>
           <Build-Time>${maven.build.timestamp}</Build-Time>
         </manifestEntries>
       </archive>
     </configuration>
   </plugin>


 }
 </pre>
 @return]]>
      </doc>
    </method>
    <method name="isShuttingDown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="errorNoPackageDetail"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="goDownWithError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exitCode" type="org.spf4j.base.SysExits"/>
    </method>
    <method name="goDownWithError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="exitCode" type="org.spf4j.base.SysExits"/>
    </method>
    <method name="goDownWithError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="exitCode" type="int"/>
    </method>
    <method name="isMacOsx" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem">
      <doc>
      <![CDATA[@return true on macosx.
 @deprecated use OperatingSystem]]>
      </doc>
    </method>
    <method name="isWindows" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem">
      <doc>
      <![CDATA[@return true on windows.
 @deprecated use OperatingSystem]]>
      </doc>
    </method>
    <method name="isTestFramework" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="haveJnaPlatform" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use JNA instead">
      <doc>
      <![CDATA[@return true if jna platform is present.
 @deprecated use JNA instead]]>
      </doc>
    </method>
    <method name="haveJnaPlatformClib" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use JNA instead.">
      <doc>
      <![CDATA[@return true if jna platform clib is present.
 @deprecated use JNA instead.]]>
      </doc>
    </method>
    <method name="getNrOpenFiles" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.getOpenFileDescriptorCount() instead">
      <doc>
      <![CDATA[get the number of open files by current java process.

 @return -1 if cannot get nr of open files
 @deprecated use OperatingSystem.getOpenFileDescriptorCount() instead]]>
      </doc>
    </method>
    <method name="getLsofOutput" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use Lsof.getLsofOutput instead.">
      <doc>
      <![CDATA[@deprecated use Lsof.getLsofOutput instead.]]>
      </doc>
    </method>
    <method name="run" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.forkExec.">
      <param name="command" type="java.lang.String[]"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.forkExec.]]>
      </doc>
    </method>
    <method name="killProcess" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.killProcess.">
      <param name="proc" type="java.lang.Process"/>
      <param name="terminateTimeoutMillis" type="long"/>
      <param name="forceTerminateTimeoutMillis" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.killProcess.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.forkExec instead.">
      <param name="command" type="java.lang.String[]"/>
      <param name="handler" type="org.spf4j.base.Runtime.ProcOutputHandler"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.forkExec instead.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.forkExec instead.">
      <param name="command" type="java.lang.String[]"/>
      <param name="handler" type="org.spf4j.base.Runtime.ProcOutputHandler"/>
      <param name="timeoutMillis" type="long"/>
      <param name="terminationTimeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.forkExec instead.]]>
      </doc>
    </method>
    <method name="queueHookAtBeginning"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="queueHookAtEnd"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="queueHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="int"/>
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="removeQueuedShutdownHook" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="see ExecutionContexts.">
      <doc>
      <![CDATA[@return returns the deadline as millis since epoch.
 @deprecated see ExecutionContexts.]]>
      </doc>
    </method>
    <method name="millisToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="see ExecutionContexts.">
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@return milliseconds until deadline.
 @deprecated see ExecutionContexts.]]>
      </doc>
    </method>
    <method name="gc" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <doc>
      <![CDATA[Attempts to run the GC in a verifiable way.

 @param timeoutMillis - timeout for GC attempt
 @return true if GC executed for sure, false otherwise, gc might have been executed though, but we cannot be sure.]]>
      </doc>
    </method>
    <method name="jrun" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="timeoutMillis" type="long"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="jrun" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="classPath" type="java.lang.String"/>
      <param name="timeoutMillis" type="long"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setCurrentDir"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceAbsolutePath" type="java.lang.String"/>
    </method>
    <method name="getCurrentDir" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="jrun" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="classPath" type="java.lang.String"/>
      <param name="timeoutMillis" type="long"/>
      <param name="jvmArgs" type="java.lang.String[]"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="jrunAndLog"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="timeoutMillis" type="long"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="jrunAndLog"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="classPath" type="java.lang.String"/>
      <param name="timeoutMillis" type="long"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="jrunAndLog"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="classPath" type="java.lang.String"/>
      <param name="timeoutMillis" type="long"/>
      <param name="jvmArgs" type="java.lang.String[]"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMainThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the main Thread.
 @return null if there is no main thread (can happen when calling this is a shutdown hook)]]>
      </doc>
    </method>
    <method name="getMainClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Method will figure out the main class and cache the result for successive invocations.
 You should call this method prior to the main thread's termination.
 @return null if main class cannot be found.]]>
      </doc>
    </method>
    <field name="IS_LITTLE_ENDIAN" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WAIT_FOR_SHUTDOWN_NANOS" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TMP_FOLDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TMP_FOLDER_PATH" type="java.nio.file.Path"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_HOME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_HOME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PID" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unix PID identifying your process in the OC image it is running.]]>
      </doc>
    </field>
    <field name="PROCESS_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OS_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PROCESS_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a unique ID for this JVM process.
 PID@HOSTNAME:HEXNR]]>
      </doc>
    </field>
    <field name="NR_PROCESSORS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_PLATFORM" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Runtime -->
  <!-- start class org.spf4j.base.Runtime.Jmx -->
  <class name="Runtime.Jmx" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Jmx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPackageInfo" return="org.spf4j.base.avro.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.spf4j.base.Runtime.Jmx -->
  <!-- start interface org.spf4j.base.Runtime.ProcOutputHandler -->
  <interface name="Runtime.ProcOutputHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use Processhandler">
    <method name="handleStdOut"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
    </method>
    <method name="stdOutDone"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="handleStdErr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
    </method>
    <method name="stdErrDone"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated use Processhandler]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Runtime.ProcOutputHandler -->
  <!-- start class org.spf4j.base.Runtime.Version -->
  <class name="Runtime.Version" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Runtime.Version[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Runtime.Version"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="fromSpecVersion" return="org.spf4j.base.Runtime.Version"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specVersion" type="java.lang.String"/>
    </method>
    <field name="V1_0" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_1" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_2" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_3" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_4" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_5" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_6" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_7" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_8" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_9" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V_10" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V_11" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V_12" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.Runtime.Version -->
  <!-- start class org.spf4j.base.SerializablePair -->
  <class name="SerializablePair" extends="org.spf4j.base.Pair"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="SerializablePair" type="java.io.Serializable, java.io.Serializable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.SerializablePair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.io.Serializable"/>
      <param name="second" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.SerializablePair -->
  <!-- start class org.spf4j.base.Slf4jMessageFormatter -->
  <class name="Slf4jMessageFormatter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="exHandle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="sbuf" type="java.lang.Appendable"/>
      <param name="t" type="java.lang.Throwable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messagePattern" type="java.lang.String"/>
      <param name="argArray" type="java.lang.Object[]"/>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param argArray the message arguments.
 @return the number of arguments used in the message.
 @throws IOException]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param argArray the message arguments.
 @return the number of arguments used in the message.
 @throws IOException]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param argArray the message arguments.
 @return the number of arguments used in the message.
 @throws IOException something wend wrong while writing to the appendable.]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firstArgIdx" type="int"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param firstArgIdx the index of the first parameter.
 @param argArray the message arguments.
 @return the index of the last arguments used in the message + 1.
 @throws IOException something wend wrong while writing to the appendable.]]>
      </doc>
    </method>
    <method name="getFormatParameterNumber" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="messagePattern" type="java.lang.String"/>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exHandler" type="org.spf4j.base.Slf4jMessageFormatter.ErrorHandler"/>
      <param name="firstArgIdx" type="int"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param safe - if true recoverable exHandle will be caught when writing arguments, and a error will be appended
 instead.
 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param firstArgIdx the index of the first parameter.
 @param argArray the message arguments.
 @return the index of the last arguments used in the message + 1.
 @throws IOException something wend wrong while writing to the appendable.]]>
      </doc>
    </method>
    <method name="safeObjectAppend"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exHandler" type="org.spf4j.base.Slf4jMessageFormatter.ErrorHandler"/>
      <param name="sbuf" type="java.lang.Appendable"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A more flexible implementation of the SLF4j message formatter (org.slf4j.helpers.MessageFormatter). the following
 improvements:

 1) Allow to format to a procvided destination (Appendable) allowing you to reduce the amount of garbage generated in
 a custom formatter... 2) Lets you know which arguments have been used in the message allowing you to implement extra
 logic to handle the unused ones 3) Lets you plug custom formatters for argument types. (you can get better
 performance and more flexibility) 4) Processing arguments that are arrays is sligtly faster than the slf4j formatter.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Slf4jMessageFormatter -->
  <!-- start interface org.spf4j.base.Slf4jMessageFormatter.ErrorHandler -->
  <interface name="Slf4jMessageFormatter.ErrorHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="sbuf" type="java.lang.Appendable"/>
      <param name="t" type="java.lang.Throwable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.base.Slf4jMessageFormatter.ErrorHandler -->
  <!-- start interface org.spf4j.base.StackSamples -->
  <interface name="StackSamples"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.JsonWriteable"/>
    <method name="getSampleCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSubNodes" return="gnu.trove.map.TMap"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.StackSamples -->
  <!-- start class org.spf4j.base.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="distance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.distance instead.">
      <param name="s1" type="java.lang.String"/>
      <param name="s2" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.distance instead.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use containsAnyChars instead.">
      <param name="string" type="java.lang.String"/>
      <param name="chars" type="char[]"/>
      <doc>
      <![CDATA[@deprecated use containsAnyChars instead.]]>
      </doc>
    </method>
    <method name="containsAnyChars" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="chars" type="char[]"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.containsAnyChar instead.">
      <param name="string" type="java.lang.CharSequence"/>
      <param name="chars" type="char[]"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.containsAnyChar instead.]]>
      </doc>
    </method>
    <method name="withFirstCharLower" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
    </method>
    <method name="methodToAttribute" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[A get/set/is prefixed method name to attribute name converter.
 @param prefix
 @param str
 @return]]>
      </doc>
    </method>
    <method name="attributeToMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[A attribute to get/set/is method name converter.
 @param prefix
 @param str
 @return]]>
      </doc>
    </method>
    <method name="writeReplaceWhitespaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="replacement" type="char"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="steal" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Steal the underlying character array of a String.

 @param str
 @return]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="char[]"/>
      <doc>
      <![CDATA[Create a String based on the provided character array. No copy of the array is made.

 @param chars
 @return]]>
      </doc>
    </method>
    <method name="createUtf8Encoder" return="java.nio.charset.CharsetEncoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createUtf8Decoder" return="java.nio.charset.CharsetDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUTF8CharsetEncoder" return="java.nio.charset.CharsetEncoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUTF8CharsetDecoder" return="java.nio.charset.CharsetDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ce" type="java.nio.charset.CharsetEncoder"/>
      <param name="ca" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="getmaxNrBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ce" type="java.nio.charset.CharsetEncoder"/>
      <param name="nrChars" type="int"/>
    </method>
    <method name="encode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ce" type="java.nio.charset.CharsetEncoder"/>
      <param name="ca" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <param name="targetArray" type="byte[]"/>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cd" type="java.nio.charset.CharsetDecoder"/>
      <param name="ba" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="fromUtf8" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Optimized UTF8 decoder.

 Here is a benchmark comparison with the JDK implementation (see EncodingBenchmark.java in the benchmark project):

 EncodingBenchmark.stringDecode thrpt 10 16759798.463 # 343505.144 ops/s EncodingBenchmark.fastStringDecode thrpt 10
 17413298.464 # 301756.867 ops/s


 @param bytes
 @return]]>
      </doc>
    </method>
    <method name="fromUtf8" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="startIdx" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="toUtf8" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Optimized UTF8 string encoder.

 comparison with the stock JDK implementation (see EncodingBenchmark.java in the benchmark project):

 EncodingBenchmark.stringEncode thrpt 10 9481668.776 # 252543.135 ops/s EncodingBenchmark.fastStringEncode thrpt 10
 22469383.612 # 898677.892 ops/s

 @param str
 @return]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.compare">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.compare]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="hashcode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <method name="subSequence" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
    </method>
    <method name="endsWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qc" type="java.lang.CharSequence"/>
      <param name="with" type="java.lang.CharSequence"/>
    </method>
    <method name="escapeJsonString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toEscape" type="java.lang.String"/>
      <param name="jsonString" type="java.lang.StringBuilder"/>
      <doc>
      <![CDATA[Utility method to escape java strings to json strings.

 @param toEscape - the java string to escape.
 @param jsonString - the destination json String builder.]]>
      </doc>
    </method>
    <method name="escapeJsonString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toEscape" type="java.lang.String"/>
      <param name="jsonString" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendJsonStringEscapedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="jsonString" type="java.lang.StringBuilder"/>
    </method>
    <method name="appendJsonStringEscapedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="jsonString" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendUnsignedString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="long"/>
      <param name="shift" type="int"/>
    </method>
    <method name="appendUnsignedString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
    </method>
    <method name="appendUnsignedStringPadded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
      <param name="padTo" type="int"/>
    </method>
    <method name="appendUnsignedStringPadded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.Appendable"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
      <param name="padTo" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendSpaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="nrSpaces" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendSpaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.StringBuilder"/>
      <param name="nrSpaces" type="int"/>
    </method>
    <method name="regionMatches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.regionMatches.">
      <param name="t" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
      <param name="other" type="java.lang.CharSequence"/>
      <param name="ooffset" type="int"/>
      <param name="plen" type="int"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.regionMatches.]]>
      </doc>
    </method>
    <method name="truncate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="length" type="int"/>
    </method>
    <method name="commonPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strs" type="java.lang.CharSequence[]"/>
    </method>
    <field name="EOL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Strings -->
  <!-- start class org.spf4j.base.SuppressedThrowable -->
  <class name="SuppressedThrowable" extends="java.lang.Throwable"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SuppressedThrowable" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="fillInStackTrace" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.SuppressedThrowable -->
  <!-- start interface org.spf4j.base.SuppressForbiden -->
  <interface name="SuppressForbiden"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.SuppressForbiden -->
  <!-- start class org.spf4j.base.SysExits -->
  <class name="SysExits" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.SysExits[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.SysExits"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="exitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOk" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isError" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fromCode" return="org.spf4j.base.SysExits"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exitCode" type="int"/>
      <doc>
      <![CDATA[@param exitCode
 @return corresponding enum.]]>
      </doc>
    </method>
    <field name="OK" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Everything is OK.]]>
      </doc>
    </field>
    <field name="EX_GENERAL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Catch all for general errors.]]>
      </doc>
    </field>
    <field name="EX_SHELL_BUILTIN_MISSUSE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shell build in miss-use.]]>
      </doc>
    </field>
    <field name="EX_USAGE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The command was used incorrectly, e.g., with the wrong number of arguments, a bad flag, a bad syntax in a
 parameter, or whatever.]]>
      </doc>
    </field>
    <field name="EX_DATAERR" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The input data was incorrect in some way. This should only be used for user's data and not system files.]]>
      </doc>
    </field>
    <field name="EX_NOINPUT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An input file (not a system file) did not exist or was not readable. This could also include errors like ``No
 message'' to a mailer (if it cared to catch it).]]>
      </doc>
    </field>
    <field name="EX_NOUSER" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The user specified did not exist. This might be used for mail addresses or remote logins.]]>
      </doc>
    </field>
    <field name="EX_NOHOST" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The host specified did not exist. This is used in mail addresses or network requests.]]>
      </doc>
    </field>
    <field name="EX_UNAVAILABLE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A service is unavailable. This can occur if a support program or file does not exist. This can also be used as a
 catchall message when something you wanted to do doesn't work, but you don't know why.]]>
      </doc>
    </field>
    <field name="EX_SOFTWARE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An internal software error has been detected. This should be limited to non-operating system related errors as
 possible.]]>
      </doc>
    </field>
    <field name="EX_OSERR" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An operating system error has been detected. This is intended to be used for such things as ``cannot fork'',
 ``cannot create pipe'', or the like. It includes things like getuid returning a user that does not exist in the
 passwd file.]]>
      </doc>
    </field>
    <field name="EX_OSFILE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some system file (e.g., /etc/passwd, /var/run/utmp,etc.) does not exist, cannot be opened, or has some sort of
 error (e.g., syntax error).]]>
      </doc>
    </field>
    <field name="EX_CANTCREAT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A (user specified) output file cannot be created.]]>
      </doc>
    </field>
    <field name="EX_IOERR" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An error occurred while doing I/O on some file.]]>
      </doc>
    </field>
    <field name="EX_TEMPFAIL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Temporary failure, indicating something that is not really an error. In sendmail, this means that a mailer (e.g.)
 could not create a connection, and the request should be reattempted later.]]>
      </doc>
    </field>
    <field name="EX_PROTOCOL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The remote system returned something that was ``not possible'' during a protocol exchange.]]>
      </doc>
    </field>
    <field name="EX_NOPERM" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[You did not have sufficient permission to perform the operation. This is not intended for file system problems,
 which should use EX_NOINPUT or EX_CANTCREAT, but rather for higher level permissions.]]>
      </doc>
    </field>
    <field name="EX_CONFIG" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Something was found in an unconfigured or misconfigured state.]]>
      </doc>
    </field>
    <field name="EX_CANNOT_EXEC_CMD" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[cannot execute invoked command.]]>
      </doc>
    </field>
    <field name="EX_CMD_NOT_FOUND" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Command not found.]]>
      </doc>
    </field>
    <field name="EX_INVALID_ARG_TO_EXIT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invalid argument to exit.]]>
      </doc>
    </field>
    <field name="EX_SIG_HUP" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Section caused by exit due to signal.
 where signal name is same on Linux, Solaris and MacOS enum has the appropriate name.
 for linux see: http://man7.org/linux/man-pages/man7/signal.7.html
 or run man signal on you OS of choice.]]>
      </doc>
    </field>
    <field name="EX_SIG_INT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_QUIT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_ILL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_TRAP" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_ABRT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_7" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_FPE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_KILL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_10" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_11" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_12" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_PIPE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_ALRM" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_TERM" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_16" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_17" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_18" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_19" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_20" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_21" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_22" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_23" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_24" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_25" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_26" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_27" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_28" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_29" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_30" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_31" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_STATUS_OUT_OF_RANGE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_UNKNOWN" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Any return codes not explicitly defined will be associated with "EX_UNKNOWN"]]>
      </doc>
    </field>
    <doc>
    <![CDATA[some "standard" process exit codes from:
 http://tldp.org/LDP/abs/html/index.html
 https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html
 http://journal.thobe.org/2013/02/jvms-and-kill-signals.html
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.SysExits -->
  <!-- start interface org.spf4j.base.ThreadLocalContextAttacher -->
  <interface name="ThreadLocalContextAttacher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="attach" return="org.spf4j.base.ThreadLocalContextAttacher.Attached"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <doc>
      <![CDATA[Attach an execution context to the current Thread.
 @param ctx the Execution context.
 @return Information object about the operation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ThreadLocalContextAttacher -->
  <!-- start interface org.spf4j.base.ThreadLocalContextAttacher.Attached -->
  <interface name="ThreadLocalContextAttacher.Attached"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="detach"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Remove context from thread.]]>
      </doc>
    </method>
    <method name="isTopOfStack" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the Attached Context is the first/only context in the Thread context stack.
 @return]]>
      </doc>
    </method>
    <method name="attachedThread" return="java.lang.Thread"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the Thread that this context has been attached to.
 @return]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.base.ThreadLocalContextAttacher.Attached -->
  <!-- start class org.spf4j.base.Threads -->
  <class name="Threads" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getThreads" return="java.lang.Thread[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="randomFirst" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nr" type="int"/>
      <param name="threads" type="java.lang.Thread[]"/>
      <doc>
      <![CDATA[get a random selection of nr Threads from the array, the first nr location in the array will
 contain the random set,m the rest will be null.
 @param nr number of threads to randomly select.
 @param threads the array of threads to select from]]>
      </doc>
    </method>
    <method name="getThreadByName" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getThreadById" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="long"/>
    </method>
    <method name="getStackTraces" return="java.lang.StackTraceElement[][]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threads" type="java.lang.Thread[]"/>
    </method>
    <method name="dumpTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dumpToPrintStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.PrintStream"/>
    </method>
    <field name="EMPTY_ARRAY" type="java.lang.Thread[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Thread utilities.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Threads -->
  <!-- start interface org.spf4j.base.ThrowableMatcher -->
  <interface name="ThrowableMatcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Predicate"/>
    <method name="getOperationName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the name of this matcher. something like "tcp-connection-error" for something matching TCP connection issues.
  String getName();

  /**
 @return The API name that this Throwable matcher applies to.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ThrowableMatcher -->
  <!-- start class org.spf4j.base.Throwables -->
  <class name="Throwables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isRetryable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[figure out if a Exception is retry-able or not.
 If while executing a operation a exception is returned, that exception is retryable if retrying the operation
 can potentially succeed.
 @param value
 @return true/false is retry-able or not, null when this is not clear and can be context dependent.]]>
      </doc>
    </method>
    <method name="getIsRetryablePredicate" return="java.util.function.Function"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setIsRetryablePredicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isRetryablePredicate" type="java.util.function.Function"/>
    </method>
    <method name="getNrSuppressedExceptions" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="getNrRecursiveSuppressedExceptions" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="removeOldestSuppressedRecursive" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="removeOldestSuppressed" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="suppress" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use suppressLimited instead.">
      <param name="t" type="java.lang.Throwable"/>
      <param name="suppressed" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Functionality will call Throwable.addSuppressed, 2 extra things happen:

 1) limit to nr of exceptions suppressed.
 2) if exception is already suppressed, will not add it.
 3) will return a clone of exception t.

 @param <T>
 @param t
 @param suppressed
 @returna clone of exception t with suppressed exception suppressed;
 @deprecated use suppressLimited instead.]]>
      </doc>
    </method>
    <method name="suppressLimited"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="suppressed" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Functionality will call Throwable.addSuppressed, 2 extra things happen:

 1) limit to nr of exceptions suppressed.
 2) if exception is already suppressed, will not add it.

 @param t
 @param suppressed]]>
      </doc>
    </method>
    <method name="suppressLimited"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="suppressed" type="java.lang.Throwable"/>
      <param name="maxSuppressed" type="int"/>
    </method>
    <method name="suppress" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="suppressed" type="java.lang.Throwable"/>
      <param name="maxSuppressed" type="int"/>
    </method>
    <method name="getSuppressed" return="java.lang.Throwable[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Utility to get suppressed exceptions.

 In java 1.7 it will return t.getSuppressed()
 + in case it is Iterable<Throwable> any other linked exceptions (see
 SQLException)

 java 1.6 behavior is deprecated.

 @param t
 @return]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.StackTraceElement"/>
      <param name="previous" type="java.lang.StackTraceElement"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
    </method>
    <method name="toStringBuilder" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
    </method>
    <method name="toStringBuilder" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.io.PrintStream"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.io.PrintStream"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeThrowableDetail"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMessageString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="t" type="java.lang.Throwable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.lang.StackTraceElement[]"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.lang.StackTraceElement[]"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="commonFrames" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.lang.StackTraceElement[]"/>
      <param name="enclosingTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="isNonRecoverable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Is this Throwable a JVM non-recoverable exception. (Oom, VMError, etc...)
 @param t
 @return]]>
      </doc>
    </method>
    <method name="containsNonRecoverable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Does this Throwable contain a JVM non-recoverable exception. (Oom, VMError, etc...)
 @param t
 @return]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[checks in the throwable + children (both causal and suppressed) contain a throwable that
 respects the Predicate.
 @param t the throwable
 @param predicate the predicate
 @return true if a Throwable matching the predicate is found.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="toLookFor" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[checks in the throwable + children (both causal and suppressed) contain a throwable that
 respects the Predicate.
 @param t the throwable
 @param predicate the predicate
 @return true if a Throwable matching the predicate is found.]]>
      </doc>
    </method>
    <method name="first" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="clasz" type="java.lang.Class"/>
      <doc>
      <![CDATA[return first Exception in the causal chain Assignable to clasz.
 @param <T>
 @param t
 @param clasz
 @return]]>
      </doc>
    </method>
    <method name="first" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[Returns the first Throwable that matches the predicate in the causal and suppressed chain,
 the suppressed chain includes the supression mechanism included in SQLException.
 @param t the Throwable
 @param predicate the Predicate
 @return the Throwable the first matches the predicate or null is none matches.]]>
      </doc>
    </method>
    <method name="firstCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[Returns first Throwable in the causality chain that is matching the provided predicate.
 @param throwable the Throwable to go through.
 @param predicate the predicate to apply
 @return the first Throwable from the chain that the predicate matches.]]>
      </doc>
    </method>
    <method name="getNonRecoverablePredicate" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNonRecoverablePredicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[Overwrite the default non-recoverable predicate.
 @param predicate]]>
      </doc>
    </method>
    <method name="writeAbreviatedClassName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
      <param name="writeTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="throwException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ex" type="java.lang.Exception"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <field name="SUPPRESSED_CAPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Caption for labeling suppressed exception stack traces]]>
      </doc>
    </field>
    <field name="CAUSE_CAPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Caption for labeling causative exception stack traces]]>
      </doc>
    </field>
    <doc>
    <![CDATA[utility class for throwables.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Throwables -->
  <!-- start class org.spf4j.base.Throwables.PackageDetail -->
  <class name="Throwables.PackageDetail" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Throwables.PackageDetail[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Throwables.PackageDetail"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="NONE" type="org.spf4j.base.Throwables.PackageDetail"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No jar info or version info.]]>
      </doc>
    </field>
    <field name="SHORT" type="org.spf4j.base.Throwables.PackageDetail"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[jar file name + manifest version.]]>
      </doc>
    </field>
    <field name="LONG" type="org.spf4j.base.Throwables.PackageDetail"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[complete jar path + manifest version.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[enum describing the PackageDetail level to be logged in the stack trace.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Throwables.PackageDetail -->
  <!-- start class org.spf4j.base.Throwables.TrimmedException -->
  <class name="Throwables.TrimmedException" extends="java.lang.Exception"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TrimmedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="fillInStackTrace" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Throwables.TrimmedException -->
  <!-- start class org.spf4j.base.TimeoutDeadline -->
  <class name="TimeoutDeadline" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimeoutDeadline" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.TimeoutDeadline"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutNanos" type="long"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getTimeoutNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.TimeoutDeadline -->
  <!-- start class org.spf4j.base.TimeoutRunnable -->
  <class name="TimeoutRunnable" extends="org.spf4j.base.CheckedRunnable"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="use RetryPolicy">
    <implements name="java.util.concurrent.Callable"/>
    <constructor name="TimeoutRunnable" type="long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimeoutRunnable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doRun"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="doRun"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pdeadlineMillis" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="getDeadlineMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="call" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly
 @deprecated use RetryPolicy]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.TimeoutRunnable -->
  <!-- start class org.spf4j.base.TimeSource -->
  <class name="TimeSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nanoTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get JVM. time source. Default implementation calls System.nanotime.

 @return]]>
      </doc>
    </method>
    <method name="nanoTimeSupplier" return="java.util.function.LongSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="currentTimeNanos" type="long"/>
      <param name="timeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeToDeadlineStrict" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getTimeToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <doc>
    <![CDATA[Utility method to convert between TimeSource.nanoTime and System.currentTimeMillis
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.TimeSource -->
  <!-- start class org.spf4j.base.Timing -->
  <class name="Timing" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="updateTiming"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fromNanoTimeToEpochMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nanoTime" type="long"/>
    </method>
    <method name="fromNanoTimeToInstant" return="java.time.Instant"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nanoTime" type="long"/>
    </method>
    <method name="fromEpochMillisToNanoTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="epochTimeMillis" type="long"/>
    </method>
    <method name="getCurrentTiming" return="org.spf4j.base.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopUpdate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="MAX_MS_SPAN" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Utility class that allows for quick conversion between nanotime and epoch relative time.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Timing -->
  <!-- start class org.spf4j.base.TLScratch -->
  <class name="TLScratch" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getBytesTmp" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[returns a thread local byte array of at least the size requested. use only for temporary purpose. This method needs
 to be carefully used!

 @param size - the minimum size of the temporary buffer requested.
 @return - the temporary buffer.]]>
      </doc>
    </method>
    <method name="getCharsTmp" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[returns a thread local char array of at least the requested size. Use only for temporary purpose.

 @param size - the minimum size of the temporary buffer requested.
 @return - the temporary buffer.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.TLScratch -->
  <!-- start class org.spf4j.base.UncheckedExecutionException -->
  <class name="UncheckedExecutionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedExecutionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedExecutionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedExecutionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedExecutionException" type="java.lang.String, java.lang.Throwable, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.UncheckedExecutionException -->
  <!-- start class org.spf4j.base.UncheckedTimeoutException -->
  <class name="UncheckedTimeoutException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedTimeoutException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String, java.lang.Throwable, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.UncheckedTimeoutException -->
  <!-- start class org.spf4j.base.UnsafeString -->
  <class name="UnsafeString" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="steal" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Steal the underlying character array of a String.

 @param str
 @return]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="char[]"/>
      <doc>
      <![CDATA[Create a String based on the provided character array. No copy of the array is made.

 @param chars
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Lower lever unsafe hacks for performance improvement.
 These optimizations will work only up to including JDK 8.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.UnsafeString -->
  <!-- start class org.spf4j.base.UnsafeThrowable -->
  <class name="UnsafeThrowable" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getSuppressedNoCopy" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.UnsafeThrowable -->
  <!-- start class org.spf4j.base.Version -->
  <class name="Version" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="Version" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Version" type="java.lang.CharSequence"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.base.Version"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getImage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getComponents" return="java.lang.Comparable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getComponent" return="java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="int"/>
    </method>
    <method name="getMajor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMinor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPatch" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrComponents" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Version -->
  <!-- start interface org.spf4j.base.Wrapper -->
  <interface name="Wrapper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getWrapped" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the wrapped object by this wrapper.]]>
      </doc>
    </method>
    <method name="getTopWrapped" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An interface to uniformly access wrapped objects + wrap.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Wrapper -->
  <!-- start interface org.spf4j.base.Writeable -->
  <interface name="Writeable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
    </method>
    <doc>
    <![CDATA[Interface for Objects that can write themselves to a appendable.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Writeable -->
  <!-- start class org.spf4j.base.XCollectors -->
  <class name="XCollectors" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="last" return="java.util.stream.Collector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
    </method>
    <method name="last" return="java.util.stream.Collector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <param name="addIfLimited" type="java.lang.Object"/>
    </method>
    <method name="last" return="java.util.stream.Collector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dqSupp" type="java.util.function.Supplier"/>
      <param name="limit" type="int"/>
      <param name="addIfLimited" type="java.lang.Object"/>
    </method>
    <method name="limitDequeue"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l1" type="java.util.Deque"/>
      <param name="limit" type="int"/>
      <param name="addIfLimited" type="java.lang.Object"/>
    </method>
    <method name="filtering" return="java.util.stream.Collector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="java.util.function.Predicate"/>
      <param name="downstream" type="java.util.stream.Collector"/>
      <doc>
      <![CDATA[THis is a backport from JDK9.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.XCollectors -->
</package>
<package name="org.spf4j.trace.avro">
</package>
<package name="org.spf4j.unix">
  <!-- start interface org.spf4j.unix.CLibrary -->
  <interface name="CLibrary"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.sun.jna.platform.unix.LibCAPI"/>
    <implements name="com.sun.jna.Library"/>
    <method name="fork" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="gethostname" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="byte[]"/>
      <param name="len" type="int"/>
    </method>
    <method name="strsignal" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sigNumber" type="int"/>
      <doc>
      <![CDATA[returns signal name from a signal number.
 @param sigNumber the signal number.
 @return the signal name.]]>
      </doc>
    </method>
    <method name="kill" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="int"/>
      <param name="signum" type="int"/>
    </method>
    <method name="setsid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setuid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newuid" type="short"/>
    </method>
    <method name="setgid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newgid" type="short"/>
    </method>
    <method name="umask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mask" type="int"/>
    </method>
    <method name="getpid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current process id.
 https://www.systutorials.com/docs/linux/man/2-getppid/
 @return current process id.]]>
      </doc>
    </method>
    <method name="getppid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get parent process id.
 https://www.systutorials.com/docs/linux/man/2-getppid/
 @return parent process id.]]>
      </doc>
    </method>
    <method name="chdir" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.lang.String"/>
    </method>
    <method name="execv" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="args" type="com.sun.jna.StringArray"/>
    </method>
    <method name="execvp" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="args" type="com.sun.jna.StringArray"/>
    </method>
    <method name="setenv" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="perror"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="strerror" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errno" type="int"/>
    </method>
    <method name="sysctlbyname" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="oldp" type="com.sun.jna.Pointer"/>
      <param name="oldlenp" type="com.sun.jna.ptr.IntByReference"/>
      <param name="newp" type="com.sun.jna.Pointer"/>
      <param name="newlen" type="com.sun.jna.ptr.IntByReference"/>
    </method>
    <method name="sysctl" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mib" type="int[]"/>
      <param name="nameLen" type="int"/>
      <param name="oldp" type="com.sun.jna.Pointer"/>
      <param name="oldlenp" type="com.sun.jna.ptr.IntByReference"/>
      <param name="newp" type="com.sun.jna.Pointer"/>
      <param name="newlen" type="com.sun.jna.ptr.IntByReference"/>
    </method>
    <method name="sysctlnametomib" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="mibp" type="com.sun.jna.Pointer"/>
      <param name="size" type="com.sun.jna.ptr.IntByReference"/>
    </method>
    <method name="fopen" return="org.spf4j.unix.CLibrary.FILE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <param name="mode" type="java.lang.String"/>
    </method>
    <method name="freopen" return="org.spf4j.unix.CLibrary.FILE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <param name="mode" type="java.lang.String"/>
      <param name="stream" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="fseek" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
      <param name="offset" type="long"/>
      <param name="whence" type="int"/>
    </method>
    <method name="ftell" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="fread" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="com.sun.jna.Pointer"/>
      <param name="size" type="int"/>
      <param name="count" type="int"/>
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="fclose" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="getdtablesize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fcntl" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="int"/>
      <param name="command" type="int"/>
    </method>
    <method name="fcntl" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="int"/>
      <param name="command" type="int"/>
      <param name="flags" type="int"/>
    </method>
    <method name="readlink" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="buffer" type="com.sun.jna.Memory"/>
      <param name="size" type="com.sun.jna.NativeLong"/>
      <doc>
      <![CDATA[Read a symlink. The name will be copied into the specified memory, and returns the number of bytes copied. The
 string is not null-terminated.

 @return if the return value equals size, the caller needs to retry with a bigger buffer. If -1, error.]]>
      </doc>
    </method>
    <field name="INSTANCE" type="org.spf4j.unix.CLibrary"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="F_GETFD" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="F_SETFD" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FD_CLOEXEC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[GNU C library.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.unix.CLibrary -->
  <!-- start class org.spf4j.unix.CLibrary.FILE -->
  <class name="CLibrary.FILE" extends="com.sun.jna.PointerType"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FILE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FILE" type="com.sun.jna.Pointer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.spf4j.unix.CLibrary.FILE -->
  <!-- start class org.spf4j.unix.JVMArguments -->
  <class name="JVMArguments" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JVMArguments" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="JVMArguments" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExecutable" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeSystemProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the first System property.
 @param pname the name of the system property to remove.
 @return the value of the removed system property. or null if there is no such property.]]>
      </doc>
    </method>
    <method name="getSystemProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
    </method>
    <method name="createOrUpdateSystemProperty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
      <param name="replacer" type="java.util.function.Function"/>
    </method>
    <method name="hasSystemProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
    </method>
    <method name="removeAllSystemPropertiesStartingWith" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
      <doc>
      <![CDATA[remove all system properties starting with a prefix.
 @param pname the prefix
 @return number of system properties removed.]]>
      </doc>
    </method>
    <method name="setSystemProperty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="setVMArgument"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="removeVMArgument" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="removeVMArgumentStartingWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="hasVMArgument" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="hasVMArgumentStartingWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argumentPrefix" type="java.lang.String"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arg" type="java.lang.String"/>
    </method>
    <method name="removeTail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Removes the n items from the end. Useful for removing all the Java arguments to rebuild them.]]>
      </doc>
    </method>
    <method name="toStringArray" return="com.sun.jna.StringArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="current" return="org.spf4j.unix.JVMArguments"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the process argument list of the current process.]]>
      </doc>
    </method>
    <method name="of" return="org.spf4j.unix.JVMArguments"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the process argument list of the specified process ID.

 @param pid -1 to indicate the current process.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[List of arguments for Java VM and application. based on class from akuma lib (http://akuma.kohsuke.org).]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.JVMArguments -->
  <!-- start class org.spf4j.unix.Lsof -->
  <class name="Lsof" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getNrOpenFiles" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getLsofOutput" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.Lsof -->
  <!-- start class org.spf4j.unix.Ulimit -->
  <class name="Ulimit" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="see UnixResources for better/faster alternative.">
    <method name="runUlimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="options" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param options
 @return number of max open files for the current process. If unable to find out System Max Limit this value will be
 Integer.MAX_VALUE]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@deprecated see UnixResources for better/faster alternative.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.Ulimit -->
  <!-- start class org.spf4j.unix.UnixConstants -->
  <class name="UnixConstants" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="O_RDONLY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_WRONLY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_RDWR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_APPEND" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_CREAT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_EXCL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_TRUNC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_SYNC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_DSYNC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_NOFOLLOW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IAMB" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IRUSR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IWUSR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IXUSR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IRGRP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IWGRP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IXGRP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IROTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IWOTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IXOTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFMT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFREG" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFLNK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFCHR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFBLK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFIFO" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="R_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="W_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="X_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="F_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOENT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EACCES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EEXIST" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOTDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EINVAL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EXDEV" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EISDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOTEMPTY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOSPC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EAGAIN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOSYS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ELOOP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EROFS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENODATA" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERANGE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AT_SYMLINK_NOFOLLOW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AT_REMOVEDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixConstants -->
  <!-- start class org.spf4j.unix.UnixException -->
  <class name="UnixException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnixException" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="errno" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="errorString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="translateToIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="other" type="java.lang.String"/>
      <doc>
      <![CDATA[Map well known errors to specific exceptions where possible; otherwise return more general FileSystemException.]]>
      </doc>
    </method>
    <method name="rethrowAsIOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Internal exception thrown by native methods when error detected.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixException -->
  <!-- start class org.spf4j.unix.UnixResources -->
  <class name="UnixResources" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.unix.UnixResources[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.unix.UnixResources"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getMacId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGnuId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSoftLimit" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <method name="setSoftLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="long"/>
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <method name="setLimits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="softLimit" type="long"/>
      <param name="hardlimit" type="long"/>
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <method name="getHardLimit" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <field name="RLIMIT_CPU" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[0 Per-process CPU limit, in seconds.]]>
      </doc>
    </field>
    <field name="RLIMIT_FSIZE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[1 Largest file that can be created, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_DATA" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[2 Maximum size of data segment, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_STACK" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[3 Maximum size of stack segment, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_CORE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[4 Largest core file that can be created, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_RSS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[5 Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size
 will be more likely to have physical memory taken from them.]]>
      </doc>
    </field>
    <field name="RLIMIT_NPROC" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[6 Number of processes.]]>
      </doc>
    </field>
    <field name="RLIMIT_NOFILE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[7 Number of open files.]]>
      </doc>
    </field>
    <field name="RLIMIT_MEMLOCK" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[8 Locked-in-memory address space.]]>
      </doc>
    </field>
    <field name="RLIMIT_AS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[9 Address space limit.]]>
      </doc>
    </field>
    <field name="RLIMIT_LOCKS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[10 Maximum number of file locks.]]>
      </doc>
    </field>
    <field name="RLIMIT_SIGPENDING" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[11 Maximum number of pending signals.]]>
      </doc>
    </field>
    <field name="RLIMIT_MSGQUEUE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[12 Maximum bytes in POSIX message queues.]]>
      </doc>
    </field>
    <field name="RLIMIT_NICE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[13 Maximum nice priority allowed to raise to. Nice levels 19 .. -20 correspond to 0 .. 39 values of this resource
 limit.]]>
      </doc>
    </field>
    <field name="RLIMIT_RTPRIO" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[14]]>
      </doc>
    </field>
    <field name="RLIMIT_RTTIME" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[15 Maximum CPU time in microseconds that a process scheduled under a real-time scheduling policy may consume
 without making a blocking system call before being forcibly de-scheduled.]]>
      </doc>
    </field>
    <field name="RLIMIT_NLIMITS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[16 Number of {@code rlimit} values]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Possible values of the first parameter to getrlimit()/setrlimit()
 A combination of com.sun.jna.platform.unix.Resource and MACOSX resource.h
 this class requires jna-platforn which is a optional dependency.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixResources -->
  <!-- start class org.spf4j.unix.UnixRuntime -->
  <class name="UnixRuntime" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restart current process with same arguments except -Dspf4j.restart which is added/updated.
 @throws IOException]]>
      </doc>
    </method>
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newArguments" type="org.spf4j.unix.JVMArguments"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restart current process.
 This will issue a "exec" system call after closing all existing open files.
 @param newArguments new process arguments. spf4j has a system property: spf4j.restart that will automatically add
 or update to indicate a process was restarted and how many times.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixRuntime -->
  <!-- start class org.spf4j.unix.UnixRuntimeException -->
  <class name="UnixRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnixRuntimeException" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="errno" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="errorString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="translateToIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="other" type="java.lang.String"/>
      <doc>
      <![CDATA[Map well known errors to specific exceptions where possible; otherwise return more general FileSystemException.]]>
      </doc>
    </method>
    <method name="rethrowAsIOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Internal exception thrown by native methods when error detected.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixRuntimeException -->
</package>
<package name="org.spf4j.perf.cpu">
  <!-- start class org.spf4j.perf.cpu.CpuUsageSampler -->
  <class name="CpuUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getProcessCpuTimeNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.cpu.CpuUsageSampler -->
  <!-- start class org.spf4j.perf.cpu.ThreadUsageSampler -->
  <class name="ThreadUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writePeakThreadInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintStream"/>
    </method>
    <method name="logPeakThreadInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="java.util.logging.Level"/>
    </method>
    <method name="getPeakThreadInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clearPeakThreadInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPeakTime" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentAliveThreadInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
      <param name="withStackTraces" type="boolean"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.cpu.ThreadUsageSampler -->
</package>
<package name="org.spf4j.concurrent.jdbc">
  <!-- start class org.spf4j.concurrent.jdbc.HeartBeatError -->
  <class name="HeartBeatError" extends="java.lang.Error"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HeartBeatError"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HeartBeatError" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HeartBeatError" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HeartBeatError" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A Error specifying that a Heartbeat cannot be done.
 THis should be handled as a unrecoverable error in a distributed environment.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.HeartBeatError -->
  <!-- start class org.spf4j.concurrent.jdbc.HeartBeatTableDesc -->
  <class name="HeartBeatTableDesc" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="HeartBeatTableDesc" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.spf4j.jdbc.DbType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntervalColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastHeartbeatColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDbType" return="org.spf4j.jdbc.DbType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withDbType" return="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pdbType" type="org.spf4j.jdbc.DbType"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.HeartBeatTableDesc -->
  <!-- start class org.spf4j.concurrent.jdbc.JdbcHeartBeat -->
  <class name="JdbcHeartBeat" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getBeatDurationNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addLyfecycleHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
    </method>
    <method name="removeLifecycleHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
    </method>
    <method name="removeDeadHeartBeatRows" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="removeDeadHeartBeatRowsAsyncNoReturn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
    </method>
    <method name="removeDeadHeartBeatRowsAsync" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
    </method>
    <method name="scheduleHeartbeat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scheduler" type="com.google.common.util.concurrent.ListeningScheduledExecutorService"/>
    </method>
    <method name="beat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getLastRunDB" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getIntervalMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRunNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRunTimeStampString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeartBeatAndSubscribe" return="org.spf4j.concurrent.jdbc.JdbcHeartBeat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataSource" type="javax.sql.DataSource"/>
      <param name="hbTableDesc" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"/>
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[Get a reference to the hearbeat instance.
 @param dataSource  the datasource the hearbeat goes against.
 @param hbTableDesc - heartbeat table description.
 @param hook  a hook to notify when heartbeat fails.
 @return the heartbeat instance.]]>
      </doc>
    </method>
    <method name="getHeartBeatAndSubscribe" return="org.spf4j.concurrent.jdbc.JdbcHeartBeat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataSource" type="javax.sql.DataSource"/>
      <param name="hbTableDesc" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"/>
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
      <param name="heartBeatIntevalMillis" type="int"/>
      <param name="jdbcTimeoutSeconds" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getHeartBeatAndSubscribe" return="org.spf4j.concurrent.jdbc.JdbcHeartBeat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataSource" type="javax.sql.DataSource"/>
      <param name="hbTableDesc" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"/>
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
      <param name="heartBeatIntevalMillis" type="int"/>
      <param name="jdbcTimeoutSeconds" type="int"/>
      <param name="scheduler" type="com.google.common.util.concurrent.ListeningScheduledExecutorService"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="stopHeartBeats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHbTableDesc" return="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that does "heartbeats" (at a arbitrary inteval) to a database table.
 This is to detect the death of a process.
 The process is considered dead when: currentTime - lastheartbeat > beatInterval * 2
 When this class mechanism detects that it cannot perform the heartbeats it throws a Error.
 The sensible this for the process is to go down (and restart if it is a daemon).
 This is typically done by registering a default uncaught exception handler with:
 Thread.setDefaultUncaughtExceptionHandler


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.JdbcHeartBeat -->
  <!-- start interface org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook -->
  <interface name="JdbcHeartBeat.LifecycleHook"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Error"/>
    </method>
    <method name="onClose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook -->
  <!-- start class org.spf4j.concurrent.jdbc.JdbcLock -->
  <class name="JdbcLock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.locks.Lock"/>
    <implements name="java.lang.AutoCloseable"/>
    <constructor name="JdbcLock" type="javax.sql.DataSource, org.spf4j.concurrent.jdbc.SemaphoreTablesDesc, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </constructor>
    <method name="lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lockInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newCondition" return="java.util.concurrent.locks.Condition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Jdbc Lock implementation.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.JdbcLock -->
  <!-- start class org.spf4j.concurrent.jdbc.JdbcSemaphore -->
  <class name="JdbcSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[@param dataSource  the jdbc data source with the Semaphores table. Please be sensible, no "test on borrow" pools.
 @param semaphoreName  number of initial permits, if semaphore already exists the existing nr of permits is kept.
 @param nrPermits  the number of initial permits.]]>
      </doc>
    </constructor>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, java.lang.String, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[create a JDBC Semaphore. create one instance / process.

 @param dataSource  the data source to use for sync.
 @param semaphoreName  the semaphore name.
 @param nrPermits  number of initial permits.
 @param strict  if true, if semaphore already exists and the total permits is different that param nrPermits an
 IllegalArgumentException will be thrown.]]>
      </doc>
    </constructor>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, org.spf4j.concurrent.jdbc.SemaphoreTablesDesc, java.lang.String, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </constructor>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, org.spf4j.concurrent.jdbc.SemaphoreTablesDesc, java.lang.String, int, int, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </constructor>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrReservations" type="int"/>
    </method>
    <method name="releaseAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="availablePermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="permitsOwned" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="totalPermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getDeadOwnerPermits" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wishPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="releaseDeadOwnerPermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wishPermits" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[Attempts to release permits for this semaphore owned by dead owners.

 @param wishPermits - How many permits we would like to get released.
 @return - the number of permits we actually released.
 @throws SQLException - something went wrong with the db.
 @throws InterruptedException - thrown if thread is interrupted.]]>
      </doc>
    </method>
    <method name="updatePermits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="reducePermits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="increasePermits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="removeDeadHeartBeatAndNotOwnerRows" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Throwable" type="java.lang.Throwable"/>
    </method>
    <method name="getJdbcTimeoutSeconds" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isIsHealthy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A jdbc table based distributes semaphore implementation.
 Similar with a semaphore implemented with zookeeper, we rely on
 heartbeats to detect dead members. If you have a zookeeper instance accessible you should probably use a semaphore
 implemented with it... If you are already connecting to a database, this should be a reliable and low overhead
 implementation. Using a crappy database will give you crappy results.

 There are 3 tables involved:

 SEMAPHORES - keep track of available and total permits by semaphore.
 PERMITS_BY_OWNER - keeps track of all permits by
 owner.
 HEARTBEATS - keeps heartbeats by owner to detect - dead owners.

 All table names and columns are customizable to adapt this implementation to different naming conventions.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.JdbcSemaphore -->
  <!-- start class org.spf4j.concurrent.jdbc.OwnerPermits -->
  <class name="OwnerPermits" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="OwnerPermits" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrPermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.OwnerPermits -->
  <!-- start class org.spf4j.concurrent.jdbc.ProcessLimitedJdbcSemaphore -->
  <class name="ProcessLimitedJdbcSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="ProcessLimitedJdbcSemaphore" type="org.spf4j.concurrent.jdbc.JdbcSemaphore, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrReservations" type="int"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.ProcessLimitedJdbcSemaphore -->
  <!-- start class org.spf4j.concurrent.jdbc.SemaphoreTablesDesc -->
  <class name="SemaphoreTablesDesc" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="SemaphoreTablesDesc" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSemaphoreTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSemNameColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAvailablePermitsColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTotalPermitsColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastModifiedByColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastModifiedAtColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPermitsByOwnerTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerPermitsColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeartBeatTableDesc" return="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withDbType" return="org.spf4j.concurrent.jdbc.SemaphoreTablesDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dbType" type="org.spf4j.jdbc.DbType"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT" type="org.spf4j.concurrent.jdbc.SemaphoreTablesDesc"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.SemaphoreTablesDesc -->
</package>
<package name="org.spf4j.tsdb2">
  <!-- start class org.spf4j.tsdb2.TableDefs -->
  <class name="TableDefs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="from" return="org.spf4j.tsdb2.avro.TableDef"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="id" type="long"/>
    </method>
    <method name="sanitizeName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="createSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
    </method>
    <method name="toRecord" return="org.spf4j.perf.TimeSeriesRecord"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rSchema" type="org.apache.avro.Schema"/>
      <param name="baseTs" type="long"/>
      <param name="row" type="org.spf4j.tsdb2.avro.DataRow"/>
    </method>
    <method name="toRecord" return="org.spf4j.perf.TimeSeriesRecord"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rSchema" type="org.apache.avro.Schema"/>
      <param name="row" type="org.spf4j.tsdb2.avro.Observation"/>
    </method>
    <method name="getMeasurementType" return="org.spf4j.tsdb2.avro.MeasurementType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.spf4j.tsdb2.avro.TableDef"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TableDefs -->
  <!-- start class org.spf4j.tsdb2.TimeSeries -->
  <class name="TimeSeries" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimeSeries" type="long[], long[][]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTimeStamps" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValues" return="long[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TimeSeries -->
  <!-- start class org.spf4j.tsdb2.TSDBQuery -->
  <class name="TSDBQuery" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasurementType" return="org.spf4j.tsdb2.avro.MeasurementType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
    </method>
    <method name="getAllTables" return="com.google.common.collect.ListMultimap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTables" return="com.google.common.collect.ListMultimap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tables" type="java.util.Set"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAllTablesWithDataRanges" return="com.google.common.collect.ListMultimap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTableDef" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTimeSeries" return="org.spf4j.tsdb2.TimeSeries"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tableIds" type="long[]"/>
      <param name="startTimeMillis" type="long"/>
      <param name="endTimeMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTimeSeries"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tableIds" type="long[]"/>
      <param name="startTimeMillis" type="long"/>
      <param name="endTimeMillis" type="long"/>
      <param name="consumer" type="java.util.function.BiConsumer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTimeSeriesData" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <param name="startTimeMillis" type="long"/>
      <param name="endTimeMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@param tsdbFile
 @param tableName
 @param startTimeMillis
 @param endTimeMillis
 @return iterator through the results, null when not table found.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getTimeSeriesData" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="startTimeMillis" type="long"/>
      <param name="endTimeMillis" type="long"/>
      <param name="ids" type="java.util.Collection"/>
      <param name="rSchema" type="org.apache.avro.Schema"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTimeSeriesData" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toRecord" return="com.google.common.base.Function"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rSchema" type="org.apache.avro.Schema"/>
    </method>
    <method name="getIds" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableDefs" type="java.util.Collection"/>
    </method>
    <method name="writeCsvTable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsDB" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <param name="output" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeAsCsv"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="tsDB" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvTables"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsDB" type="java.io.File"/>
      <param name="tableNames" type="java.util.Set"/>
      <param name="output" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getColumnDefIfExists" return="org.spf4j.tsdb2.avro.ColumnDef"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
      <param name="columnName" type="java.lang.String"/>
    </method>
    <method name="getColumnDef" return="org.spf4j.tsdb2.avro.ColumnDef"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
      <param name="columnName" type="java.lang.String"/>
    </method>
    <method name="getColumnIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
      <param name="columnName" type="java.lang.String"/>
    </method>
    <method name="getColumnNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
    </method>
    <method name="getColumnUnitsOfMeasurement" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBQuery -->
  <!-- start class org.spf4j.tsdb2.TSDBQuery.TableDefEx -->
  <class name="TSDBQuery.TableDefEx" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TableDefEx" type="org.spf4j.tsdb2.avro.TableDef, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTableDef" return="org.spf4j.tsdb2.avro.TableDef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEndTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setStartTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTime" type="long"/>
    </method>
    <method name="setEndTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endTime" type="long"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBQuery.TableDefEx -->
  <!-- start class org.spf4j.tsdb2.TSDBReader -->
  <class name="TSDBReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TSDBReader" type="java.io.File, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="TSDBReader" type="java.io.File, int, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="reReadSize" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[method useful when implementing tailing.

 @return true if size changed.
 @throws IOException]]>
      </doc>
    </method>
    <method name="read" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getSize" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeader" return="org.spf4j.tsdb2.avro.Header"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopWatching"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="bgWatch" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
    </method>
    <method name="bgWatch" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="bgWatch" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="watch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="watch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="watch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="readAll"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="readAll"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.Consumer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBReader -->
  <!-- start class org.spf4j.tsdb2.TSDBReader.EventSensitivity -->
  <class name="TSDBReader.EventSensitivity" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.tsdb2.TSDBReader.EventSensitivity[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="HIGH" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MEDIUM" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOW" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBReader.EventSensitivity -->
  <!-- start class org.spf4j.tsdb2.TSDBWriter -->
  <class name="TSDBWriter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="java.io.Flushable"/>
    <constructor name="TSDBWriter" type="java.io.File, int, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="writeTableDef" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableDef" type="org.spf4j.tsdb2.avro.TableDef"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDataRow"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timestamp" type="long"/>
      <param name="data" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pvalue" type="long"/>
      <param name="bytes" type="byte[]"/>
      <param name="idx" type="int"/>
    </method>
    <method name="toOutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pvalue" type="long"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Commits the data to disk.

 @throws IOException]]>
      </doc>
    </method>
    <method name="getHeader" return="org.spf4j.tsdb2.avro.Header"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="FILE_RECORD_SCHEMA" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Second generation Time-Series database format. The linked list structure from first generation is dropped to reduce
 write overhead.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBWriter -->
</package>
<package name="org.spf4j.io.tcp">
  <!-- start class org.spf4j.io.tcp.AcceptorSelectorEventHandler -->
  <class name="AcceptorSelectorEventHandler" extends="org.spf4j.io.tcp.SelectorEventHandler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AcceptorSelectorEventHandler" type="java.nio.channels.ServerSocketChannel, org.spf4j.io.tcp.ClientHandler, java.nio.channels.Selector, java.util.concurrent.ExecutorService, java.util.concurrent.BlockingQueue, org.spf4j.ds.UpdateablePriorityQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="canRunAsync" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
    </method>
    <method name="initialInterestRegistration" return="java.nio.channels.SelectionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.AcceptorSelectorEventHandler -->
  <!-- start interface org.spf4j.io.tcp.ClientHandler -->
  <interface name="ClientHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverSelector" type="java.nio.channels.Selector"/>
      <param name="clientChannel" type="java.nio.channels.SocketChannel"/>
      <param name="exec" type="java.util.concurrent.ExecutorService"/>
      <param name="tasksToRunBySelector" type="java.util.concurrent.BlockingQueue"/>
      <param name="deadlineActions" type="org.spf4j.ds.UpdateablePriorityQueue"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.tcp.ClientHandler -->
  <!-- start class org.spf4j.io.tcp.DeadlineAction -->
  <class name="DeadlineAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DeadlineAction" type="long, java.lang.Runnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAction" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="COMPARATOR" type="java.util.Comparator"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.DeadlineAction -->
  <!-- start class org.spf4j.io.tcp.SelectorEventHandler -->
  <class name="SelectorEventHandler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SelectorEventHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialInterestRegistration" return="java.nio.channels.SelectionKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
      <doc>
      <![CDATA[Method must be invoked in selector thread.
 THis will register this handler to Selector + channel.
 @return
 @throws ClosedChannelException]]>
      </doc>
    </method>
    <method name="canRunAsync" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.SelectorEventHandler -->
  <!-- start class org.spf4j.io.tcp.TcpServer -->
  <class name="TcpServer" extends="org.spf4j.concurrent.RestartableServiceImpl"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TcpServer" type="java.util.concurrent.ExecutorService, org.spf4j.io.tcp.ClientHandler, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TcpServer" type="java.util.concurrent.ExecutorService, org.spf4j.io.tcp.ClientHandler, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.TcpServer -->
  <!-- start class org.spf4j.io.tcp.TcpServer.TcpServerGuavaService -->
  <class name="TcpServer.TcpServerGuavaService" extends="com.google.common.util.concurrent.AbstractExecutionThreadService"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TcpServerGuavaService" type="java.util.concurrent.ExecutorService, org.spf4j.io.tcp.ClientHandler, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="triggerShutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.tcp.TcpServer.TcpServerGuavaService -->
</package>
<package name="org.spf4j.io">
  <!-- start class org.spf4j.io.AppendableLimiterWithOverflow -->
  <class name="AppendableLimiterWithOverflow" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Appendable"/>
    <implements name="java.io.Closeable"/>
    <constructor name="AppendableLimiterWithOverflow" type="int, java.io.File, java.lang.CharSequence, java.nio.charset.Charset, java.lang.Appendable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AppendableLimiterWithOverflow" type="int, java.lang.Appendable, org.spf4j.io.AppendableLimiterWithOverflow.OverflowSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOverflowIfNeeded"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility class that limits the nr of characters written to a particular Appender.
 if nr of characters exceed the limit the character above the limit + entire message are written to
 the specified file.
 THe destination appender will contain the chars that fit the limit + a reference to the overflow file
 if overflow happened.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.AppendableLimiterWithOverflow -->
  <!-- start interface org.spf4j.io.AppendableLimiterWithOverflow.OverflowSupplier -->
  <interface name="AppendableLimiterWithOverflow.OverflowSupplier"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOverflowReference" return="java.lang.CharSequence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return - a string that you can use to reference the overflow. (file name, url...)
 this string is used as a suffix for the appender that is being limited.]]>
      </doc>
    </method>
    <method name="getOverflowWriter" return="java.io.Writer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return - a writer to write the overflow.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[provide the overflow.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.AppendableLimiterWithOverflow.OverflowSupplier -->
  <!-- start class org.spf4j.io.AppendableOutputStream -->
  <class name="AppendableOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.CharsetDecoder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.

 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.CharsetDecoder, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.

 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @param bufferSize the size of the output buffer in number of characters
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.

 @param writer the target {@link Writer}
 @param charset the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.

 @param writer the target {@link Writer}
 @param charset the charset encoding]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.

 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.

 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="poff" type="int"/>
      <param name="plen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write bytes from the specified byte array to the stream.

 @param b the byte array containing the bytes to write
 @param poff the start offset in the byte array
 @param plen the number of bytes to write
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write bytes from the specified byte array to the stream.

 @param b the byte array containing the bytes to write
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a single byte to the stream.

 @param b the byte to write
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#flush()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#close()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="processInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="endOfInput" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decode the contents of the input ByteBuffer into a CharBuffer.

 @param endOfInput indicates end of input
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="flushOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the output.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="decoderOut" type="java.nio.CharBuffer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[CharBuffer used as output for the decoder. It should be
 somewhat larger as we write from this buffer to the
 underlying Writer.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[{@link OutputStream} implementation that transforms a byte stream to a
 character stream using a specified character set encoding and writes the resulting
 stream to a {@link Writer}. The stream is transformed using a
 {@link CharsetDecoder} object, guaranteeing that all character set
 encodings supported by the JRE are handled correctly.
 <p>
 The output of the {@link CharsetDecoder} is buffered using a fixed size buffer.
 This implies that the data is written to the underlying {@link Writer} in chunks
 that are no larger than the size of this buffer. By default, the buffer is
 flushed only when it overflows or when {@link #flush()} or {@link #close()}
 is called. In general there is therefore no need to wrap the underlying {@link Writer}
 in a {@link java.io.BufferedWriter}. {@link WriterOutputStream} can also
 be instructed to flush the buffer after each write operation. In this case, all
 available data is written immediately to the underlying {@link Writer}, implying that
 the current position of the {@link Writer} is correlated to the current position
 of the {@link AppendableOutputStream}.
 <p>
 {@link AppendableOutputStream} implements the inverse transformation of {@link java.io.OutputStreamWriter};
 in the following example, writing to {@code out2} would have the same result as writing to
 {@code out} directly (provided that the byte sequence is legal with respect to the
 character set encoding):
 <pre>
 OutputStream out = ...
 Charset cs = ...
 OutputStreamWriter writer = new OutputStreamWriter(out, cs);
 AppendableOutputStream out2 = new AppendableOutputStream(writer, cs);</pre>
 {@link WriterOutputStream} implements the same transformation as {@link java.io.InputStreamReader},
 except that the control flow is reversed: both classes transform a byte stream
 into a character stream, but {@link java.io.InputStreamReader} pulls data from the underlying stream,
 while {@link AppendableOutputStream} pushes it to the underlying stream.
 <p>
 Note that while there are use cases where there is no alternative to using
 this class, very often the need to use this class is an indication of a flaw
 in the design of the code. This class is typically used in situations where an existing
 API only accepts an {@link OutputStream} object, but where the stream is known to represent
 character data that must be decoded for further use.
 <p>
 Instances of {@link AppendableOutputStream} are not thread safe.

 @see org.apache.commons.io.input.ReaderInputStream

 @since 7.2.25]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.AppendableOutputStream -->
  <!-- start class org.spf4j.io.AppendableWriter -->
  <class name="AppendableWriter" extends="java.io.Writer"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AppendableWriter" type="java.lang.Appendable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility class to adapt a Appendable to a Writer.
 this is a faster version of guava: CharStreams.asWriter
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.AppendableWriter -->
  <!-- start class org.spf4j.io.BufferedInputStream -->
  <class name="BufferedInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="BufferedInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedInputStream" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedInputStream" type="java.io.InputStream, int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.BufferedInputStream -->
  <!-- start class org.spf4j.io.BufferedOutputStream -->
  <class name="BufferedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="BufferedOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedOutputStream" type="java.io.OutputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedOutputStream" type="java.io.OutputStream, int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Better that the JDK outputstream, no exception swallowing...
 and ability to recycle underlying byte array.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.BufferedOutputStream -->
  <!-- start class org.spf4j.io.ByteArrayBuilder -->
  <class name="ByteArrayBuilder" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteArrayBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteArrayBuilder" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteArrayBuilder" type="int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new byte array output stream, with a buffer capacity of the specified size, in bytes.

 @param size the initial size.
 @exception IllegalArgumentException if size is negative.]]>
      </doc>
    </constructor>
    <method name="getBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Writes the specified byte to this byte array output stream.

 @param b the byte to be written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array
 output stream.

 @param b the data.
 @param off the start offset in the data.
 @param len the number of bytes to write.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the complete contents of this byte array output stream to the specified output stream argument, as if by
 calling the output stream's write method using <code>out.write(buf, 0, count)</code>.

 @param out the output stream to which to write the data.
 @exception IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readFrom"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the <code>count</code> field of this byte array output stream to zero, so that all currently accumulated
 output in the output stream is discarded. The output stream can be used again, reusing the already allocated buffer
 space.

 @see java.io.ByteArrayInputStream#count]]>
      </doc>
    </method>
    <method name="resetCountTo"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="int"/>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a newly allocated byte array. Its size is the current size of this output stream and the valid contents of
 the buffer have been copied into it.

 @return the current contents of this output stream, as a byte array.
 @see java.io.ByteArrayOutputStream#size()]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current size of the buffer.

 @return the value of the <code>count</code> field, which is the number of valid bytes in this output stream.
 @see java.io.ByteArrayOutputStream#count]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Converts the buffer's contents into a string decoding bytes using the platform's default character set. The length
 of the new <tt>String</tt>
 is a function of the character set, and hence may not be equal to the size of the buffer.

 <p>
 This method always replaces malformed-input and unmappable-character sequences with the default replacement string
 for the platform's default character set. The {@linkplain java.nio.charset.CharsetDecoder} class should be used
 when more control over the decoding process is required.

 @return String decoded from the buffer's contents.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closing a <tt>ByteArrayOutputStream</tt> will likely recycle the underlying buffer. use of the builder after close
 is not advised]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class to avoid replicating byte arrays for no good reason.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ByteArrayBuilder -->
  <!-- start class org.spf4j.io.CharArrayBuilder -->
  <class name="CharArrayBuilder" extends="java.io.Writer"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharArrayBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CharArrayBuilder" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CharArrayBuilder" type="int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new byte array output stream, with a buffer capacity of the specified size, in bytes.

 @param size the initial size.
 @exception IllegalArgumentException if size is negative.]]>
      </doc>
    </constructor>
    <method name="getBuffer" return="char[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="char[]"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Writes the specified byte to this byte array output stream.

 @param b the byte to be written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array
 output stream.

 @param b the data.
 @param off the start offset in the data.
 @param len the number of bytes to write.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the complete contents of this char array output stream to the specified output stream argument, as if by
 calling the output stream's write method using <code>out.write(buf, 0, count)</code>.

 @param out the output stream to which to write the data.
 @exception IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readFrom"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the <code>count</code> field of this byte array output stream to zero, so that all currently accumulated
 output in the output stream is discarded. The output stream can be used again, reusing the already allocated buffer
 space.

 @see java.io.ByteArrayInputStream#count]]>
      </doc>
    </method>
    <method name="resetCountTo"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="int"/>
    </method>
    <method name="toByteArray" return="char[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a newly allocated byte array. Its size is the current size of this output stream and the valid contents of
 the buffer have been copied into it.

 @return the current contents of this output stream, as a byte array.
 @see java.io.ByteArrayOutputStream#size()]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current size of the buffer.

 @return the value of the <code>count</code> field, which is the number of valid bytes in this output stream.
 @see java.io.ByteArrayOutputStream#count]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Converts the buffer's contents into a string decoding bytes using the platform's default character set. The length
 of the new <tt>String</tt>
 is a function of the character set, and hence may not be equal to the size of the buffer.

 <p>
 This method always replaces malformed-input and unmappable-character sequences with the default replacement string
 for the platform's default character set. The {@linkplain java.nio.charset.CharsetDecoder} class should be used
 when more control over the decoding process is required.

 @return String decoded from the buffer's contents.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closing a <tt>ByteArrayOutputStream</tt> will likely recycle the underlying buffer, using the builder after close
 is NOT advised]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility class to avoid replicating character arrays for no good reason.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.CharArrayBuilder -->
  <!-- start class org.spf4j.io.ClosedOutputStream -->
  <class name="ClosedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.io.ClosedOutputStream"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[an OutputStream that will throw an exception is written to.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ClosedOutputStream -->
  <!-- start class org.spf4j.io.ConfigurableAppenderSupplier -->
  <class name="ConfigurableAppenderSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppenderSupplier"/>
    <constructor name="ConfigurableAppenderSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConfigurableAppenderSupplier" type="boolean, java.util.function.Predicate, org.spf4j.io.ObjectAppender[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppenderType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appender" type="org.spf4j.io.ObjectAppender"/>
    </method>
    <method name="register" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="appenders" type="org.spf4j.io.ObjectAppender[]"/>
    </method>
    <method name="replace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mt" type="org.spf4j.base.CoreTextMediaType"/>
      <param name="type" type="java.lang.Class"/>
      <param name="replace" type="java.util.function.Function"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="appender" type="org.spf4j.io.ObjectAppender"/>
    </method>
    <method name="tryRegister" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="appender" type="org.spf4j.io.ObjectAppender"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="contentType" type="org.spf4j.base.CoreTextMediaType"/>
      <param name="appender" type="org.spf4j.io.ObjectAppender"/>
    </method>
    <method name="tryRegister" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="contentType" type="org.spf4j.base.CoreTextMediaType"/>
      <param name="appender" type="org.spf4j.io.ObjectAppender"/>
    </method>
    <method name="unregister" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="get" return="org.spf4j.io.ObjectAppender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mt" type="org.spf4j.base.CoreTextMediaType"/>
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ConfigurableAppenderSupplier -->
  <!-- start class org.spf4j.io.CountingInputStream -->
  <class name="CountingInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Wrapper"/>
    <constructor name="CountingInputStream" type="java.io.InputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, counting the number of bytes read.

 @param in the input stream to be wrapped]]>
      </doc>
    </constructor>
    <constructor name="CountingInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes read.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWrapped" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that counts the number of bytes read.
 initial count can be provided]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.CountingInputStream -->
  <!-- start class org.spf4j.io.Csv -->
  <class name="Csv" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="readSystemProperty" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="defaults" type="java.lang.String[]"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow2"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="long[]"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Iterable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="java.lang.Iterable"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="row" type="java.lang.String"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvRowHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readNoBom" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[reads CSV format until EOF of reader.

 @param <T>
 @param preader
 @param handler
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="asIterable" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <doc>
      <![CDATA[read a CSV stream, as a Iterable over rows.
 the List<String> instance is reused during iteration, you will need to copy content into
 own data structure.
 @param preader
 @return]]>
      </doc>
    </method>
    <method name="reader" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readerNoBOM" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
    </method>
    <method name="writeCsvElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeQuotedCsvElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toCsvElement" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
    </method>
    <method name="readCsvElement" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="addElemTo" type="java.lang.StringBuilder"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[returns next character.

 @param reader
 @param addElemTo
 @return - next character or -1 if eof has been reached.
 @throws IOException]]>
      </doc>
    </method>
    <field name="CSV" type="org.spf4j.io.csv.CharSeparatedValues"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Supports CSV format as described at: https://en.wikipedia.org/wiki/Comma-separated_values. either of \n \r or \r\n
 are valid end of line delimiters

 why another implementation? because I need one that is as fast as possible, and as flexible as possible.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.Csv -->
  <!-- start interface org.spf4j.io.Csv.CsvHandler -->
  <interface name="Csv.CsvHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.csv.CsvHandler"/>
  </interface>
  <!-- end interface org.spf4j.io.Csv.CsvHandler -->
  <!-- start interface org.spf4j.io.Csv.CsvMapHandler -->
  <interface name="Csv.CsvMapHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.csv.CsvMapHandler"/>
  </interface>
  <!-- end interface org.spf4j.io.Csv.CsvMapHandler -->
  <!-- start interface org.spf4j.io.Csv.CsvRowHandler -->
  <interface name="Csv.CsvRowHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.csv.CsvRowHandler"/>
  </interface>
  <!-- end interface org.spf4j.io.Csv.CsvRowHandler -->
  <!-- start class org.spf4j.io.DebugInputStream -->
  <class name="DebugInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DebugInputStream" type="java.io.InputStream, java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.DebugInputStream -->
  <!-- start class org.spf4j.io.DeletingVisitor -->
  <class name="DeletingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.nio.file.FileVisitor"/>
    <constructor name="DeletingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitFile" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="postVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="preVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
    </method>
    <method name="visitFileFailed" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.DeletingVisitor -->
  <!-- start class org.spf4j.io.EmptyInputStream -->
  <class name="EmptyInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="java.io.InputStream"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.EmptyInputStream -->
  <!-- start class org.spf4j.io.EmptyReader -->
  <class name="EmptyReader" extends="java.io.Reader"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="java.io.Reader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.EmptyReader -->
  <!-- start class org.spf4j.io.FSWatchEventSensitivity -->
  <class name="FSWatchEventSensitivity" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.io.FSWatchEventSensitivity[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.io.FSWatchEventSensitivity"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="HIGH" type="org.spf4j.io.FSWatchEventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MEDIUM" type="org.spf4j.io.FSWatchEventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOW" type="org.spf4j.io.FSWatchEventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.FSWatchEventSensitivity -->
  <!-- start interface org.spf4j.io.IOConsumer -->
  <interface name="IOConsumer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Consumer"/>
    <method name="acceptEx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.IOConsumer -->
  <!-- start class org.spf4j.io.IOTimeoutException -->
  <class name="IOTimeoutException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOTimeoutException" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMillisAfterDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNanosAfterDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.IOTimeoutException -->
  <!-- start class org.spf4j.io.LazyOutputStreamWrapper -->
  <class name="LazyOutputStreamWrapper" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LazyOutputStreamWrapper" type="java.util.function.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A utility class that allows you to delay any writes made in the constructor of a particular writer (headers).
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.LazyOutputStreamWrapper -->
  <!-- start class org.spf4j.io.MemorizingBufferedInputStream -->
  <class name="MemorizingBufferedInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, int, int, org.spf4j.recyclable.SizedRecyclingSupplier, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getReadBytesFromBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnreadBytesFromBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReadBytes" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <doc>
    <![CDATA[Why another buffered input stream?
 Main use case if for troubleshooting.
 Allows you to get more detail on where your stream processing failed.

 Implementation is a circular byte buffer, where you have 2 sizes to control the behavior:

 buffer size - the total sie of the buffer.
 read size - the maximum number of read bytes kept in the buffer.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.MemorizingBufferedInputStream -->
  <!-- start class org.spf4j.io.NoCloseOutputStream -->
  <class name="NoCloseOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoCloseOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[an OutputStream that will wrap a output stream and not propagate close.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.NoCloseOutputStream -->
  <!-- start class org.spf4j.io.NullWriter -->
  <class name="NullWriter" extends="java.io.Writer"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="java.io.Writer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.NullWriter -->
  <!-- start interface org.spf4j.io.ObjectAppender -->
  <interface name="ObjectAppender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.BiConsumer"/>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the MimeType of the format used to write the Object.
 @return]]>
      </doc>
    </method>
    <method name="append"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write an Object to a char stream.
 @param object
 @param appendTo
 @throws IOException]]>
      </doc>
    </method>
    <method name="appendNullable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendNullableJson"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Method to overwrite for implementing apenders for container objects.]]>
      </doc>
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <field name="TOSTRING_APPENDER" type="org.spf4j.io.ObjectAppender"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A simple Object appender that invokes the toString method of the object and writes the object out.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@author zoly
 @param <T> - type of object to append.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.ObjectAppender -->
  <!-- start interface org.spf4j.io.ObjectAppenderSupplier -->
  <interface name="ObjectAppenderSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <method name="get" return="org.spf4j.io.ObjectAppender"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.spf4j.base.CoreTextMediaType"/>
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="get" return="org.spf4j.io.ObjectAppender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <field name="TO_STRINGER" type="org.spf4j.io.ConfigurableAppenderSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.ObjectAppenderSupplier -->
  <!-- start class org.spf4j.io.PathsIOException -->
  <class name="PathsIOException" extends="java.io.IOException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathsIOException" type="java.nio.file.Path, java.io.IOException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="ex" type="java.io.IOException"/>
    </method>
    <method name="getPaths" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.PathsIOException -->
  <!-- start class org.spf4j.io.PipedOutputStream -->
  <class name="PipedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PipedOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int, long"
      static="false" final="false" visibility="public"
      deprecated="use constructor that takes globalDeadlineNanos.">
      <doc>
      <![CDATA[@deprecated use constructor that takes globalDeadlineNanos.]]>
      </doc>
    </constructor>
    <constructor name="PipedOutputStream" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a PipedOutputStream with a global deadline relative to System.nanoTime().
 @param globalDeadlineNanos deadline relative to System.nanoTime().
 @param bufferSize the buffer size.]]>
      </doc>
    </constructor>
    <constructor name="PipedOutputStream" type="int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int, org.spf4j.recyclable.SizedRecyclingSupplier, java.lang.Long"
      static="false" final="false" visibility="public"
      deprecated="use constructor that takes globalDeadlineNanos.">
      <doc>
      <![CDATA[@deprecated use constructor that takes globalDeadlineNanos.]]>
      </doc>
    </constructor>
    <constructor name="PipedOutputStream" type="java.lang.Long, int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a PipedOutputStream.
 @param globalDeadlineNanos the deadline relative to System.nanoTime().
 @param bufferSize the buffer size in bytes.
 @param bufferProvider a buffer provider. (to allow more efficient recycling)]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getNanoDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeUntil"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeUntil"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ex" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Close this piped output stream, and provide a exception reason.
 Designed to propagate exception details from the consumer to the producer.
 A consumer that reads data from a InputStream connected to this PipedOutpuStream,
 can close this pipe, and provide a exception. THis exception will be used as cause for any
 exceptions thrown by subsequent attempted write operations.
 @param ex the exception to use as root cause.]]>
      </doc>
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnreadBytesFromBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Equivalent to Java piped input/output stream.

 This implementation supports timeouts, timeout are specified by setting in the ExecutionContext

 Implementation supports multiple readers and writers.

 Data is available to readers only after it is flushed. (happens automatically when buffer is full)

 This implementation should be slightly faster than the JDK implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.PipedOutputStream -->
  <!-- start class org.spf4j.io.PipedOutputStream.PipedInputStream -->
  <class name="PipedOutputStream.PipedInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getOutputStream" return="org.spf4j.io.PipedOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readUntil" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readUntil" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="len" type="int"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="deadline" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.PipedOutputStream.PipedInputStream -->
  <!-- start class org.spf4j.io.PushbackInputStreamEx -->
  <class name="PushbackInputStreamEx" extends="java.io.PushbackInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PushbackInputStreamEx" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PushbackInputStreamEx" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnderlyingStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[a extended implementation that improves the safety of unread and provides a better toString.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.PushbackInputStreamEx -->
  <!-- start class org.spf4j.io.PushbackReader -->
  <class name="PushbackReader" extends="java.io.FilterReader"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PushbackReader" type="java.io.Reader, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PushbackReader" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="poff" type="int"/>
      <param name="plen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="ready" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readAheadLimit" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pn" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.PushbackReader -->
  <!-- start class org.spf4j.io.ReaderInputStream -->
  <class name="ReaderInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReaderInputStream" type="java.io.Reader, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new input stream that will encode the characters from {@code reader} into bytes using
 the given character set. Malformed input and unmappable characters will be replaced.

 @param reader input source
 @param charset character set used for encoding chars to bytes
 @param bufferSize size of internal input and output buffers
 @throws IllegalArgumentException if bufferSize is non-positive]]>
      </doc>
    </constructor>
    <constructor name="ReaderInputStream" type="java.io.Reader, java.nio.charset.CharsetEncoder, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new input stream that will encode the characters from {@code reader} into bytes using
 the given character set encoder.

 @param reader input source
 @param encoder character set encoder used for encoding chars to bytes
 @param bufferSize size of internal input and output buffers
 @throws IllegalArgumentException if bufferSize is non-positive]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that converts characters from a {@link Reader} into bytes using an
 arbitrary Charset.

 <p>This is an alternative to copying the data to an {@code OutputStream} via a {@code Writer},
 which is necessarily blocking. By implementing an {@code InputStream} it allows consumers to
 "pull" as much data as they can handle, which is more convenient when dealing with flow
 controlled, async APIs.

 @author Chris Nokleberg

 Notes by Z: THis class in its current state is not ready for prime time. Here is why:
 1) Since it buffers, there needs to be capability to access the unconsumed bytes/chars.
 2) Buffer sizing could be smarter? char buffer and byte buffers are not "byte size equivalent"(just made this up :-))]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ReaderInputStream -->
  <!-- start class org.spf4j.io.SetFilesReadOnlyVisitor -->
  <class name="SetFilesReadOnlyVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.nio.file.FileVisitor"/>
    <constructor name="SetFilesReadOnlyVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="preVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
    </method>
    <method name="visitFile" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="visitFileFailed" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="postVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.spf4j.io.SetFilesReadOnlyVisitor -->
  <!-- start class org.spf4j.io.Streams -->
  <class name="Streams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[see copy(final InputStream is, final OutputStream os, final int buffSize) for detail.

 @param is
 @param os
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="os" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Equivalent to guava ByteStreams.copy, with one special behavior: if is has no bytes immediately available for read,
 the os is flushed prior to the next read that will probably block.

 I believe this behavior will yield better performance in most scenarios. This method also makes use of:
 Arrays.getBytesTmp. THis method should not be invoked from any context making use of Arrays.getBytesTmp.

 @param is
 @param os
 @param buffSize
 @throws IOException]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="os" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <param name="maxBytes" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="asWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <doc>
      <![CDATA[faster variant than guava CharStreams.asWriter.

 @param appendable - the appendable to transform.
 @return - the writer that will write to the appendable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.Streams -->
  <!-- start class org.spf4j.io.WriterOutputStream -->
  <class name="WriterOutputStream" extends="org.spf4j.io.AppendableOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.CharsetDecoder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.
 
 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.CharsetDecoder, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.
 
 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @param bufferSize the size of the output buffer in number of characters
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.
 
 @param writer the target {@link Writer}
 @param charset the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.
 
 @param writer the target {@link Writer}
 @param charset the charset encoding]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.
 
 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.
 
 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding]]>
      </doc>
    </constructor>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#flush()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#close()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="flushOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the output.
 
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[{@link OutputStream} implementation that transforms a byte stream to a
 character stream using a specified character set encoding and writes the resulting
 stream to a {@link Writer}. The stream is transformed using a
 {@link CharsetDecoder} object, guaranteeing that all character set
 encodings supported by the JRE are handled correctly.
 <p>
 The output of the {@link CharsetDecoder} is buffered using a fixed size buffer.
 This implies that the data is written to the underlying {@link Writer} in chunks
 that are no larger than the size of this buffer. By default, the buffer is
 flushed only when it overflows or when {@link #flush()} or {@link #close()}
 is called. In general there is therefore no need to wrap the underlying {@link Writer}
 in a {@link java.io.BufferedWriter}. {@link WriterOutputStream} can also
 be instructed to flush the buffer after each write operation. In this case, all
 available data is written immediately to the underlying {@link Writer}, implying that
 the current position of the {@link Writer} is correlated to the current position
 of the {@link WriterOutputStream}.
 <p>
 {@link WriterOutputStream} implements the inverse transformation of {@link java.io.OutputStreamWriter};
 in the following example, writing to {@code out2} would have the same result as writing to
 {@code out} directly (provided that the byte sequence is legal with respect to the
 character set encoding):
 <pre>
 OutputStream out = ...
 Charset cs = ...
 OutputStreamWriter writer = new OutputStreamWriter(out, cs);
 WriterOutputStream out2 = new WriterOutputStream(writer, cs);</pre>
 {@link WriterOutputStream} implements the same transformation as {@link java.io.InputStreamReader},
 except that the control flow is reversed: both classes transform a byte stream
 into a character stream, but {@link java.io.InputStreamReader} pulls data from the underlying stream,
 while {@link WriterOutputStream} pushes it to the underlying stream.
 <p>
 Note that while there are use cases where there is no alternative to using
 this class, very often the need to use this class is an indication of a flaw
 in the design of the code. This class is typically used in situations where an existing
 API only accepts an {@link OutputStream} object, but where the stream is known to represent
 character data that must be decoded for further use.
 <p>
 Instances of {@link WriterOutputStream} are not thread safe.
 
 @see org.apache.commons.io.input.ReaderInputStream
 
 @since 7.2.25]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.WriterOutputStream -->
</package>
<package name="org.spf4j.log">
  <!-- start class org.spf4j.log.AvroLogRecordImpl -->
  <class name="AvroLogRecordImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.log.Slf4jLogRecord"/>
    <constructor name="AvroLogRecordImpl" type="org.spf4j.base.avro.LogRecord"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AvroLogRecordImpl" type="org.spf4j.base.avro.LogRecord, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toLogRecord" return="org.spf4j.base.avro.LogRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="java.lang.String"/>
      <param name="traceId" type="java.lang.String"/>
    </method>
    <method name="getArguments" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtraArgumentsRaw" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtraArguments" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtraThrowable" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLoggerName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMarker" return="org.slf4j.Marker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessageFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrMessageArguments" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimeStamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimeStampInstant" return="java.time.Instant"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isLogged" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setIsLogged"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="attach"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getAttachments" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasAttachment" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.AvroLogRecordImpl -->
  <!-- start class org.spf4j.log.ExecContextLogger -->
  <class name="ExecContextLogger" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.slf4j.Logger"/>
    <implements name="org.spf4j.base.Wrapper"/>
    <constructor name="ExecContextLogger" type="org.slf4j.Logger"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ExecContextLogger" type="org.spf4j.log.XLog"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="org.spf4j.log.ExecContextLogger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wrapped" type="org.slf4j.Logger"/>
    </method>
    <method name="getWrapped" return="org.slf4j.Logger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="log"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="log" type="org.spf4j.base.avro.LogRecord"/>
    </method>
    <method name="log"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="msg" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
    </method>
    <method name="log"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="org.spf4j.base.ExecutionContext"/>
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="msg" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
    </method>
    <method name="isTraceEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isTraceEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="argArray" type="java.lang.Object[]"/>
    </method>
    <method name="trace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isDebugEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isDebugEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="debug"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isInfoEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isInfoEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="info"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isWarnEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isWarnEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="warn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isErrorEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isErrorEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg" type="java.lang.Object"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arg1" type="java.lang.Object"/>
      <param name="arg2" type="java.lang.Object"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="format" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="error"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="msg" type="java.lang.String"/>
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Execution context aware logger.

 does the following:

 <li>
 1) if Execution context is present, it logs the context id. (relies on Logging back-ends supporting overflow args)
 </li>
 <li>
 2) if Execution context is present, it allows for context aware log level, and upgrades log messages to be logged by
 backend.
 </li>

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.ExecContextLogger -->
  <!-- start class org.spf4j.log.Level -->
  <class name="Level" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.log.Level[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getIntValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getJulLevel" return="java.util.logging.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAvroLevel" return="org.spf4j.base.avro.LogLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fromAvroLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="org.spf4j.base.avro.LogLevel"/>
    </method>
    <method name="fromJulLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="severity" type="int"/>
    </method>
    <field name="TRACE" type="org.spf4j.log.Level"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEBUG" type="org.spf4j.log.Level"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INFO" type="org.spf4j.log.Level"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WARN" type="org.spf4j.log.Level"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERROR" type="org.spf4j.log.Level"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OFF" type="org.spf4j.log.Level"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An enum for log levels
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.Level -->
  <!-- start class org.spf4j.log.LogAttribute -->
  <class name="LogAttribute" extends="org.spf4j.base.Pair"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.JsonWriteable"/>
    <implements name="org.slf4j.Marker"/>
    <constructor name="LogAttribute" type="java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="java.lang.String"/>
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="traceId" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.CharSequence"/>
    </method>
    <method name="profileSamples" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ss" type="org.spf4j.base.StackSamples"/>
    </method>
    <method name="origLevel" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="org.spf4j.log.Level"/>
    </method>
    <method name="origLoggerName" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loggerName" type="java.lang.String"/>
    </method>
    <method name="origTimeStamp" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instant" type="java.time.Instant"/>
    </method>
    <method name="origTimeStamp" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="millisSinceEpoch" type="long"/>
    </method>
    <method name="log" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.spf4j.log.Slf4jLogRecord"/>
    </method>
    <method name="execTimeMicros" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="value" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
      <param name="value" type="long"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeJsonTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeJsonTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gen" type="com.fasterxml.jackson.core.JsonGenerator"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="fromJson" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jsonStr" type="java.lang.CharSequence"/>
    </method>
    <method name="fromMap" return="org.spf4j.log.LogAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="java.util.Map"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="org.slf4j.Marker"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="org.slf4j.Marker"/>
    </method>
    <method name="hasChildren" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasReferences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.slf4j.Marker"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="ID_ATTR_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PROFILE_SAMPLES_ATTR_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.LogAttribute -->
  <!-- start class org.spf4j.log.LogPrinter -->
  <class name="LogPrinter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LogPrinter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LogPrinter" type="java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LogPrinter" type="java.time.format.DateTimeFormatter, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppenderSupplier" return="org.spf4j.io.ConfigurableAppenderSupplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="print" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.spf4j.log.Slf4jLogRecord"/>
      <param name="os" type="java.io.OutputStream"/>
      <param name="errStream" type="java.io.OutputStream"/>
    </method>
    <method name="print"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.spf4j.log.Slf4jLogRecord"/>
      <param name="os" type="java.io.OutputStream"/>
    </method>
    <method name="printToBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.spf4j.log.Slf4jLogRecord"/>
    </method>
    <method name="print"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.spf4j.base.avro.LogRecord"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="printTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="record" type="org.spf4j.log.Slf4jLogRecord"/>
      <param name="annotate" type="java.lang.String"/>
    </method>
    <method name="printTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.OutputStream"/>
      <param name="record" type="org.spf4j.base.avro.LogRecord"/>
      <param name="annotate" type="java.lang.String"/>
    </method>
    <method name="printTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.PrintStream"/>
      <param name="record" type="org.spf4j.log.Slf4jLogRecord"/>
      <param name="annotate" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A log printer. The format is not configurable, and this is intentional.
 create One instance of this printer and re-use it.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.LogPrinter -->
  <!-- start class org.spf4j.log.LogUtils -->
  <class name="LogUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="logUpgrade"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.slf4j.Logger"/>
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="format" type="java.lang.String"/>
      <param name="pargs" type="java.lang.Object[]"/>
    </method>
    <method name="logUpgrade"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="java.util.logging.Logger"/>
      <param name="plevel" type="org.spf4j.log.Level"/>
      <param name="format" type="java.lang.String"/>
      <param name="pargs" type="java.lang.Object[]"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.LogUtils -->
  <!-- start class org.spf4j.log.SLF4JBridgeHandler -->
  <class name="SLF4JBridgeHandler" extends="java.util.logging.Handler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SLF4JBridgeHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Adds a SLF4JBridgeHandler instance to jul's root logger.

 This handler will redirect j.u.l. logging to SLF4J. However, only logs enabled in j.u.l. will be redirected. For
 example, if a log statement invoking a j.u.l. logger is disabled, then the corresponding non-event will
 <em>not</em>
 reach SLF4JBridgeHandler and cannot be redirected.]]>
      </doc>
    </method>
    <method name="uninstall"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes previously installed SLF4JBridgeHandler instances. See also {@link #install()}.

 @throws SecurityException A <code>SecurityException</code> is thrown, if a security manager exists and if the
 caller does not have LoggingPermission("control").]]>
      </doc>
    </method>
    <method name="isInstalled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if SLF4JBridgeHandler has been previously installed, returns false otherwise.

 @return true if SLF4JBridgeHandler is already installed, false other wise
 @throws SecurityException]]>
      </doc>
    </method>
    <method name="removeHandlersForRootLogger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoking this method removes/unregisters/detaches all handlers currently attached to the root logger]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="logEfficient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i18nMessage" type="java.lang.String"/>
      <param name="record" type="java.util.logging.LogRecord"/>
      <param name="slf4jLogger" type="org.slf4j.Logger"/>
    </method>
    <method name="getSourceMethodInfo" return="org.spf4j.base.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="java.util.logging.LogRecord"/>
    </method>
    <method name="publish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="java.util.logging.LogRecord"/>
    </method>
    <doc>
    <![CDATA[<p>
 Bridge/route all JUL log records to the SLF4J API.</p>
 <p>
 Implementation based on jul-to-slf4j bridge but at least 20% faster. Speed improvements come from using spf4j
 improved MessageFormatter + code cleanup. Also unlike jul-to-slf4j the sorce class and source method information is
 not being dropped. </p>
 <p>
 Implementation is interchangeable with the jul-to-slf4j implementation </p>]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.SLF4JBridgeHandler -->
  <!-- start interface org.spf4j.log.Slf4jLogRecord -->
  <interface name="Slf4jLogRecord"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getArguments" return="java.lang.Object[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return all slf4j log arguments, getNrMessageArguments() message arguments followed by additional payload
 like exceptions, or other data.]]>
      </doc>
    </method>
    <method name="getExtraArgumentsRaw" return="java.lang.Object[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return all extra arguments. (arguments that are not parameters for the message)]]>
      </doc>
    </method>
    <method name="getExtraArguments" return="java.lang.Object[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return all non Throwable extra arguments.]]>
      </doc>
    </method>
    <method name="getExtraThrowable" return="java.lang.Throwable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Throwable from extra arguments. If multiple, will return first will all others as suppressed.]]>
      </doc>
    </method>
    <method name="getLevel" return="org.spf4j.log.Level"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLoggerName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMarker" return="org.slf4j.Marker"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessageFormat" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrMessageArguments" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimeStamp" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimeStampInstant" return="java.time.Instant"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isLogged" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates that this log record has been sent to the logging backend to persist.

 @return]]>
      </doc>
    </method>
    <method name="setIsLogged"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="attach"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getAttachments" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasAttachment" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="compareByTimestamp" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="org.spf4j.log.Slf4jLogRecord"/>
      <param name="b" type="org.spf4j.log.Slf4jLogRecord"/>
    </method>
    <method name="toLogRecord" return="org.spf4j.base.avro.LogRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="java.lang.String"/>
      <param name="ptraceId" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.log.Slf4jLogRecord -->
  <!-- start class org.spf4j.log.Slf4jLogRecordImpl -->
  <class name="Slf4jLogRecordImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.JsonWriteable"/>
    <implements name="org.spf4j.log.Slf4jLogRecord"/>
    <constructor name="Slf4jLogRecordImpl" type="java.lang.String, org.spf4j.log.Level, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Slf4jLogRecordImpl" type="java.lang.String, org.spf4j.log.Level, org.slf4j.Marker, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Slf4jLogRecordImpl" type="boolean, java.lang.String, org.spf4j.log.Level, org.slf4j.Marker, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Slf4jLogRecordImpl" type="boolean, java.lang.String, org.spf4j.log.Level, org.slf4j.Marker, long, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLoggerName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLevel" return="org.spf4j.log.Level"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimeStamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMarker" return="org.slf4j.Marker"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessageFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getArguments" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrMessageArguments" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtraArgumentsRaw" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtraArguments" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExtraThrowable" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[can be sub-classed to change the string representation.
 @return]]>
      </doc>
    </method>
    <method name="writeJsonTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[can be sub-classed to change the json representation.
 @return]]>
      </doc>
    </method>
    <method name="isLogged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setIsLogged"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="attach"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hasAttachment" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getAttachments" return="java.util.Set"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.log.Slf4jLogRecordImpl -->
  <!-- start class org.spf4j.log.SLf4jXLogAdapter -->
  <class name="SLf4jXLogAdapter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.log.XLog"/>
    <constructor name="SLf4jXLogAdapter" type="org.slf4j.Logger"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="logUpgrade"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="format" type="java.lang.String"/>
      <param name="pargs" type="java.lang.Object[]"/>
    </method>
    <method name="log"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="format" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="marker" type="org.slf4j.Marker"/>
    </method>
    <method name="getWrapped" return="org.slf4j.Logger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.log.SLf4jXLogAdapter -->
  <!-- start interface org.spf4j.log.XLog -->
  <interface name="XLog"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Wrapper"/>
    <method name="isEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="marker" type="org.slf4j.Marker"/>
      <doc>
      <![CDATA[Is logger enabled for level and marker
 @param level
 @param marker
 @return]]>
      </doc>
    </method>
    <method name="log"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="format" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Log.
 @param marker
 @param level
 @param format
 @param args]]>
      </doc>
    </method>
    <method name="logUpgrade"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="marker" type="org.slf4j.Marker"/>
      <param name="level" type="org.spf4j.log.Level"/>
      <param name="format" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Log with a level that is enabled. (upgrade level until so)
 @param marker
 @param level
 @param format
 @param args]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.log.XLog -->
</package>
<package name="org.spf4j.pool.jdbc">
  <!-- start class org.spf4j.pool.jdbc.JdbcConnectionFactory -->
  <class name="JdbcConnectionFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.RecyclingSupplier.Factory"/>
    <constructor name="JdbcConnectionFactory" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="JdbcConnectionFactory" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="JdbcConnectionFactory" type="java.lang.String, java.lang.String, java.util.Properties, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.sql.Connection"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="validate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.sql.Connection"/>
      <param name="e" type="java.lang.Exception"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.pool.jdbc.JdbcConnectionFactory -->
  <!-- start class org.spf4j.pool.jdbc.PooledDataSource -->
  <class name="PooledDataSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jdbc.DataSourceEx"/>
    <implements name="java.lang.AutoCloseable"/>
    <constructor name="PooledDataSource" type="int, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="PooledDataSource" type="int, int, java.lang.String, java.lang.String, java.util.Properties, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="PooledDataSource" type="int, int, org.spf4j.recyclable.RecyclingSupplier.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="getConnection" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getConnection" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getConnection" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="username" type="java.lang.String"/>
      <param name="password" type="java.lang.String"/>
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="getLogWriter" return="java.io.PrintWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="setLogWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintWriter"/>
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="setLoginTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seconds" type="int"/>
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="getLoginTimeout" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="unwrap" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="isWrapperFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
    </method>
    <method name="getParentLogger" return="java.util.logging.Logger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.pool.jdbc.PooledDataSource -->
</package>
<package name="org.spf4j.jdbc">
  <!-- start interface org.spf4j.jdbc.DataSourceEx -->
  <interface name="DataSourceEx"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.sql.DataSource"/>
    <method name="getConnection" return="java.sql.Connection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[get a JDBC connection.

 @param timeout max time to wait.
 @param unit
 @return null if unable to obtain connection in the provided time.
 @throws java.sql.SQLException]]>
      </doc>
    </method>
    <method name="from" return="org.spf4j.jdbc.DataSourceEx"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ds" type="javax.sql.DataSource"/>
      <param name="maxNrConnections" type="int"/>
      <doc>
      <![CDATA[Create a DataSourceEx from a plain vanilla DataSource.
 This DataDource will be guarded by a semaphore.
 THis is basically will allow you to not wait more than you want when the pool
 has no more connections to provide.
 @param ds
 @param maxNrConnections
 @return]]>
      </doc>
    </method>
    <method name="from" return="org.spf4j.jdbc.DataSourceEx"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ds" type="javax.sql.DataSource"/>
      <param name="sem" type="org.spf4j.concurrent.Semaphore"/>
      <doc>
      <![CDATA[Create a DataSourceEx from a plain vanilla DataSource.
 This DataDource will be guarded by the provided semaphore.

 Using s distributed semaphore can allow you to control nr of conns at a more global level.
 @param maxNrConnections
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jdbc.DataSourceEx -->
  <!-- start class org.spf4j.jdbc.DbType -->
  <class name="DbType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.jdbc.DbType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.jdbc.DbType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getCurrTSSqlFn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dbType" type="org.spf4j.jdbc.DbType"/>
      <exception name="ExceptionInInitializerError" type="java.lang.ExceptionInInitializerError"/>
      <doc>
      <![CDATA[Return the SQL for a current time millis since a EPOCH...

 @param dbType - the database type.
 @return - the sql fragment taht returns the current sql millis.
 @throws ExceptionInInitializerError]]>
      </doc>
    </method>
    <method name="getCurrTSSqlFn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ExceptionInInitializerError" type="java.lang.ExceptionInInitializerError"/>
      <doc>
      <![CDATA[Return the SQL for a current time millis since a EPOCH...

 @param dbType - the database type.
 @return - the sql fragment taht returns the current sql millis.
 @throws ExceptionInInitializerError]]>
      </doc>
    </method>
    <field name="ORACLE" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="H2" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SYBASE_ASE" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SYBASE_IQ" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MSSQL" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MYSQL" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POSTGRES" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COCKROACH_DB" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default database type to use in all jdbc APIs if a DBtype is not provided.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jdbc.DbType -->
  <!-- start class org.spf4j.jdbc.JdbcTemplate -->
  <class name="JdbcTemplate" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JdbcTemplate" type="javax.sql.DataSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="JdbcTemplate" type="javax.sql.DataSource, org.spf4j.failsafe.RetryPolicy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkJdbcObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.CharSequence"/>
    </method>
    <method name="transactOnConnection" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="transactOnConnection" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="transactOnConnectionNonInterrupt" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getTimeoutToDeadlineSeconds" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <exception name="SQLTimeoutException" type="java.sql.SQLTimeoutException"/>
      <doc>
      <![CDATA[@param deadlineNanos the deadline relative to the same as System.nanoTime()
 @return]]>
      </doc>
    </method>
    <method name="getTimeoutToDeadlineSecondsNoEx" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A very simple JdbTemplate.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jdbc.JdbcTemplate -->
</package>
<package name="org.spf4j.os">
  <!-- start class org.spf4j.os.LoggingProcessHandler -->
  <class name="LoggingProcessHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.os.ProcessHandler"/>
    <constructor name="LoggingProcessHandler" type="java.util.logging.Logger"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="started"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.lang.Process"/>
    </method>
    <method name="handleStdOut" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleStdErr" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stderr" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.LoggingProcessHandler -->
  <!-- start class org.spf4j.os.OperatingSystem -->
  <class name="OperatingSystem" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isMacOsx" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isWindows" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOsName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOSMbean" return="java.lang.management.OperatingSystemMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSunJdkOSMBean" return="com.sun.management.OperatingSystemMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnixOsMBean" return="com.sun.management.UnixOperatingSystemMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOpenFileDescriptorCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHostName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxFileDescriptorCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="killProcess" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proc" type="java.lang.Process"/>
      <param name="terminateTimeoutMillis" type="long"/>
      <param name="forceTerminateTimeoutMillis" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="forkExec" return="org.spf4j.os.ProcessResponse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String[]"/>
      <param name="handler" type="org.spf4j.os.ProcessHandler"/>
      <param name="timeoutMillis" type="long"/>
      <param name="terminationTimeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Process execution utility.
 @param <T> type the stdout is reduced to.
 @param <E> type stderr is reduced to.
 @param command the command to execute.
 @param handler handler for child stdin, stdout and stderr. stdout and stderr handling will be done in 2 threads
 from the DefaultExecutor thread pool. while stdin handling will execute in the current thread.
 @param timeoutMillis time to wait for the process to execute.
 @param terminationTimeoutMillis this is the timeout used when trying to terminate the process gracefully.
 @return the response (respCode, stdout reduction, stderr reduction)
 @throws IOException
 @throws InterruptedException
 @throws ExecutionException
 @throws TimeoutException when timeout happens.]]>
      </doc>
    </method>
    <method name="forkExec" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String[]"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="forkExecLog"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String[]"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <field name="MAX_NR_OPENFILES" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility to wrap access to JDK specific Operating system Mbean attributes.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.OperatingSystem -->
  <!-- start interface org.spf4j.os.ProcessHandler -->
  <interface name="ProcessHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleStdOut" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleStdErr" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stderr" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStdIn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stdout" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="started"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.lang.Process"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.os.ProcessHandler -->
  <!-- start class org.spf4j.os.ProcessResponse -->
  <class name="ProcessResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getResponseCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResponseExitCode" return="org.spf4j.base.SysExits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOutput" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getErrOutput" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.ProcessResponse -->
  <!-- start class org.spf4j.os.ProcessUtil -->
  <class name="ProcessUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getPid" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the jvm process ID, -1 if it cannot be figured out.]]>
      </doc>
    </method>
    <method name="getPid" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.lang.Process"/>
    </method>
    <doc>
    <![CDATA[PID is exposed in jdk 9... some of this will go away.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.ProcessUtil -->
  <!-- start class org.spf4j.os.StdOutLineCountProcessHandler -->
  <class name="StdOutLineCountProcessHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.os.ProcessHandler"/>
    <constructor name="StdOutLineCountProcessHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handleStdOut" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.StdOutLineCountProcessHandler -->
  <!-- start class org.spf4j.os.StdOutToStringProcessHandler -->
  <class name="StdOutToStringProcessHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.os.ProcessHandler"/>
    <constructor name="StdOutToStringProcessHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="started"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.lang.Process"/>
    </method>
    <method name="handleStdOut" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stdout" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleStdErr" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stderr" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.StdOutToStringProcessHandler -->
</package>
<package name="org.spf4j.perf.impl">
  <!-- start class org.spf4j.perf.impl.DirectRecorderSource -->
  <class name="DirectRecorderSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <constructor name="DirectRecorderSource" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DirectRecorderSource" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore, org.spf4j.tsdb2.avro.MeasurementType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.DirectRecorderSource -->
  <!-- start class org.spf4j.perf.impl.MeasurementsInfoImpl -->
  <class name="MeasurementsInfoImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementsInfo"/>
    <constructor name="MeasurementsInfoImpl" type="java.lang.Object, java.lang.String, java.lang.String[], java.lang.String[], org.spf4j.tsdb2.avro.MeasurementType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MeasurementsInfoImpl" type="java.lang.Object, java.lang.String, java.lang.String[], java.lang.String[], org.spf4j.tsdb2.avro.Aggregation[], org.spf4j.tsdb2.avro.MeasurementType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMeasurementType" return="org.spf4j.tsdb2.avro.MeasurementType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasuredEntity" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNumberOfMeasurements" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementUnits" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getMeasurementUnit" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getAggregations" return="org.spf4j.tsdb2.avro.Aggregation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementAggregation" return="org.spf4j.tsdb2.avro.Aggregation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.MeasurementsInfoImpl -->
  <!-- start class org.spf4j.perf.impl.NopMeasurementRecorder -->
  <class name="NopMeasurementRecorder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorder"/>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="recordAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
      <param name="timestampMillis" type="long"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.perf.impl.NopMeasurementRecorder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.NopMeasurementRecorder -->
  <!-- start class org.spf4j.perf.impl.NopMeasurementRecorderSource -->
  <class name="NopMeasurementRecorderSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.perf.impl.NopMeasurementRecorderSource"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.NopMeasurementRecorderSource -->
  <!-- start class org.spf4j.perf.impl.NopMeasurementStore -->
  <class name="NopMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="NopMeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.NopMeasurementStore -->
  <!-- start class org.spf4j.perf.impl.ProcessMeasurementStore -->
  <class name="ProcessMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasurementStore" return="org.spf4j.perf.MeasurementStore"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ProcessMeasurementStore -->
  <!-- start class org.spf4j.perf.impl.Quanta -->
  <class name="Quanta" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="Quanta" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Quanta" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIntervalEnd" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntervalStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClosestToZero" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.perf.impl.Quanta"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[this class ordering is based on start Interval ordering]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.Quanta -->
  <!-- start class org.spf4j.perf.impl.RecorderFactory -->
  <class name="RecorderFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasurementStore" return="org.spf4j.perf.MeasurementStore"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use ProcessMeasurementStore.getMeasurementStore() instead.">
      <doc>
      <![CDATA[@return process measurement store instance.
 @deprecated use ProcessMeasurementStore.getMeasurementStore() instead.]]>
      </doc>
    </method>
    <method name="createScalableQuantizedRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="factor" type="int"/>
      <param name="lowerMagnitude" type="int"/>
      <param name="higherMagnitude" type="int"/>
      <param name="quantasPerMagnitude" type="int"/>
      <doc>
      <![CDATA[Create a Quantized Measurement recorder. (see concept at http://dtrace.org/blogs/bmc/2011/02/08/llquantize/ )

 A quantized measurement recorder is appropriate for low overhead measurement recording with good detail
 using quantized data resolution.
 For lower overhead recorder see createScalableMinMaxAvgRecorder.

 example : createScalableQuantizedRecorder("response time", "ms", 60000, 10, -3, 3, 5)
 will aggregate and persist measurements every minute.
 will have the following measurement buckets:

 QNI_-1000, Q-1000_-800, Q-800_-600, Q-600_-400, Q-400_-100, Q-100_-80, Q-80_-60, Q-60_-40, Q-40_-10, Q-10_-8,
 Q-8_-6, Q-6_-4, Q-4_-2, Q-2_0, Q0_2, Q2_4, Q4_6,
 Q6_8, Q8_10, Q10_40, Q40_60, Q60_80, Q80_100, Q100_400, Q400_600, Q600_800, Q800_1000, Q1000_PI

 where A_B equivalent Math notation is [A,B)
 where NI = negative infinity
 where PI is positive infinity

 @param forWhat an object identifying what is being measured, ex: "response time"
 @param unitOfMeasurement the unit of measurement of the measurements, ex "milliseconds"
 @param sampleTimeMillis the sampling (accumulating interval) ex: 60000 for minute level detail.
 @param factor the log factor of the magnitudes, ex: 10 for 0-1,1-10,10-100,100 - 1000 magnitudes.
 @param lowerMagnitude the lowest magnitude. ex: 10 for 10 * factor min bucket limit value.
 @param higherMagnitude th highest magnitude. ex 10 for 10 * factor max bucket limit value.
 @param quantasPerMagnitude number of equally divided measurement buckets per magnitude. ex: 10
 @return a measurement recorder that]]>
      </doc>
    </method>
    <method name="createScalableQuantizedRecorder2" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="factor" type="int"/>
      <param name="lowerMagnitude" type="int"/>
      <param name="higherMagnitude" type="int"/>
      <param name="quantasPerMagnitude" type="int"/>
    </method>
    <method name="createScalableCountingRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="bucketTimeMillis" type="int"/>
      <doc>
      <![CDATA[This will accumulate a sum of all the recorded numbers +
 the number fo record method invocations.
 @param forWhat entity we measure
 @param unitOfMeasurement the unit of measurement
 @param bucketTimeMillis the bucket time in milliseconds.
 @return]]>
      </doc>
    </method>
    <method name="createScalableSimpleCountingRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="bucketTimeMillis" type="int"/>
      <doc>
      <![CDATA[This will accumulate a sum of all the recorded numbers
 @param forWhat entity we measure
 @param unitOfMeasurement the unit of measurement
 @param bucketTimeMillis the bucket time in milliseconds.
 @return]]>
      </doc>
    </method>
    <method name="createScalableMinMaxAvgRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableMinMaxAvgRecorder2" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableQuantizedRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="factor" type="int"/>
      <param name="lowerMagnitude" type="int"/>
      <param name="higherMagnitude" type="int"/>
      <param name="quantasPerMagnitude" type="int"/>
    </method>
    <method name="createScalableQuantizedRecorderSource2" return="org.spf4j.perf.CloseableMeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="factor" type="int"/>
      <param name="lowerMagnitude" type="int"/>
      <param name="higherMagnitude" type="int"/>
      <param name="quantasPerMagnitude" type="int"/>
    </method>
    <method name="createScalableCountingRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableSimpleCountingRecorderSource" return="org.spf4j.perf.CloseableMeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="description" type="java.lang.String"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableSimpleCountingRecorderSource" return="org.spf4j.perf.CloseableMeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableCountingRecorderSource2" return="org.spf4j.perf.CloseableMeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableMinMaxAvgRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.MultiMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measuredEntity" type="java.lang.Object"/>
      <param name="description" type="java.lang.String"/>
      <param name="measurementNames" type="java.lang.String[]"/>
      <param name="measurementUnits" type="java.lang.String[]"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.MultiMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measuredEntity" type="java.lang.Object"/>
      <param name="description" type="java.lang.String"/>
      <param name="measurementNames" type="java.lang.String[]"/>
      <param name="measurementUnits" type="java.lang.String[]"/>
      <param name="type" type="org.spf4j.tsdb2.avro.MeasurementType"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="type" type="org.spf4j.tsdb2.avro.MeasurementType"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="type" type="org.spf4j.tsdb2.avro.MeasurementType"/>
    </method>
    <method name="createDirectRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
    </method>
    <method name="createDirectGraphiteUdpRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="graphiteHost" type="java.lang.String"/>
      <param name="graphitePort" type="int"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="createDirectGraphiteTcpRecorder" return="org.spf4j.perf.CloseableMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="graphiteHost" type="java.lang.String"/>
      <param name="graphitePort" type="int"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <field name="MEASUREMENT_STORE" type="org.spf4j.perf.MeasurementStore"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use ProcessMeasurementStore.getMeasurementStore() instead.">
      <doc>
      <![CDATA[@deprecated use ProcessMeasurementStore.getMeasurementStore() instead.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.RecorderFactory -->
  <!-- start class org.spf4j.perf.impl.ScalableMeasurementRecorder -->
  <class name="ScalableMeasurementRecorder" extends="org.spf4j.perf.impl.acc.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.CloseableMeasurementRecorder"/>
    <implements name="org.spf4j.perf.JmxSupport"/>
    <method name="closeOnShutdown" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementsAsCsv" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurement" return="org.spf4j.perf.TimeSeriesRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ScalableMeasurementRecorder -->
  <!-- start class org.spf4j.perf.impl.ScalableMeasurementRecorderSource -->
  <class name="ScalableMeasurementRecorderSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <implements name="org.spf4j.perf.MeasurementsSource"/>
    <implements name="org.spf4j.perf.CloseableMeasurementRecorderSource"/>
    <implements name="org.spf4j.perf.JmxSupport"/>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
    </method>
    <method name="getEntitiesMeasurements" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitiesMeasurementsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementsAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurements" return="javax.management.openmbean.TabularDataSupport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.ScalableMeasurementRecorderSource -->
</package>
<package name="org.spf4j.avro.zfork">
  <!-- start class org.spf4j.avro.zfork.Yaml -->
  <class name="Yaml" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newParser" return="com.fasterxml.jackson.core.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="FACTORY" type="com.fasterxml.jackson.dataformat.yaml.YAMLFactory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAPPER" type="com.fasterxml.jackson.databind.ObjectMapper"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.avro.zfork.Yaml -->
  <!-- start class org.spf4j.avro.zfork.ZForkAvroAdapter -->
  <class name="ZForkAvroAdapter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.avro.AvroCompatUtils.Adapter"/>
    <constructor name="ZForkAvroAdapter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createField" return="org.apache.avro.Schema.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="doc" type="java.lang.String"/>
      <param name="defaultVal" type="java.lang.Object"/>
      <param name="validateDefault" type="boolean"/>
      <param name="validateName" type="boolean"/>
      <param name="order" type="org.apache.avro.Schema.Field.Order"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="fields" type="java.util.List"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="allowUndefinedLogicalTypes" type="boolean"/>
      <param name="resolver" type="org.spf4j.avro.SchemaResolver"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getYamlDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="parser" type="com.fasterxml.jackson.core.JsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Adapter for the zolyfarkas/avro fork.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.avro.zfork.ZForkAvroAdapter -->
</package>
<package name="org.spf4j.recyclable">
  <!-- start interface org.spf4j.recyclable.BlockingDisposable -->
  <interface name="BlockingDisposable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Disposable"/>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryDispose" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.BlockingDisposable -->
  <!-- start interface org.spf4j.recyclable.Disposable -->
  <interface name="Disposable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="dispose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.Disposable -->
  <!-- start interface org.spf4j.recyclable.Lease -->
  <interface name="Lease"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
    <implements name="java.lang.AutoCloseable"/>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.Lease -->
  <!-- start interface org.spf4j.recyclable.LeaseSupplier -->
  <interface name="LeaseSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
  </interface>
  <!-- end interface org.spf4j.recyclable.LeaseSupplier -->
  <!-- start interface org.spf4j.recyclable.NonValidatingRecyclingSupplier -->
  <interface name="NonValidatingRecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[block until a object is available and return it.

 @return - a object instance returned by this supplier.
 @throws ObjectCreationException - cannot create an object.
 @throws ObjectBorrowException - cannot borrow an object.
 @throws InterruptedException - interrupted.
 @throws TimeoutException - timed out while getting object.]]>
      </doc>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[recycle object.
 @param object - object to recycle.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.NonValidatingRecyclingSupplier -->
  <!-- start interface org.spf4j.recyclable.ObjectBorower -->
  <interface name="ObjectBorower"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Scanable"/>
    <method name="tryRequestReturnObject" return="org.spf4j.base.Either"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Non Blocking method.

 @return Ether object or REQUEST_MADE if was able to notify borrower to return an object, or NONE if not.
 Object.]]>
      </doc>
    </method>
    <method name="tryReturnObjectIfNotInUse" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Non Blocking method.

 @return null or the object if available.
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="tryReturnObjectsIfNotInUse" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Return all objects that are not currently in use.]]>
      </doc>
    </method>
    <method name="tryReturnObjectsIfNotNeededAnymore" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[This method is a cleanup method. The purpose is to recover all borrowed objects before once this borrower will
 never use them anymore...

 @return all objects borrowed]]>
      </doc>
    </method>
    <method name="nevermind" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Notify borower that object has been received back from another borrower.
 return true is indeed object was from here, false otherwise.
 @param object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.ObjectBorower -->
  <!-- start class org.spf4j.recyclable.ObjectBorower.Action -->
  <class name="ObjectBorower.Action" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.recyclable.ObjectBorower.Action[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.recyclable.ObjectBorower.Action"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="REQUEST_MADE" type="org.spf4j.recyclable.ObjectBorower.Action"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NONE" type="org.spf4j.recyclable.ObjectBorower.Action"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectBorower.Action -->
  <!-- start class org.spf4j.recyclable.ObjectBorrowException -->
  <class name="ObjectBorrowException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectBorrowException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectBorrowException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectBorrowException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectBorrowException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectBorrowException -->
  <!-- start class org.spf4j.recyclable.ObjectCreationException -->
  <class name="ObjectCreationException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectCreationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectCreationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectCreationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectCreationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectCreationException -->
  <!-- start class org.spf4j.recyclable.ObjectDisposeException -->
  <class name="ObjectDisposeException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectDisposeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectDisposeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectDisposeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectDisposeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectDisposeException -->
  <!-- start class org.spf4j.recyclable.ObjectReturnException -->
  <class name="ObjectReturnException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectReturnException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectReturnException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectReturnException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectReturnException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectReturnException -->
  <!-- start class org.spf4j.recyclable.RecyclerFactory -->
  <class name="RecyclerFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toLeaseSupplier" return="org.spf4j.recyclable.LeaseSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rs" type="org.spf4j.recyclable.RecyclingSupplier"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.RecyclerFactory -->
  <!-- start interface org.spf4j.recyclable.RecyclingSupplier -->
  <interface name="RecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.NonValidatingRecyclingSupplier"/>
    <implements name="org.spf4j.recyclable.BlockingDisposable"/>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="tryGet" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryGet" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
      <doc>
      <![CDATA[return a object previously borrowed from the pool,
 together with a optional exception in case one was encountered
 while using the object. passing an exception will cause the object
 to be validated and potentially retired from the pool.

 @param object - object to recycle.
 @param e - exception encountered while handling the object. this is useful for the recycle to validate/retire
 object]]>
      </doc>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[recycle object.
 @param object - object to recycle.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Object pool interface.

 My goal is to create a simpler and better object pool interface and implementation.


 @author zoly
 @param <T> - type of recycled objects]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.RecyclingSupplier -->
  <!-- start interface org.spf4j.recyclable.RecyclingSupplier.Factory -->
  <interface name="RecyclingSupplier.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <doc>
      <![CDATA[create the object.

 @return - the created object.
 @throws ObjectCreationException - cannot create object.]]>
      </doc>
    </method>
    <method name="dispose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <doc>
      <![CDATA[Dispose the object.

 @param object - object to dispose.
 @throws ObjectDisposeException - cannot dispose object.]]>
      </doc>
    </method>
    <method name="validate" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Validate the object, return true if valid,
 false of throw an Exception with validation detail otherwise.
 in case of throwing an exception the object is considered invalid.
 @param object - object to validate.
 @param e - exception previously encountered while handling the object.
 @return  - true is object is still valid, false otherwise.
 @throws java.lang.Exception - something happened during validation.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.recyclable.RecyclingSupplier.Factory -->
  <!-- start interface org.spf4j.recyclable.Scanable -->
  <interface name="Scanable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scan" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.recyclable.Scanable.ScanHandler"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Scan through  objects and call handler...
 if handler throws exception scan is not aborted.
 scan is aborted only if handler returns false.
 @param handler - the handler to handle the scanned objects.
 @return - false if scanning is stopped by the handler, true otherwise.
 @throws Exception - whatever exception is thrown during scanning.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly
 @param <T> - type of the objects to scan.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.Scanable -->
  <!-- start interface org.spf4j.recyclable.Scanable.ScanHandler -->
  <interface name="Scanable.ScanHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[method to handle object
 @param object - the scanned object.
 @return true if scan operation is to continue, false otherwise.
 @throws java.lang.Exception - whatever exception this handler needs to throw.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.recyclable.Scanable.ScanHandler -->
  <!-- start interface org.spf4j.recyclable.SizedLeaseSupplier -->
  <interface name="SizedLeaseSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="lease" return="org.spf4j.recyclable.Lease"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.SizedLeaseSupplier -->
  <!-- start interface org.spf4j.recyclable.SizedRecyclingSupplier -->
  <interface name="SizedRecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.SizedRecyclingSupplier -->
  <!-- start interface org.spf4j.recyclable.SizedRecyclingSupplier.Factory -->
  <interface name="SizedRecyclingSupplier.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.recyclable.SizedRecyclingSupplier.Factory -->
  <!-- start interface org.spf4j.recyclable.SmartRecyclingSupplier -->
  <interface name="SmartRecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.BlockingDisposable"/>
    <implements name="org.spf4j.recyclable.Scanable"/>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <doc>
      <![CDATA[Borrow object from pool.
 @param borower
 @return
 @throws InterruptedException
 @throws TimeoutException
 @throws ObjectCreationException]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="tryGet" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryGet" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <doc>
      <![CDATA[Return object to pool.
 @param object
 @param borower]]>
      </doc>
    </method>
    <method name="getSample" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the object sample.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.SmartRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.SupplierException -->
  <class name="SupplierException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SupplierException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SupplierException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SupplierException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SupplierException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.SupplierException -->
  <!-- start class org.spf4j.recyclable.Template -->
  <class name="Template" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Template" type="org.spf4j.recyclable.RecyclingSupplier, org.spf4j.failsafe.RetryPolicy, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doOnSupplied" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="doOnSupplied" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <param name="pool" type="org.spf4j.recyclable.RecyclingSupplier"/>
      <param name="retryPolicy" type="org.spf4j.failsafe.RetryPolicy"/>
      <param name="exClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.recyclable.Template -->
  <!-- start interface org.spf4j.recyclable.UsageProvider -->
  <interface name="UsageProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUsage" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.UsageProvider -->
</package>
<package name="org.spf4j.tsdb2.avro">
</package>
<package name="org.spf4j.io.tcp.proxy">
  <!-- start class org.spf4j.io.tcp.proxy.ProxyBufferTransferHandler -->
  <class name="ProxyBufferTransferHandler" extends="org.spf4j.io.tcp.SelectorEventHandler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProxyBufferTransferHandler" type="org.spf4j.io.tcp.proxy.TransferBuffer, org.spf4j.io.tcp.proxy.TransferBuffer, org.spf4j.io.tcp.proxy.SnifferFactory, java.nio.channels.SocketChannel, java.nio.channels.Selector, java.util.concurrent.ExecutorService, java.util.concurrent.BlockingQueue, org.spf4j.ds.UpdateablePriorityQueue.ElementRef"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialInterestRegistration" return="java.nio.channels.SelectionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
    </method>
    <method name="canRunAsync" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAsync"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sKey" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="skey" type="java.nio.channels.SelectionKey"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.ProxyBufferTransferHandler -->
  <!-- start class org.spf4j.io.tcp.proxy.ProxyClientHandler -->
  <class name="ProxyClientHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.tcp.ClientHandler"/>
    <constructor name="ProxyClientHandler" type="com.google.common.net.HostAndPort, org.spf4j.io.tcp.proxy.SnifferFactory, org.spf4j.io.tcp.proxy.SnifferFactory, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[TCP proxy client handler.
 @param fwdDestination - the destination all connections will be forwarded to.
 @param c2sSnifferFact - create sniffer to be invoked when data is received from client.
 @param s2cSnifferFact - create sniffer to be invoked when data is received from server.
 @param proxyBufferSize - the transmission buffer sizes.
 @param connectTimeoutMillis - The connection timeout.]]>
      </doc>
    </constructor>
    <method name="handle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverSelector" type="java.nio.channels.Selector"/>
      <param name="clientChannel" type="java.nio.channels.SocketChannel"/>
      <param name="exec" type="java.util.concurrent.ExecutorService"/>
      <param name="tasksToRunBySelector" type="java.util.concurrent.BlockingQueue"/>
      <param name="deadlineActions" type="org.spf4j.ds.UpdateablePriorityQueue"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.ProxyClientHandler -->
  <!-- start interface org.spf4j.io.tcp.proxy.Sniffer -->
  <interface name="Sniffer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="received" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.nio.ByteBuffer"/>
      <param name="nrBytes" type="int"/>
      <doc>
      <![CDATA[Invoked on data receive/transmission.
 @param data - the byte buffer containing the data.
 @param nrBytes - number of bytes in the buffer. The data in the buffer is from position-nrBytes to position.
 nrBytes will be -1 on EOF.
 @return new nrReadValue if we aim to mutate buffer, returning -1 will simulate a EOF.]]>
      </doc>
    </method>
    <method name="received" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ex" type="java.io.IOException"/>
      <doc>
      <![CDATA[Allows to intercept read errors and change/suppress them.
 @param ex
 @return A exception you want to propagate, or null in case we do not want to propagate exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.tcp.proxy.Sniffer -->
  <!-- start interface org.spf4j.io.tcp.proxy.SnifferFactory -->
  <interface name="SnifferFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.spf4j.io.tcp.proxy.Sniffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.SocketChannel"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.tcp.proxy.SnifferFactory -->
  <!-- start class org.spf4j.io.tcp.proxy.TransferBuffer -->
  <class name="TransferBuffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TransferBuffer" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.SocketChannel"/>
    </method>
    <method name="write" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.SocketChannel"/>
    </method>
    <method name="transfer" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.nio.channels.SocketChannel"/>
      <param name="out" type="java.nio.channels.SocketChannel"/>
      <param name="buffer" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setIsDataInBufferHook"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isDataInBufferHook" type="java.lang.Runnable"/>
    </method>
    <method name="setIsRoomInBufferHook"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isRoomInBufferHook" type="java.lang.Runnable"/>
    </method>
    <method name="setIncomingSniffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="incomingSniffer" type="org.spf4j.io.tcp.proxy.Sniffer"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.TransferBuffer -->
  <!-- start class org.spf4j.io.tcp.proxy.TransferBuffer.Operation -->
  <class name="TransferBuffer.Operation" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.io.tcp.proxy.TransferBuffer.Operation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.io.tcp.proxy.TransferBuffer.Operation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="READ" type="org.spf4j.io.tcp.proxy.TransferBuffer.Operation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WRITE" type="org.spf4j.io.tcp.proxy.TransferBuffer.Operation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.TransferBuffer.Operation -->
</package>
<package name="org.spf4j.io.compress">
  <!-- start class org.spf4j.io.compress.Compress -->
  <class name="Compress" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="zip" return="java.nio.file.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileOrFolderToCompress" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Zip a file or folder.
 @param fileOrFolderToCompress file or folder to compress.
 @return the Path of the compressed file. It will created in the same folder as the input parent.
 @throws IOException]]>
      </doc>
    </method>
    <method name="zip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileOrFolderToCompress" type="java.nio.file.Path"/>
      <param name="destFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Zip a file or folder.
 @param fileOrFolderToCompress file or folder to compress.
 @param destFile the destination zip file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="zip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileOrFolderToCompress" type="java.nio.file.Path"/>
      <param name="destFile" type="java.nio.file.Path"/>
      <param name="filter" type="java.util.function.Predicate"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Zip a file or folder.
 @param fileOrFolderToCompress file or folder to compress.
 @param destFile the destination zip file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="copyFileAtomic"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.nio.file.Path"/>
      <param name="destinationFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy file atomic.
 file will be written to a tmp file in the destination folder, and atomically renamed (if file system supports)
 @param source
 @param destinationFile
 @throws IOException]]>
      </doc>
    </method>
    <method name="unzip" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unzip a zip archive to same folder.
 @param zipFile
 @return list of unzipped files.
 @throws IOException]]>
      </doc>
    </method>
    <method name="unzip" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <param name="destinationDirectory" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unzip a zip file to a destination folder.
 @param zipFile
 @param destinationDirectory
 @return the list of files that were extracted.
 @throws IOException in case extraction fails for whatever reason.]]>
      </doc>
    </method>
    <method name="unzip" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <param name="destinationDirectory" type="java.nio.file.Path"/>
      <param name="filter" type="java.util.function.Predicate"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unzip a zip file to a destination folder.
 @param zipFile
 @param destinationDirectory
 @return the list of files that were extracted.
 @throws IOException in case extraction fails for whatever reason.]]>
      </doc>
    </method>
    <method name="unzip2" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <param name="destinationDirectory" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unzip2" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <param name="destDir" type="java.nio.file.Path"/>
      <param name="filter" type="java.util.function.Predicate"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.compress.Compress -->
</package>
<package name="org.spf4j.perf.impl.ms.tsdb">
  <!-- start class org.spf4j.perf.impl.ms.tsdb.AvroFileInfo -->
  <class name="AvroFileInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AvroFileInfo" type="java.nio.file.Path, org.apache.avro.file.DataFileWriter, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFilePath" return="java.nio.file.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileWriter" return="org.apache.avro.file.DataFileWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileEpoch" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInitNrRecords" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.AvroFileInfo -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore -->
  <class name="AvroMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="AvroMeasurementStore" type="java.nio.file.Path, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="AvroMeasurementStore" type="java.nio.file.Path, java.lang.String, org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getNrRecords" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="avroFile" type="java.nio.file.Path"/>
      <param name="clasz" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getInfoFile" return="java.nio.file.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDataFile" return="java.nio.file.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor -->
  <class name="AvroMeasurementStore.Compressor" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="SNAPPY" type="org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ZSTANDARD" type="org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStore.Compressor -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStoreReader -->
  <class name="AvroMeasurementStoreReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStoreQuery"/>
    <constructor name="AvroMeasurementStoreReader" type="java.nio.file.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="AvroMeasurementStoreReader" type="java.nio.file.Path, java.nio.file.Path[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="lookupObservationFiles" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="infoFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMeasurements" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="java.util.function.Predicate"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getObservations" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.AvroMeasurementStoreReader -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.TSDBMeasurementStore -->
  <class name="TSDBMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="TSDBMeasurementStore" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTables" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTableAsCsv" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDBWriter" return="org.spf4j.tsdb2.TSDBWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.TSDBMeasurementStore -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.TSDBMeasurementStoreReader -->
  <class name="TSDBMeasurementStoreReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStoreQuery"/>
    <constructor name="TSDBMeasurementStoreReader" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMeasurements" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="java.util.function.Predicate"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMeasurementData" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.apache.avro.Schema"/>
      <param name="from" type="java.time.Instant"/>
      <param name="to" type="java.time.Instant"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getObservations" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.TSDBMeasurementStoreReader -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.TSDBTxtMeasurementStore -->
  <class name="TSDBTxtMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="TSDBTxtMeasurementStore" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[File based store implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.TSDBTxtMeasurementStore -->
</package>
<package name="org.spf4j.failsafe.concurrent">
  <!-- start interface org.spf4j.failsafe.concurrent.ConditionalConsumer -->
  <interface name="ConditionalConsumer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.concurrent.ConditionalConsumer -->
  <!-- start class org.spf4j.failsafe.concurrent.DefaultFailSafeExecutor -->
  <class name="DefaultFailSafeExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="instance" return="org.spf4j.failsafe.concurrent.FailSafeExecutorImpl"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[a default Retry executor.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.concurrent.DefaultFailSafeExecutor -->
  <!-- start interface org.spf4j.failsafe.concurrent.FailSafeExecutor -->
  <interface name="FailSafeExecutor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="execute"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="nrHedges" type="int"/>
      <param name="hedgeDelay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="cfSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="nrHedges" type="int"/>
      <param name="hedgeDelay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="nrHedges" type="int"/>
      <param name="hedgeDelay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="cfSupplier" type="java.util.function.Supplier"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.failsafe.concurrent.FailSafeExecutor -->
  <!-- start class org.spf4j.failsafe.concurrent.FailSafeExecutorImpl -->
  <class name="FailSafeExecutorImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.failsafe.concurrent.FailSafeExecutor"/>
    <constructor name="FailSafeExecutorImpl" type="java.util.concurrent.ExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="initiateClose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="cfSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="nrHedges" type="int"/>
      <param name="hedgeDelay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="submitRx" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
      <param name="nrHedges" type="int"/>
      <param name="hedgeDelay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="cfSupplier" type="java.util.function.Supplier"/>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
      <param name="predicate" type="org.spf4j.failsafe.RetryPredicate"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Executor that will call Callables with retry. This executor cannot be used inside a Completion service.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.concurrent.FailSafeExecutorImpl -->
  <!-- start class org.spf4j.failsafe.concurrent.FutureTask -->
  <class name="FutureTask" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.RunnableFuture"/>
    <constructor name="FutureTask" type="java.util.concurrent.Callable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code FutureTask} that will, upon running, execute the given {@code Callable}.

 @param callable the callable task
 @throws NullPointerException if the callable is null]]>
      </doc>
    </constructor>
    <constructor name="FutureTask" type="java.lang.Runnable, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code FutureTask} that will, upon running, execute the given {@code Runnable}, and arrange that
 {@code get} will return the given result on successful completion.

 @param runnable the runnable task
 @param result the result to return on successful completion. If you don't need a particular result, consider using
 constructions of the form: {@code Future<?> f = new FutureTask<Void>(runnable, null)}
 @throws NullPointerException if the runnable is null]]>
      </doc>
    </constructor>
    <method name="report" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="int"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns result or throws exception for completed task.

 @param s completed state value]]>
      </doc>
    </method>
    <method name="setCallable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.concurrent.Callable"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[@throws CancellationException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@throws CancellationException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Protected method invoked when this task transitions to state {@code isDone} (whether normally or via cancellation).
 The default implementation does nothing. Subclasses may override this method to invoke completion callbacks or
 perform bookkeeping. Note that you can query status inside the implementation of this method to determine whether
 this task has been cancelled.]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="v" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the result of this future to the given value unless this future has already been set or has been cancelled.

 <p>
 This method is invoked internally by the {@link #run} method upon successful completion of the computation.

 @param v the value]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Causes this future to report an {@link ExecutionException} with the given throwable as its cause, unless this
 future has already been set or has been cancelled.

 <p>
 This method is invoked internally by the {@link #run} method upon failure of the computation.

 @param t the cause of failure]]>
      </doc>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAndReset" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Executes the computation without setting its result, and then resets this future to initial state, failing to do so
 if the computation encounters an exception or is cancelled. This is designed for use with tasks that intrinsically
 execute more than once.

 @return {@code true} if successfully run and reset]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A cancellable asynchronous computation. This class provides a base implementation of {@link Future}, with methods to
 start and cancel a computation, query to see if the computation is complete, and retrieve the result of the
 computation. The result can only be retrieved when the computation has completed; the {@code get} methods will block
 if the computation has not yet completed. Once the computation has completed, the computation cannot be restarted or
 cancelled (unless the computation is invoked using {@link #runAndReset}).

 <p>
 A {@code FutureTask} can be used to wrap a {@link Callable} or {@link Runnable} object. Because {@code FutureTask}
 implements {@code Runnable}, a {@code FutureTask} can be submitted to an {@link Executor} for execution.

 <p>
 In addition to serving as a standalone class, this class provides {@code protected} functionality that may be useful
 when creating customized task classes.

 @since 1.5
 @author Doug Lea
 @param <V> The result type returned by this FutureTask's {@code get} methods]]>
    </doc>
  </class>
  <!-- end class org.spf4j.failsafe.concurrent.FutureTask -->
</package>
<package name="org.spf4j.text">
  <!-- start class org.spf4j.text.AttributedString -->
  <class name="AttributedString" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AttributedString" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the given text.
 @param text The text for this attributed string.
 @exception NullPointerException if <code>text</code> is null.]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.lang.String, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the given text and attributes.
 @param text The text for this attributed string.
 @param attributes The attributes that apply to the entire string.
 @exception NullPointerException if <code>text</code> or
            <code>attributes</code> is null.
 @exception IllegalArgumentException if the text has length 0
 and the attributes parameter is not an empty Map (attributes
 cannot be applied to a 0-length range).]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.text.AttributedCharacterIterator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the given attributed
 text represented by AttributedCharacterIterator.
 @param text The text for this attributed string.
 @exception NullPointerException if <code>text</code> is null.]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.text.AttributedCharacterIterator, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the subrange of
 the given attributed text represented by
 AttributedCharacterIterator. If the given range produces an
 empty text, all attributes will be discarded.  Note that any
 attributes wrapped by an Annotation object are discarded for a
 subrange of the original attribute range.

 @param text The text for this attributed string.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last character
 of the range.
 @exception NullPointerException if <code>text</code> is null.
 @exception IllegalArgumentException if the subrange given by
 beginIndex and endIndex is out of the text range.
 @see java.text.Annotation]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.text.AttributedCharacterIterator, int, int, java.text.AttributedCharacterIterator.Attribute[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the subrange of
 the given attributed text represented by
 AttributedCharacterIterator.  Only attributes that match the
 given attributes will be incorporated into the instance. If the
 given range produces an empty text, all attributes will be
 discarded. Note that any attributes wrapped by an Annotation
 object are discarded for a subrange of the original attribute
 range.

 @param text The text for this attributed string.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last character
 of the range.
 @param attributes Specifies attributes to be extracted
 from the text. If null is specified, all available attributes will
 be used.
 @exception NullPointerException if <code>text</code> is null.
 @exception IllegalArgumentException if the subrange given by
 beginIndex and endIndex is out of the text range.
 @see java.text.Annotation]]>
      </doc>
    </constructor>
    <method name="addAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.text.AttributedCharacterIterator.Attribute"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds an attribute to the entire string.
 @param attribute the attribute key
 @param value the value of the attribute; may be null
 @exception NullPointerException if <code>attribute</code> is null.
 @exception IllegalArgumentException if the AttributedString has length 0
 (attributes cannot be applied to a 0-length range).]]>
      </doc>
    </method>
    <method name="addAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.text.AttributedCharacterIterator.Attribute"/>
      <param name="value" type="java.lang.Object"/>
      <param name="beginIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Adds an attribute to a subrange of the string.
 @param attribute the attribute key
 @param value The value of the attribute. May be null.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last character of the range.
 @exception NullPointerException if <code>attribute</code> is null.
 @exception IllegalArgumentException if beginIndex is less then 0, endIndex is
 greater than the length of the string, or beginIndex and endIndex together don't
 define a non-empty subrange of the string.]]>
      </doc>
    </method>
    <method name="addAttributes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributes" type="java.util.Map"/>
      <param name="beginIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Adds a set of attributes to a subrange of the string.
 @param attributes The attributes to be added to the string.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last
 character of the range.
 @exception NullPointerException if <code>attributes</code> is null.
 @exception IllegalArgumentException if beginIndex is less then
 0, endIndex is greater than the length of the string, or
 beginIndex and endIndex together don't define a non-empty
 subrange of the string and the attributes parameter is not an
 empty Map.]]>
      </doc>
    </method>
    <method name="getIterator" return="java.text.AttributedCharacterIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an AttributedCharacterIterator instance that provides access to the entire contents of
 this string.

 @return An iterator providing access to the text and its attributes.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An AttributedString holds text and related attribute information. It
 may be used as the actual data storage in some cases where a text
 reader wants to access attributed text through the AttributedCharacterIterator
 interface.

 <p>
 An attribute is a key/value pair, identified by the key.  No two
 attributes on a given character can have the same key.

 <p>The values for an attribute are immutable, or must not be mutated
 by clients or storage.  They are always passed by reference, and not
 cloned.

 @see AttributedCharacterIterator
 @see Annotation
 @since 1.2]]>
    </doc>
  </class>
  <!-- end class org.spf4j.text.AttributedString -->
  <!-- start class org.spf4j.text.MessageFormat -->
  <class name="MessageFormat" extends="java.text.Format"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MessageFormat" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a FastMessageFormat for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
 specified pattern. The constructor first sets the locale, then parses the pattern and creates a list of subformats
 for the format elements contained in it. Patterns and their interpretation are specified in the
 <a href="#patterns">class description</a>.

 @param pattern the pattern for this message format
 @exception IllegalArgumentException if the pattern is invalid]]>
      </doc>
    </constructor>
    <constructor name="MessageFormat" type="java.lang.String, java.util.Locale"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a FastMessageFormat for the specified locale and pattern. The constructor first sets the locale, then
 parses the pattern and creates a list of sub-formats for the format elements contained in it. Patterns and their
 interpretation are specified in the
 <a href="#patterns">class description</a>.

 @param pattern the pattern for this message format
 @param locale the locale for this message format
 @exception IllegalArgumentException if the pattern is invalid
 @since 1.4]]>
      </doc>
    </constructor>
    <method name="setLocale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="locale" type="java.util.Locale"/>
      <doc>
      <![CDATA[Sets the locale to be used when creating or comparing subformats. This affects subsequent calls
 <ul>
 <li>to the {@link #applyPattern applyPattern} and {@link #toPattern toPattern} methods if format elements specify a
 format type and therefore have the subformats created in the <code>applyPattern</code> method, as well as
 <li>to the <code>format</code> and {@link #formatToCharacterIterator formatToCharacterIterator} methods if format
 elements do not specify a format type and therefore have the subformats created in the formatting methods.
 </ul>
 Subformats that have already been created are not affected.

 @param locale the locale to be used when creating or comparing subformats]]>
      </doc>
    </method>
    <method name="getLocale" return="java.util.Locale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the locale that's used when creating or comparing subformats.

 @return the locale used when creating or comparing subformats]]>
      </doc>
    </method>
    <method name="applyPattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the pattern used by this message format. The method parses the pattern and creates a list of subformats for
 the format elements contained in it. Patterns and their interpretation are specified in the
 <a href="#patterns">class description</a>.

 @param pattern the pattern for this message format
 @exception IllegalArgumentException if the pattern is invalid]]>
      </doc>
    </method>
    <method name="toPattern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a pattern representing the current state of the message format. The string is constructed from internal
 information and therefore does not necessarily equal the previously applied pattern.

 @return a pattern representing the current state of the message format]]>
      </doc>
    </method>
    <method name="setFormatsByArgumentIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newFormats" type="java.text.Format[]"/>
      <doc>
      <![CDATA[Sets the formats to use for the values passed into <code>format</code> methods or returned from <code>parse</code>
 methods. The indices of elements in <code>newFormats</code> correspond to the argument indices used in the
 previously set pattern string. The order of formats in <code>newFormats</code> thus corresponds to the order of
 elements in the <code>arguments</code> array passed to the <code>format</code> methods or the result array returned
 by the <code>parse</code> methods.
 <p>
 If an argument index is used for more than one format element in the pattern string, then the corresponding new
 format is used for all such format elements. If an argument index is not used for any format element in the pattern
 string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the
 formats for argument indices less than <code>newFormats.length</code> are replaced.

 @param newFormats the new formats to use
 @exception NullPointerException if <code>newFormats</code> is null
 @since 1.4]]>
      </doc>
    </method>
    <method name="setFormats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newFormats" type="java.text.Format[]"/>
      <doc>
      <![CDATA[Sets the formats to use for the format elements in the previously set pattern string. The order of formats in
 <code>newFormats</code> corresponds to the order of format elements in the pattern string.
 <p>
 If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats
 are provided than needed, then only the first <code>newFormats.length</code> formats are replaced.
 <p>
 Since the order of format elements in a pattern string often changes during localization, it is generally better to
 use the {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex} method, which assumes an order of formats
 corresponding to the order of elements in the <code>arguments</code> array passed to the <code>format</code>
 methods or the result array returned by the <code>parse</code> methods.

 @param newFormats the new formats to use
 @exception NullPointerException if <code>newFormats</code> is null]]>
      </doc>
    </method>
    <method name="setFormatByArgumentIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argumentIndex" type="int"/>
      <param name="newFormat" type="java.text.Format"/>
      <doc>
      <![CDATA[Sets the format to use for the format elements within the previously set pattern string that use the given argument
 index. The argument index is part of the format element definition and represents an index into the
 <code>arguments</code> array passed to the <code>format</code> methods or the result array returned by the
 <code>parse</code> methods.
 <p>
 If the argument index is used for more than one format element in the pattern string, then the new format is used
 for all such format elements. If the argument index is not used for any format element in the pattern string, then
 the new format is ignored.

 @param argumentIndex the argument index for which to use the new format
 @param newFormat the new format to use
 @since 1.4]]>
      </doc>
    </method>
    <method name="setFormat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="formatElementIndex" type="int"/>
      <param name="newFormat" type="java.text.Format"/>
      <doc>
      <![CDATA[Sets the format to use for the format element with the given format element index within the previously set pattern
 string. The format element index is the zero-based number of the format element counting from the start of the
 pattern string.
 <p>
 Since the order of format elements in a pattern string often changes during localization, it is generally better to
 use the {@link #setFormatByArgumentIndex setFormatByArgumentIndex} method, which accesses format elements based on
 the argument index they specify.

 @param formatElementIndex the index of a format element within the pattern
 @param newFormat the format to use for the specified format element
 @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or larger than the number of
 format elements in the pattern string]]>
      </doc>
    </method>
    <method name="getFormats" return="java.text.Format[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the formats used for the format elements in the previously set pattern string. The order of formats in the
 returned array corresponds to the order of format elements in the pattern string.
 <p>
 Since the order of format elements in a pattern string often changes during localization, it's generally better to
 use the {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex} method, which assumes an order of formats
 corresponding to the order of elements in the <code>arguments</code> array passed to the <code>format</code>
 methods or the result array returned by the <code>parse</code> methods.

 @return the formats used for the format elements in the pattern]]>
      </doc>
    </method>
    <method name="format" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object[]"/>
      <param name="result" type="java.lang.CharSequence"/>
      <param name="pos" type="java.text.FieldPosition"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Formats an array of objects and appends the <code>MessageFormat</code>'s pattern, with format elements replaced by
 the formatted objects, to the provided <code>StringBuffer</code>.
 <p>
 The text substituted for the individual format elements is derived from the current subformat of the format element
 and the <code>arguments</code> element at the format element's argument index as indicated by the first matching
 line of the following table. An argument is <i>unavailable</i> if <code>arguments</code> is <code>null</code> or
 has fewer than argumentIndex+1 elements.

 <table border=1 summary="Examples of subformat,argument,and formatted text">
 <tr>
 <th>Subformat
 <th>Argument
 <th>Formatted Text
 <tr>
 <td><i>any</i>
 <td><i>unavailable</i>
 <td><code>"{" + argumentIndex + "}"</code>
 <tr>
 <td><i>any</i>
 <td><code>null</code>
 <td><code>"null"</code>
 <tr>
 <td><code>instanceof ChoiceFormat</code>
 <td><i>any</i>
 <td><code>subformat.format(argument).indexOf('{') &gt;= 0 ?<br>
 (new MessageFormat(subformat.format(argument), getLocale())).format(argument) : subformat.format(argument)</code>
 <tr>
 <td><code>!= null</code>
 <td><i>any</i>
 <td><code>subformat.format(argument)</code>
 <tr>
 <td><code>null</code>
 <td><code>instanceof Number</code>
 <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>
 <tr>
 <td><code>null</code>
 <td><code>instanceof Date</code>
 <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)</code>
 <tr>
 <td><code>null</code>
 <td><code>instanceof String</code>
 <td><code>argument</code>
 <tr>
 <td><code>null</code>
 <td><i>any</i>
 <td><code>argument.toString()</code>
 </table>
 <p>
 If <code>pos</code> is non-null, and refers to <code>Field.ARGUMENT</code>, the location of the first formatted
 string will be returned.

 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired. On output: the offsets of the alignment field.
 @return the string buffer passed in as {@code result}, with formatted text appended
 @exception IllegalArgumentException if an argument in the <code>arguments</code> array is not of the type expected
 by the format element(s) that use it.]]>
      </doc>
    </method>
    <method name="format" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object[]"/>
      <param name="result" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="format" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Creates a MessageFormat with the given pattern and uses it to format the given arguments. This is equivalent to
 <blockquote>
 <code>(new {@link #MessageFormat(String) MessageFormat}(pattern)).
 {@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments,
 new StringBuffer(), null).toString()</code>
 </blockquote>

 @param pattern the pattern string
 @param arguments object(s) to format
 @return the formatted string
 @exception IllegalArgumentException if the pattern is invalid, or if an argument in the <code>arguments</code>
 array is not of the type expected by the format element(s) that use it.]]>
      </doc>
    </method>
    <method name="format" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object"/>
      <param name="result" type="java.lang.CharSequence"/>
      <param name="pos" type="java.text.FieldPosition"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Formats an array of objects and appends the <code>MessageFormat</code>'s pattern, with format elements replaced by
 the formatted objects, to the provided <code>StringBuffer</code>. This is equivalent to
 <blockquote>
 <code>{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[])
 arguments, result, pos)</code>
 </blockquote>

 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired. On output: the offsets of the alignment field.
 @exception IllegalArgumentException if an argument in the <code>arguments</code> array is not of the type expected
 by the format element(s) that use it.]]>
      </doc>
    </method>
    <method name="formatToCharacterIterator" return="java.text.AttributedCharacterIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object"/>
      <doc>
      <![CDATA[Formats an array of objects and inserts them into the <code>MessageFormat</code>'s pattern, producing an
 <code>AttributedCharacterIterator</code>. You can use the returned <code>AttributedCharacterIterator</code> to
 build the resulting String, as well as to determine information about the resulting String.
 <p>
 The text of the returned <code>AttributedCharacterIterator</code> is the same that would be returned by
 <blockquote>
 <code>{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new
 StringBuffer(), null).toString()</code>
 </blockquote>
 <p>
 In addition, the <code>AttributedCharacterIterator</code> contains at least attributes indicating where text was
 generated from an argument in the <code>arguments</code> array. The keys of these attributes are of type
 <code>MessageFormat.Field</code>, their values are <code>Integer</code> objects indicating the index in the
 <code>arguments</code> array of the argument from which the text was generated.
 <p>
 The attributes/value from the underlying <code>Format</code> instances that <code>MessageFormat</code> uses will
 also be placed in the resulting <code>AttributedCharacterIterator</code>. This allows you to not only find where an
 argument is placed in the resulting String, but also which fields it contains in turn.

 @param arguments an array of objects to be formatted and substituted.
 @return AttributedCharacterIterator describing the formatted value.
 @exception NullPointerException if <code>arguments</code> is null.
 @exception IllegalArgumentException if an argument in the <code>arguments</code> array is not of the type expected
 by the format element(s) that use it.
 @since 1.4]]>
      </doc>
    </method>
    <method name="parse" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <param name="pos" type="java.text.ParsePosition"/>
      <doc>
      <![CDATA[Parses the string.

 <p>
 Caveats: The parse may fail in a number of circumstances. For example:
 <ul>
 <li>If one of the arguments does not occur in the pattern.
 <li>If the format of an argument loses information, such as with a choice format where a large number formats to
 "many".
 <li>Does not yet handle recursion (where the substituted strings contain {n} references.)
 <li>Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the
 pattern "{1},{2}" is used with the string arguments {"a,b", "c"}, it will format as "a,b,c". When the result is
 parsed, it will return {"a", "b,c"}.
 <li>If a single argument is parsed more than once in the string, then the later parse wins.
 </ul>
 When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The
 returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if
 the parsing string "AAA {0} BBB" is comparing against the pattern "AAD {0} BBB", the error index is 0. When an
 error occurs, the call to this method will return null. If the source is null, return an empty array. (zoltan:
 yuck)


 @param source the string to parse
 @param pos the parse position
 @return an array of parsed objects]]>
      </doc>
    </method>
    <method name="parse" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <exception name="ParseException" type="java.text.ParseException"/>
      <doc>
      <![CDATA[Parses text from the beginning of the given string to produce an object array. The method may not use the entire
 text of the given string.
 <p>
 See the {@link #parse(String, ParsePosition)} method for more information on message parsing.

 @param source A <code>String</code> whose beginning should be parsed.
 @return An <code>Object</code> array parsed from the string.
 @exception ParseException if the beginning of the specified string cannot be parsed.]]>
      </doc>
    </method>
    <method name="parseObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <param name="pos" type="java.text.ParsePosition"/>
      <doc>
      <![CDATA[Parses text from a string to produce an object array.
 <p>
 The method attempts to parse text starting at the index given by <code>pos</code>. If parsing succeeds, then the
 index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use
 all characters up to the end of the string), and the parsed object array is returned. The updated <code>pos</code>
 can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of
 <code>pos</code> is not changed, the error index of <code>pos</code> is set to the index of the character where the
 error occurred, and null is returned.
 <p>
 See the {@link #parse(String, ParsePosition)} method for more information on message parsing.

 @param source A <code>String</code>, part of which should be parsed.
 @param pos A <code>ParsePosition</code> object with index and error index information as described above.
 @return An <code>Object</code> array parsed from the string. In case of error, returns null.
 @exception NullPointerException if <code>pos</code> is null.]]>
      </doc>
    </method>
    <method name="clone" return="org.spf4j.text.MessageFormat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates and returns a copy of this object.

 @return a clone of this instance.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Equality comparison between two message format objects]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generates a hash code for the message format object.]]>
      </doc>
    </method>
    <method name="format" return="java.lang.StringBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="toAppendTo" type="java.lang.StringBuffer"/>
      <param name="pos" type="java.text.FieldPosition"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Performance mutation of the JDK message formatter.
 Lots things of things have been done:
 1) reduced the amount of garbage generated during formatting.
 2) made some method invocations static.
 3) made this more flexible and usable against StringBuilder not only StringBuffer...
 4) thrown exceptions provide more detail on what went wrong.
 5) cleaned up lots of static analisys reported issues.

 <code>MessageFormat</code> provides a means to produce concatenated messages in a language-neutral way. Use this to
 construct messages displayed for end users.

 this implementation is based on java.text.MessageFormat with the goal to be a faster and more flexible implementation

 <p>
 <code>MessageFormat</code> takes a set of objects, formats them, then inserts the formatted strings into the pattern
 at the appropriate places.

 <p>
 <strong>Note:</strong>
 <code>MessageFormat</code> differs from the other <code>Format</code> classes in that you create a
 <code>MessageFormat</code> object with one of its constructors (not with a <code>getInstance</code> style factory
 method). The factory methods aren't necessary because <code>MessageFormat</code> itself doesn't implement locale
 specific behavior. Any locale specific behavior is defined by the pattern that you provide as well as the sub-formats
 used for inserted arguments.

 <h3><a name="patterns">Patterns and Their Interpretation</a></h3>

 <code>MessageFormat</code> uses patterns of the following form:
 <blockquote><pre>
 <i>MessageFormatPattern:</i>
         <i>String</i>
         <i>MessageFormatPattern</i> <i>FormatElement</i> <i>String</i>

 <i>FormatElement:</i>
         { <i>ArgumentIndex</i> }
         { <i>ArgumentIndex</i> , <i>FormatType</i> }
         { <i>ArgumentIndex</i> , <i>FormatType</i> , <i>FormatStyle</i> }

 <i>FormatType: one of </i>
         number date time choice

 <i>FormatStyle:</i>
         short
         medium
         long
         full
         integer
         currency
         percent
         <i>SubformatPattern</i>
 </pre></blockquote>

 <p>
 Within a <i>String</i>, a pair of single quotes can be used to quote any arbitrary characters except single quotes.
 For example, pattern string <code>"'{0}'"</code> represents string <code>"{0}"</code>, not a <i>FormatElement</i>. A
 single quote itself must be represented by doubled single quotes {@code ''} throughout a
 <i>String</i>. For example, pattern string <code>"'{''}'"</code> is interpreted as a sequence of <code>'{</code>
 (start of quoting and a left curly brace), <code>''</code> (a single quote), and <code>}'</code> (a right curly brace
 and end of quoting),
 <em>not</em> <code>'{'</code> and <code>'}'</code> (quoted left and right curly braces): representing string
 <code>"{'}"</code>,
 <em>not</em> <code>"{}"</code>.

 <p>
 A <i>SubformatPattern</i> is interpreted by its corresponding sub-format, and sub-format-dependent pattern rules
 apply. For example, pattern string <code>"{1,number,<u>$'#',##</u>}"</code> (<i>SubformatPattern</i> with underline)
 will produce a number format with the pound-sign quoted, with a result such as: {@code
 "$#31,45"}. Refer to each {@code Format} subclass documentation for details.

 <p>
 Any unmatched quote is treated as closed at the end of the given pattern. For example, pattern string {@code "'{0}"}
 is treated as pattern {@code "'{0}'"}.

 <p>
 Any curly braces within an unquoted pattern must be balanced. For example, <code>"ab {0} de"</code> and
 <code>"ab '}' de"</code> are valid patterns, but <code>"ab {0'}' de"</code>, <code>"ab } de"</code> and
 <code>"''{''"</code> are not.

 <dl><dt><b>Warning:</b><dd>The rules for using quotes within message format patterns unfortunately have shown to be
 somewhat confusing. In particular, it isn't always obvious to localizers whether single quotes need to be doubled or
 not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle
 source files) which strings will be processed by {@code MessageFormat}. Note that localizers may need to use single
 quotes in translated strings where the original version doesn't have them.
 </dl>
 <p>
 The <i>ArgumentIndex</i> value is a non-negative integer written using the digits {@code '0'} through {@code '9'},
 and represents an index into the {@code arguments} array passed to the {@code format} methods or the result array
 returned by the {@code parse} methods.
 <p>
 The <i>FormatType</i> and <i>FormatStyle</i> values are used to create a {@code Format} instance for the format
 element. The following table shows how the values map to {@code Format} instances. Combinations not shown in the
 table are illegal. A <i>SubformatPattern</i> must be a valid pattern string for the {@code Format} subclass used.

 <table border=1 summary="Shows how FormatType and FormatStyle values map to Format instances">
 <tr>
 <th id="ft" class="TableHeadingColor">FormatType
 <th id="fs" class="TableHeadingColor">FormatStyle
 <th id="sc" class="TableHeadingColor">Subformat Created
 <tr>
 <td headers="ft"><i>(none)</i>
 <td headers="fs"><i>(none)</i>
 <td headers="sc"><code>null</code>
 <tr>
 <td headers="ft" rowspan=5><code>number</code>
 <td headers="fs"><i>(none)</i>
 <td headers="sc">{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><code>integer</code>
 <td headers="sc">{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><code>currency</code>
 <td headers="sc">{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}
 {@code (getLocale())}
 <tr>
 <td headers="fs"><code>percent</code>
 <td headers="sc">{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new}
 {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,}
 {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
 <tr>
 <td headers="ft" rowspan=6><code>date</code>
 <td headers="fs"><i>(none)</i>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}
 {@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>short</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}
 {@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>medium</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}
 {@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>long</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}
 {@code (}{@link DateFormat#LONG}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>full</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}
 {@code (}{@link DateFormat#FULL}{@code , getLocale())}
 <tr>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new}
 {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 <tr>
 <td headers="ft" rowspan=6><code>time</code>
 <td headers="fs"><i>(none)</i>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}
 {@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>short</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}
 {@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>medium</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}
 {@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>long</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}
 {@code (}{@link DateFormat#LONG}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>full</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}
 {@code (}{@link DateFormat#FULL}{@code , getLocale())}
 <tr>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new}
 {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 <tr>
 <td headers="ft"><code>choice</code>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 </table>

 <h4>Usage Information</h4>

 <p>
 Here are some examples of usage. In real internationalized programs, the message format pattern and other static
 strings will, of course, be obtained from resource bundles. Other parameters will be dynamically determined at
 runtime.
 <p>
 The first example uses the static method <code>MessageFormat.format</code>, which internally creates a
 <code>MessageFormat</code> for one-time use:
 <blockquote><pre>
 int planet = 7;
 String event = "a disturbance in the Force";

 String result = MessageFormat.format(
     "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
     planet, new Date(), event);
 </pre></blockquote>
 The output is:
 <blockquote><pre>
 At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 </pre></blockquote>

 <p>
 The following example creates a <code>MessageFormat</code> instance that can be used repeatedly:
 <blockquote><pre>
 int fileCount = 1273;
 String diskName = "MyDisk";
 Object[] testArgs = {new Long(fileCount), diskName};

 MessageFormat form = new MessageFormat(
     "The disk \"{1}\" contains {0} file(s).");

 System.out.println(form.format(testArgs));
 </pre></blockquote>
 The output with different values for <code>fileCount</code>:
 <blockquote><pre>
 The disk "MyDisk" contains 0 file(s).
 The disk "MyDisk" contains 1 file(s).
 The disk "MyDisk" contains 1,273 file(s).
 </pre></blockquote>

 <p>
 For more sophisticated patterns, you can use a <code>ChoiceFormat</code> to produce correct forms for singular and
 plural:
 <blockquote><pre>
 MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
 double[] filelimits = {0,1,2};
 String[] filepart = {"no files","one file","{0,number} files"};
 ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 form.setFormatByArgumentIndex(0, fileform);

 int fileCount = 1273;
 String diskName = "MyDisk";
 Object[] testArgs = {new Long(fileCount), diskName};

 System.out.println(form.format(testArgs));
 </pre></blockquote>
 The output with different values for <code>fileCount</code>:
 <blockquote><pre>
 The disk "MyDisk" contains no files.
 The disk "MyDisk" contains one file.
 The disk "MyDisk" contains 1,273 files.
 </pre></blockquote>

 <p>
 You can create the <code>ChoiceFormat</code> programmatically, as in the above example, or by using a pattern. See
 {@link ChoiceFormat} for more information.
 <blockquote><pre>{@code
 form.applyPattern(
    "There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.");
 }</pre></blockquote>

 <p>
 <strong>Note:</strong> As we see above, the string produced by a <code>ChoiceFormat</code> in
 <code>MessageFormat</code> is treated as special; occurrences of '{' are used to indicate subformats, and cause
 recursion. If you create both a <code>MessageFormat</code> and <code>ChoiceFormat</code> programmatically (instead of
 using the string patterns), then be careful not to produce a format that recurses on itself, which will cause an
 infinite loop.
 <p>
 When a single argument is parsed more than once in the string, the last match will be the final result of the
 parsing. For example,
 <blockquote><pre>
 MessageFormat mf = new MessageFormat("{0,number,#.##}, {0,number,#.#}");
 Object[] objs = {new Double(3.1415)};
 String result = mf.format( objs );
 // result now equals "3.14, 3.1"
 objs = null;
 objs = mf.parse(result, new ParsePosition(0));
 // objs now equals {new Double(3.1)}
 </pre></blockquote>

 <p>
 Likewise, parsing with a {@code MessageFormat} object using patterns containing multiple occurrences of the same
 argument would return the last match. For example,
 <blockquote><pre>
 MessageFormat mf = new MessageFormat("{0}, {0}, {0}");
 String forParsing = "x, y, z";
 Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 // result now equals {new String("z")}
 </pre></blockquote>

 <h4><a name="synchronization">Synchronization</a></h4>

 <p>
 Message formats are not synchronized. It is recommended to create separate format instances for each thread. If
 multiple threads access a format concurrently, it must be synchronized externally.

 @see java.util.Locale
 @see Format
 @see NumberFormat
 @see DecimalFormat
 @see DecimalFormatSymbols
 @see ChoiceFormat
 @see DateFormat
 @see SimpleDateFormat

 @author Mark Davis]]>
    </doc>
  </class>
  <!-- end class org.spf4j.text.MessageFormat -->
</package>
<package name="org.spf4j.jmx.mappers">
  <!-- start class org.spf4j.jmx.mappers.MapEntryOpenTypeMapping -->
  <class name="MapEntryOpenTypeMapping" extends="com.sun.jmx.mbeanserver.MXBeanMapping"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMapping"/>
    <constructor name="MapEntryOpenTypeMapping" type="java.lang.reflect.ParameterizedType, org.spf4j.jmx.JMXBeanMappingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </constructor>
    <method name="fromOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openValue" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="toOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaValue" type="java.lang.Object"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="getMappedType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.MapEntryOpenTypeMapping -->
  <!-- start class org.spf4j.jmx.mappers.MXBeanMappings -->
  <class name="MXBeanMappings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="com.sun.jmx.mbeanserver.MXBeanMapping"/>
    </method>
    <method name="convert" return="com.sun.jmx.mbeanserver.MXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="org.spf4j.jmx.JMXBeanMapping"/>
    </method>
    <method name="makeOpenClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaType" type="java.lang.reflect.Type"/>
      <param name="openType" type="javax.management.openmbean.OpenType"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.MXBeanMappings -->
  <!-- start class org.spf4j.jmx.mappers.SpecificRecordOpenTypeMapping -->
  <class name="SpecificRecordOpenTypeMapping" extends="com.sun.jmx.mbeanserver.MXBeanMapping"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMapping"/>
    <constructor name="SpecificRecordOpenTypeMapping" type="java.lang.Class, org.spf4j.jmx.JMXBeanMappingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </constructor>
    <method name="fromOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openValue" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="getGenericType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
    </method>
    <method name="toOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaValue" type="java.lang.Object"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="getMappedType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.SpecificRecordOpenTypeMapping -->
  <!-- start class org.spf4j.jmx.mappers.Spf4jOpenTypeMapper -->
  <class name="Spf4jOpenTypeMapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMappingSupplier"/>
    <constructor name="Spf4jOpenTypeMapper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </method>
    <method name="getCache" return="org.spf4j.reflect.CachingTypeMapSupplierWrapper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.Spf4jOpenTypeMapper -->
</package>
<package name="org.spf4j.avro.official">
  <!-- start class org.spf4j.avro.official.OfficialAvroAdapter -->
  <class name="OfficialAvroAdapter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.avro.AvroCompatUtils.Adapter"/>
    <constructor name="OfficialAvroAdapter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createField" return="org.apache.avro.Schema.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="doc" type="java.lang.String"/>
      <param name="defaultVal" type="java.lang.Object"/>
      <param name="validateDefault" type="boolean"/>
      <param name="validateName" type="boolean"/>
      <param name="order" type="org.apache.avro.Schema.Field.Order"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="fields" type="java.util.List"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="allowUndefinedLogicalTypes" type="boolean"/>
      <param name="resolver" type="org.spf4j.avro.SchemaResolver"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="parser" type="com.fasterxml.jackson.core.JsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getYamlDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="reader" type="java.io.Reader"/>
    </method>
    <doc>
    <![CDATA[Adapter for the official library.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.avro.official.OfficialAvroAdapter -->
</package>
<package name="org.spf4j.ds">
  <!-- start class org.spf4j.ds.Graphs -->
  <class name="Graphs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="clone" return="com.google.common.graph.MutableGraph"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.MutableGraph"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.Graphs -->
  <!-- start class org.spf4j.ds.IdentityHashSet -->
  <class name="IdentityHashSet" extends="gnu.trove.set.hash.THashSet"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="IdentityHashSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IdentityHashSet" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IdentityHashSet" type="int, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IdentityHashSet" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
      <param name="two" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class org.spf4j.ds.IdentityHashSet -->
  <!-- start class org.spf4j.ds.LinkedHashMapEx -->
  <class name="LinkedHashMapEx" extends="java.util.LinkedHashMap"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.ds.LinkedMap"/>
    <constructor name="LinkedHashMapEx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="int, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="int, float, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLastEntry" return="java.util.Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastEntry" return="java.util.Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Linked hashmap that allows access to the Last Entry efficiently.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.LinkedHashMapEx -->
  <!-- start class org.spf4j.ds.LinkedHashSetEx -->
  <class name="LinkedHashSetEx" extends="java.util.AbstractSet"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.ds.LinkedSet"/>
    <constructor name="LinkedHashSetEx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashSetEx" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.LinkedHashSetEx -->
  <!-- start interface org.spf4j.ds.LinkedMap -->
  <interface name="LinkedMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map"/>
    <method name="getLastEntry" return="java.util.Map.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastEntry" return="java.util.Map.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.ds.LinkedMap -->
  <!-- start interface org.spf4j.ds.LinkedSet -->
  <interface name="LinkedSet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set"/>
    <method name="getLastValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.ds.LinkedSet -->
  <!-- start class org.spf4j.ds.RTree -->
  <class name="RTree" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="RTree" type="int, int, int, org.spf4j.ds.RTree.SeedPicker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new RTree.

 @param maxEntries maximum number of entries per node
 @param minEntries minimum number of entries per node (except for the root node)
 @param numDims the number of dimensions of the RTree.]]>
      </doc>
    </constructor>
    <constructor name="RTree" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RTree"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new RTree using default parameters: maximum 50 entries per node minimum 2 entries per node 2 dimensions]]>
      </doc>
    </constructor>
    <constructor name="RTree" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMaxEntries" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the maximum number of entries per node]]>
      </doc>
    </method>
    <method name="getMinEntries" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the minimum number of entries per node for all nodes except the root.]]>
      </doc>
    </method>
    <method name="getNumDims" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the number of dimensions of the tree]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the number of items in this tree.]]>
      </doc>
    </method>
    <method name="search" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="dimensions" type="float[]"/>
      <doc>
      <![CDATA[Searches the RTree for objects overlapping with the given rectangle.

 @param coords the corner of the rectangle that is the lower bound of every dimension (eg. the top-left corner)
 @param dimensions the dimensions of the rectangle.
 @return a list of objects whose rectangles overlap with the given rectangle.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="dimensions" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Deletes the entry associated with the given rectangle from the RTree

 @param coords the corner of the rectangle that is the lower bound in every dimension
 @param dimensions the dimensions of the rectangle
 @param entry the entry to delete
 @return true iff the entry was deleted from the RTree.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Empties the RTree]]>
      </doc>
    </method>
    <method name="insert"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="dimensions" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the given entry into the RTree, associated with the given rectangle.

 @param coords the corner of the rectangle that is the lower bound in every dimension
 @param dimensions the dimensions of the rectangle
 @param entry the entry to insert]]>
      </doc>
    </method>
    <method name="insert"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Convenience method for inserting a point

 @param coords
 @param entry]]>
      </doc>
    </method>
    <method name="visualize" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of an arbitrary-dimension RTree. Based on R-Trees: A Dynamic Index Structure for Spatial Searching
 (Antonn Guttmann, 1984)

 This class is not thread-safe. Z TODO: I have cleaned up a bit this class, but there is a lot more to do here this
 class implementation is not clean in several places. (see findbugs supressions)

 @param <T> the type of entry to store in this RTree.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.RTree -->
  <!-- start class org.spf4j.ds.RTree.SeedPicker -->
  <class name="RTree.SeedPicker" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.ds.RTree.SeedPicker[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.ds.RTree.SeedPicker"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="LINEAR" type="org.spf4j.ds.RTree.SeedPicker"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="QUADRATIC" type="org.spf4j.ds.RTree.SeedPicker"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.ds.RTree.SeedPicker -->
  <!-- start class org.spf4j.ds.SimpleStack -->
  <class name="SimpleStack" extends="org.spf4j.ds.SimpleStackNullSupport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleStack" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleStack"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="peek" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[take a look at the top of stack
 returns null if there is no element.
 @return Object]]>
      </doc>
    </method>
    <method name="peekAndPush" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="pollLast" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="pushNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[/**
 A simple stack implementation that does not support null elements.
 @author Zoltan Farkas
 @param <T>]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.SimpleStack -->
  <!-- start class org.spf4j.ds.SimpleStackNullSupport -->
  <class name="SimpleStackNullSupport" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List"/>
    <constructor name="SimpleStackNullSupport" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[construct a stack with specified size]]>
      </doc>
    </constructor>
    <constructor name="SimpleStackNullSupport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a stack, default size is 20]]>
      </doc>
    </constructor>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[check if stack is empty

 @return boolean]]>
      </doc>
    </method>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[push object into stack

 @param o Object]]>
      </doc>
    </method>
    <method name="pushNull"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[pushes a null on top of stack.
 cane be overridden to prohibit operation.]]>
      </doc>
    </method>
    <method name="pushAndGetIdx" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="pushAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Push more objects into the stack

 @param args]]>
      </doc>
    </method>
    <method name="pop" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[pops object out of stack

 @return Object]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pop" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="popTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Object[]"/>
      <param name="n" type="int"/>
    </method>
    <method name="removeFromTop"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="popUntil" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="until" type="java.lang.Object"/>
    </method>
    <method name="hasElements" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[take a look at the top of stack.
 Throws exception if there is no element.

 @return Object]]>
      </doc>
    </method>
    <method name="peekFromTop" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="replaceFromTop"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="peek" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="peekUntil" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="until" type="java.lang.Object"/>
    </method>
    <method name="peekElemAfter" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="until" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the stack - also makes sure the stack objects are not referenced anymore]]>
      </doc>
    </method>
    <method name="getPtr" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the curent stack pos relative to base

 @return]]>
      </doc>
    </method>
    <method name="getFromPtr" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ptr" type="int"/>
      <doc>
      <![CDATA[get element from stack at index relative to base

 @param ptr
 @return]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[returns a character separated string with the stack elements

 @param separator
 @return String]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[to string representation. can be subclassed.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[can be overwritten to optimize.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Can be overwritten for better implementation.
 @param o element to remove.
 @return]]>
      </doc>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[can be overwritten for better implementation.]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="c" type="java.util.Collection"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="set" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="listIterator" return="java.util.ListIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="listIterator" return="java.util.ListIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <method name="subList" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Not implemented, can be overwritten.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple stack implementation that supports null elements.
 @author Zoltan Farkas
 @param <T>]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.SimpleStackNullSupport -->
  <!-- start class org.spf4j.ds.UpdateablePriorityQueue -->
  <class name="UpdateablePriorityQueue" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="UpdateablePriorityQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UpdateablePriorityQueue" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UpdateablePriorityQueue" type="int, java.util.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add" return="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
    </method>
    <method name="peek" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peekEntry" return="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qe" type="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object[]"/>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="heapify"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A priority queue which allows efficient element update.
 Element update can be either a replacement or element mutation.
 Implementation is based on jdk priority queue.
 @author zoly
 @param <E> - the type of the elements in the queue.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.UpdateablePriorityQueue -->
  <!-- start class org.spf4j.ds.UpdateablePriorityQueue.ElementRef -->
  <class name="UpdateablePriorityQueue.ElementRef" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"/>
    </method>
    <method name="getElem" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setElem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.Object"/>
    </method>
    <method name="elementMutated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.ds.UpdateablePriorityQueue.ElementRef -->
</package>
<package name="org.spf4j.jmx">
  <!-- start class org.spf4j.jmx.Client -->
  <class name="Client" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceUrl" type="java.lang.String"/>
      <param name="domain" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attribName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InstanceNotFoundException" type="javax.management.InstanceNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <doc>
      <![CDATA[get a an attribute from a JMX mbean.

 @param serviceUrl in the form of: "service:jmx:rmi:///jndi/rmi://:9999/jmxrmi"
 @param domain - mbean domain name.
 @param mbeanName - mbean name.
 @param attribName - attribute name.
 @return - the attribute value.
 @throws java.io.IOException - IO issue communicating with mbean.
 @throws javax.management.InstanceNotFoundException - mbean not found.
 @throws javax.management.MBeanException - exception while getting the attribute.
 @throws javax.management.AttributeNotFoundException - attribute not found.
 @throws javax.management.ReflectionException - mbean reflection exception.]]>
      </doc>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceUrl" type="java.lang.String"/>
      <param name="domain" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attribName" type="java.lang.String"/>
      <param name="attribValue" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InstanceNotFoundException" type="javax.management.InstanceNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <exception name="InvalidAttributeValueException" type="javax.management.InvalidAttributeValueException"/>
    </method>
    <method name="callOperation" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceUrl" type="java.lang.String"/>
      <param name="domain" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="operationName" type="java.lang.String"/>
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InstanceNotFoundException" type="javax.management.InstanceNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
    </method>
    <doc>
    <![CDATA[Simple Jmx Client utilities.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.Client -->
  <!-- start class org.spf4j.jmx.DynamicMBeanBuilder -->
  <class name="DynamicMBeanBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicMBeanBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newBuilder" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withOperation" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operation" type="org.spf4j.jmx.ExportedOperation"/>
    </method>
    <method name="withAttribute" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="org.spf4j.jmx.ExportedValue"/>
    </method>
    <method name="withAttributes" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vals" type="org.spf4j.jmx.ExportedValue[]"/>
    </method>
    <method name="withAttributes" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapAttributes" type="java.util.Map"/>
    </method>
    <method name="withJmxExportObject" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[add all exported (with @JmxExport) attributes and operations of the object.
 @param object
 @return]]>
      </doc>
    </method>
    <method name="withJmxExportObjects" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[add all exported (with @JmxExport) attributes and operations of the objects.
 @param objects
 @return]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[Build the dynamic mbean.
 @param packageName
 @param mbeanName
 @return dynamic mbean or null if no exportable attributes or operations are present.]]>
      </doc>
    </method>
    <method name="extend" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toExtend" type="org.spf4j.jmx.ExportedValuesMBean"/>
      <doc>
      <![CDATA[Create a dynamic bean with extends the toExtend mbean with the attributes and operations from thsi builder.
 @param toExtend
 @return]]>
      </doc>
    </method>
    <method name="extend" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[extend existing Mbean registered with provided packageName and mbeanName
 @param packageName
 @param mbeanName
 @return null is nothing was registered.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="replace" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[Replace mbean registered with packageName and mbeanName with a mbean constructed by this builder.
 @param packageName
 @param mbeanName
 @return the MBean that was registered.]]>
      </doc>
    </method>
    <method name="replaceIfExports" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
    </method>
    <method name="register" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[register a mbean.
 @param packageName
 @param mbeanName
 @return  and a dinamic bean instance that was registered otherwise.
 @throws InstanceAlreadyExistsException is a instance already exists.]]>
      </doc>
    </method>
    <method name="registerIfExports" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A JMX managed bean Builder.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.DynamicMBeanBuilder -->
  <!-- start interface org.spf4j.jmx.ExportedOperation -->
  <interface name="ExportedOperation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="getParameterInfos" return="javax.management.MBeanParameterInfo[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnType" return="java.lang.Class"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnOpenType" return="javax.management.openmbean.OpenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="org.spf4j.jmx.ExportedOperation"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.ExportedOperation -->
  <!-- start interface org.spf4j.jmx.ExportedValue -->
  <interface name="ExportedValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <exception name="InvalidAttributeValueException" type="javax.management.InvalidAttributeValueException"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="isWriteable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueType" return="java.lang.reflect.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueOpenType" return="javax.management.openmbean.OpenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toAttributeInfo" return="javax.management.MBeanAttributeInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.spf4j.jmx.ExportedValue -->
  <!-- start class org.spf4j.jmx.GenericExportedOperation -->
  <class name="GenericExportedOperation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.ExportedOperation"/>
    <constructor name="GenericExportedOperation" type="java.lang.String, java.lang.String, org.spf4j.base.Invocation, java.lang.reflect.Type[], java.lang.reflect.Type, java.lang.String[], java.lang.String[], boolean[], boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="getParameterInfos" return="javax.management.MBeanParameterInfo[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnOpenType" return="javax.management.openmbean.OpenType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.GenericExportedOperation -->
  <!-- start class org.spf4j.jmx.GenericExportedValue -->
  <class name="GenericExportedValue" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.ExportedValue"/>
    <constructor name="GenericExportedValue" type="java.lang.String, java.lang.String, java.util.function.Supplier, java.util.function.Consumer, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </constructor>
    <constructor name="GenericExportedValue" type="java.lang.String, java.lang.String, java.util.function.Supplier, java.util.function.Consumer, javax.management.openmbean.CompositeType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GenericExportedValue" type="java.lang.String, java.lang.String, java.util.function.Supplier, java.util.function.Consumer, javax.management.openmbean.TabularType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="isWriteable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueOpenType" return="javax.management.openmbean.OpenType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.GenericExportedValue -->
  <!-- start class org.spf4j.jmx.GlobalMXBeanMapperSupplier -->
  <class name="GlobalMXBeanMapperSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.spf4j.jmx.JMXBeanMappingSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="register" return="org.spf4j.jmx.JMXBeanMappingSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newMapper" type="org.spf4j.jmx.JMXBeanMappingSupplier"/>
    </method>
    <method name="getOpenTypeMapping" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </method>
    <method name="getOpenType" return="javax.management.openmbean.OpenType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.GlobalMXBeanMapperSupplier -->
  <!-- start interface org.spf4j.jmx.JMXBeanMapping -->
  <interface name="JMXBeanMapping"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromOpenValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openValue" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
      <doc>
      <![CDATA[convert from open value.
 @param openValue
 @return]]>
      </doc>
    </method>
    <method name="toOpenValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaValue" type="java.lang.Object"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
      <doc>
      <![CDATA[convert to open value.
 @param javaValue
 @return]]>
      </doc>
    </method>
    <method name="getJavaType" return="java.lang.reflect.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 The Java type the open type mapping is mapped to</p>

 @return the Java type that the open type mapping is mapped to.]]>
      </doc>
    </method>
    <method name="getMappedType" return="java.lang.Class"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Jet the mapped java type.
 @return]]>
      </doc>
    </method>
    <method name="getOpenType" return="javax.management.openmbean.OpenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 The Open Type.</p>

 @return the Open Type.]]>
      </doc>
    </method>
    <method name="isSimpleType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A type where the open type class and the java class are the same.
 @return]]>
      </doc>
    </method>
    <field name="NOMAPPING" type="org.spf4j.jmx.JMXBeanMapping"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.JMXBeanMapping -->
  <!-- start interface org.spf4j.jmx.JMXBeanMappingSupplier -->
  <interface name="JMXBeanMappingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <method name="get" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
      <doc>
      <![CDATA[Get a opentype mapping if available.
 @param type the java typ eto lookup open type mapping
 @return the open type mapping (to/from converter) if available.
 @throws NotSerializableException will be thrown if type is a non serializable class (not interface).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.JMXBeanMappingSupplier -->
  <!-- start interface org.spf4j.jmx.JmxExport -->
  <interface name="JmxExport"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return - the name of the operation or attribute or parameter.]]>
      </doc>
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return - the description of the operation attribute or parameter.]]>
      </doc>
    </method>
    <method name="mapOpenType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map to openType the types associated to the exported entity. (or not)
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotation to mark setters and getters of attributes to export via JMX,
 Any other methods that do not respect get/set/is bean naming conventions will be exported as JMX operation.
 Any method parameters annotated with JMXExport allows you to provide names and descriptions to your
 operation parameters.
 Names are inferred from the method names, but can be customized further with JmxExport.value.

 Open type mapping is configurable by registering a new mapper with: GlobalMXBeanMapperSupplier.register
 or modifying the current ones (if supported). The default implementation, Spf4jOpenTypeMapper supports this.
 attribute description can be added to the annotation.

 Classes annotated with this annotation can be exported with Registry.export or DynamicMBeanBuilder

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.JmxExport -->
  <!-- start class org.spf4j.jmx.Registry -->
  <class name="Registry" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="registerMBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
      <param name="mbean" type="java.lang.Object"/>
      <doc>
      <![CDATA[Register MBean, will replace any existing bean.
 @param objectName
 @param mbean
 @return]]>
      </doc>
    </method>
    <method name="registerIfNotExistsMBean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
      <param name="mbean" type="java.lang.Object"/>
    </method>
    <method name="getRegistered" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
    </method>
    <method name="getRegistered" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="registerMBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Class"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Class"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="objects" type="java.lang.Object[]"/>
    </method>
    <method name="exportIfNeeded" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="objects" type="java.lang.Object[]"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use DynamicMBeanBuilder instead.">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attributes" type="java.util.Properties"/>
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@deprecated use DynamicMBeanBuilder instead.]]>
      </doc>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use BynamicMBeanBuilder instead.">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attributes" type="java.util.Map"/>
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@deprecated use BynamicMBeanBuilder instead.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class that allows to easily exportAgg via JMX java beans.

 attributes can be exported as simply as:

       @JmxExport
       public String [][] getMatrix() {
           return matrix.clone();
       }

 for a writable attribute you will need to annotate the setter as well.

 Operations are as simple as:

       @JmxExport(description = "test operation")
       public String doStuff(@JmxExport(value = "what", description = "some param") final String what,
               final String where) {
           return "Doing " + what + " " + where;
       }

 A object annotated as above can be exported via JMX as simple as Registry.export(object).

 The registry utility also allows you to export the content of a Map as JMX attributes:

 Registry.export("package", "beanName", map);

 OpenType conversions are made for all type where this is doable.
 Avro SpecificRecord's are converted to CompositeData Open type.
 OpenType conversions can be enabled/disabled with JmcExport annotation.


 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.Registry -->
</package>
<package name="org.spf4j.base.avro">
  <!-- start class org.spf4j.base.avro.AThrowables -->
  <class name="AThrowables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="org.spf4j.base.avro.RemoteException"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMessageString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="t" type="org.spf4j.base.avro.RemoteException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="org.spf4j.base.avro.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeThrowableDetails"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="org.spf4j.base.avro.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.util.List"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <param name="prefix" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="org.spf4j.base.avro.StackTraceElement"/>
      <param name="previous" type="org.spf4j.base.avro.StackTraceElement"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="commonFrames" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.util.List"/>
      <param name="enclosingTrace" type="java.util.List"/>
    </method>
    <method name="writeMessageString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="t" type="org.spf4j.base.avro.Throwable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.avro.AThrowables -->
  <!-- start interface org.spf4j.base.avro.AvroCloseableIterable -->
  <interface name="AvroCloseableIterable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.avro.AvroContainer"/>
    <implements name="org.spf4j.base.CloseableIterable"/>
    <method name="from" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="it" type="java.lang.Iterable"/>
      <param name="toClose" type="java.io.Closeable"/>
      <param name="elementSchema" type="org.apache.avro.Schema"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.avro.AvroCloseableIterable -->
  <!-- start interface org.spf4j.base.avro.AvroContainer -->
  <interface name="AvroContainer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getElementSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the element schema of the container.
 @return null if schema can be inferred from type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.avro.AvroContainer -->
  <!-- start class org.spf4j.base.avro.Converters -->
  <class name="Converters" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="org.spf4j.base.avro.StackTraceElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement"/>
    </method>
    <method name="convert" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTraces" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="convert" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwables" type="java.lang.Throwable[]"/>
      <param name="seen" type="java.util.Set"/>
    </method>
    <method name="convert" return="org.spf4j.base.avro.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
    </method>
    <method name="convert" return="org.spf4j.base.avro.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="seen" type="java.util.Set"/>
    </method>
    <method name="convert" return="org.spf4j.base.avro.RemoteException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <param name="throwable" type="org.spf4j.base.avro.Throwable"/>
    </method>
    <method name="convert" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="origin" type="java.lang.String"/>
      <param name="traceId" type="java.lang.String"/>
      <param name="logRecords" type="java.util.List"/>
    </method>
    <method name="convert" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="org.spf4j.base.avro.Method"/>
      <param name="node" type="org.spf4j.base.StackSamples"/>
      <param name="parentId" type="int"/>
      <param name="id" type="int"/>
      <param name="handler" type="java.util.function.Consumer"/>
    </method>
    <method name="convert" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackSamples" type="org.spf4j.base.StackSamples"/>
    </method>
    <field name="ROOT" type="org.spf4j.base.avro.Method"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.avro.Converters -->
  <!-- start class org.spf4j.base.avro.MediaTypes -->
  <class name="MediaTypes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="APPLICATION_JSON" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_OCTET_STREAM" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_AVRO" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_AVRO_JSON" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_AVRO_XJSON" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[an optimized json format implemented in zolyfarkas/avro]]>
      </doc>
    </field>
    <field name="TEXT_PLAIN" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TEXT_CSV" type="org.spf4j.base.avro.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.avro.MediaTypes -->
  <!-- start class org.spf4j.base.avro.RemoteException -->
  <class name="RemoteException" extends="org.spf4j.base.RemoteException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RemoteException" type="java.lang.String, org.spf4j.base.avro.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRemoteCause" return="org.spf4j.base.avro.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fillInStackTrace" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override to make up the remote stack trace.
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.avro.RemoteException -->
</package>
<package name="org.spf4j.reflect">
  <!-- start interface org.spf4j.reflect.ByTypeSupplier -->
  <interface name="ByTypeSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.reflect.ByTypeSupplier -->
  <!-- start class org.spf4j.reflect.CachingTypeMapSupplierWrapper -->
  <class name="CachingTypeMapSupplierWrapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <constructor name="CachingTypeMapSupplierWrapper" type="com.google.common.cache.CacheBuilder, org.spf4j.reflect.TypeMap, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CachingTypeMapSupplierWrapper" type="org.spf4j.reflect.TypeMap, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="putIfNotPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="appender" type="org.spf4j.reflect.ByTypeSupplier"/>
    </method>
    <method name="safePut"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="object" type="org.spf4j.reflect.ByTypeSupplier"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="clearCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.reflect.CachingTypeMapSupplierWrapper -->
  <!-- start class org.spf4j.reflect.CachingTypeMapWrapper -->
  <class name="CachingTypeMapWrapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.TypeMap"/>
    <constructor name="CachingTypeMapWrapper" type="com.google.common.cache.CacheBuilder, org.spf4j.reflect.TypeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CachingTypeMapWrapper" type="org.spf4j.reflect.TypeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAll" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <method name="putIfNotPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="appender" type="java.lang.Object"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="getExact" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <method name="replace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <param name="f" type="java.util.function.Function"/>
    </method>
    <method name="clearCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.reflect.CachingTypeMapWrapper -->
  <!-- start class org.spf4j.reflect.GraphTypeMap -->
  <class name="GraphTypeMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.TypeMap"/>
    <constructor name="GraphTypeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GraphTypeMap" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAll" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <method name="putIfNotPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExact" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.reflect.GraphTypeMap -->
  <!-- start interface org.spf4j.reflect.TypeMap -->
  <interface name="TypeMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <method name="getAll" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Get all Objects associated to all unrelated compatible types.

 for example we have Object O of type T a subtype of T1 and T2.
 if this typemap contains Objects mapped to T1 and T2, those 2 objects
 will be returned if T1 and T2 are not related (subtypes of each other)
 if T1 extends T2 the object mapped to the most specific type is returned.

 @param t
 @return]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[get the object associated to a compatible type, only if there is only one.
 @param t
 @return]]>
      </doc>
    </method>
    <method name="getExact" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Get the the Object associated to type.
 @param t
 @return]]>
      </doc>
    </method>
    <method name="putIfNotPresent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Associate object to type if no existing association present.
 @param type
 @param object
 @return]]>
      </doc>
    </method>
    <method name="safePut" return="org.spf4j.reflect.TypeMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Associate object with type. if there is an existing association a exception will be thrown.
 @param type
 @param object]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[remove type association.
 @param type
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Type to Object map.
 association is not 1 - 1. if we have  type1 -> object that if type2 is subtype of type1, also type2 -> object
 this is useful for resolving: ITC_INHERITANCE_TYPE_CHECKING

 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.reflect.TypeMap -->
</package>
<package name="org.spf4j.avro">
  <!-- start class org.spf4j.avro.AvroCompatUtils -->
  <class name="AvroCompatUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createField" return="org.apache.avro.Schema.Field"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="doc" type="java.lang.String"/>
      <param name="defaultVal" type="java.lang.Object"/>
      <param name="validateDefault" type="boolean"/>
      <param name="validateName" type="boolean"/>
      <param name="order" type="org.apache.avro.Schema.Field.Order"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="fields" type="java.util.List"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAdapter" return="org.spf4j.avro.AvroCompatUtils.Adapter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A set of Utils to abstract away differences between zolyfarkas/avro forrk and apache/avro
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.avro.AvroCompatUtils -->
  <!-- start interface org.spf4j.avro.AvroCompatUtils.Adapter -->
  <interface name="AvroCompatUtils.Adapter"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parseSchema" return="org.apache.avro.Schema"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseSchema" return="org.apache.avro.Schema"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="allowUndefinedLogicalTypes" type="boolean"/>
      <param name="resolver" type="org.spf4j.avro.SchemaResolver"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createField" return="org.apache.avro.Schema.Field"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="doc" type="java.lang.String"/>
      <param name="defaultVal" type="java.lang.Object"/>
      <param name="validateDefault" type="boolean"/>
      <param name="validateName" type="boolean"/>
      <param name="order" type="org.apache.avro.Schema.Field.Order"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="fields" type="java.util.List"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="createRecordSchema" return="org.apache.avro.Schema"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="doc" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="isError" type="boolean"/>
      <param name="validateName" type="boolean"/>
    </method>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonEncoder" return="org.apache.avro.io.Encoder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="os" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getJsonDecoder" return="org.apache.avro.io.Decoder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="parser" type="com.fasterxml.jackson.core.JsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getYamlDecoder" return="org.apache.avro.io.Decoder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writerSchema" type="org.apache.avro.Schema"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.avro.AvroCompatUtils.Adapter -->
  <!-- start class org.spf4j.avro.Configs -->
  <class name="Configs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="schemaResolver" type="org.spf4j.avro.SchemaResolver"/>
      <param name="reader" type="java.io.Reader[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="override" return="com.fasterxml.jackson.databind.JsonNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="com.fasterxml.jackson.databind.JsonNode"/>
      <param name="defaults" type="com.fasterxml.jackson.databind.JsonNode"/>
      <param name="targetSchema" type="org.apache.avro.Schema"/>
    </method>
    <method name="getMatchingSchema" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="com.fasterxml.jackson.databind.JsonNode"/>
      <param name="schemas" type="java.util.List"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseHeader" return="org.spf4j.avro.Configs.ConfigHeader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="rSchema" type="org.apache.avro.Schema"/>
      <param name="schemaResolver" type="org.spf4j.avro.SchemaResolver"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="schemaResolver" type="org.spf4j.avro.SchemaResolver"/>
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Utilities to read Objects from configuration files enforced via json/yaml files.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.avro.Configs -->
  <!-- start class org.spf4j.avro.Configs.ConfigHeader -->
  <class name="Configs.ConfigHeader" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigHeader" type="org.apache.avro.Schema, java.io.Reader, com.google.common.net.MediaType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getwSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The reader with the content of the config. (header component was consumed)
 @return]]>
      </doc>
    </method>
    <method name="getMediaType" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.avro.Configs.ConfigHeader -->
  <!-- start interface org.spf4j.avro.SchemaResolver -->
  <interface name="SchemaResolver"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="customWrite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="gen" type="com.fasterxml.jackson.core.JsonGenerator"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Lower level resolver implementation, that will write a schema in a "custom way"
 @param schema
 @param gen
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="customRead" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.util.function.Function"/>
      <doc>
      <![CDATA[Lowere level resolver implementation that will read a schema from a "custom way"
 @param object
 @return the resolved schema, or null if nothing to resolve.]]>
      </doc>
    </method>
    <method name="getJsonAttrName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="resolveSchema" return="org.apache.avro.Schema"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
    </method>
    <method name="getId" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
    </method>
    <field name="NONE" type="org.spf4j.avro.SchemaResolver"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.avro.SchemaResolver -->
</package>
<package name="org.spf4j.io.appenders.json">
  <!-- start class org.spf4j.io.appenders.json.ArrayBooleanJsonAppender -->
  <class name="ArrayBooleanJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayBooleanJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="boolean[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="boolean[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayBooleanJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayBytesJsonAppender -->
  <class name="ArrayBytesJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayBytesJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="byte[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="byte[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayBytesJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayCharsJsonAppender -->
  <class name="ArrayCharsJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayCharsJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="char[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="char[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayCharsJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayDoubleJsonAppender -->
  <class name="ArrayDoubleJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayDoubleJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="double[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="double[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayDoubleJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayFloatJsonAppender -->
  <class name="ArrayFloatJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayFloatJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="float[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="float[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayFloatJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayIntJsonAppender -->
  <class name="ArrayIntJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayIntJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="int[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="int[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayIntJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayLongJsonAppender -->
  <class name="ArrayLongJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayLongJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="long[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="long[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayLongJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ArrayObjectJsonAppender -->
  <class name="ArrayObjectJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ArrayObjectJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="java.lang.Object[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object[]"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ArrayObjectJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.CollectionJsonAppender -->
  <class name="CollectionJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="CollectionJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iter" type="java.util.Collection"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.util.Collection"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.CollectionJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.GenericRecordJsonAppender -->
  <class name="GenericRecordJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="GenericRecordJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[extends if needed for another type]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.apache.avro.generic.GenericRecord"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.GenericRecordJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.JsonWriteableAppender -->
  <class name="JsonWriteableAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="JsonWriteableAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.base.JsonWriteable"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.JsonWriteableAppender -->
  <!-- start class org.spf4j.io.appenders.json.MapJsonAppender -->
  <class name="MapJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="MapJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.util.Map"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.MapJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.NumberJsonAppender -->
  <class name="NumberJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="NumberJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override for plain text.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="nr" type="java.lang.Number"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Number"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.NumberJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.SampleNodeWriteableAppender -->
  <class name="SampleNodeWriteableAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SampleNodeWriteableAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.SampleNodeWriteableAppender -->
  <!-- start class org.spf4j.io.appenders.json.SpecificRecordBaseJsonAppender -->
  <class name="SpecificRecordBaseJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SpecificRecordBaseJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[extends if needed for another type]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.apache.avro.specific.SpecificRecordBase"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This is to disambiguate the choice between SpecificRecord and GenericRecord.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.SpecificRecordBaseJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.SpecificRecordJsonAppender -->
  <class name="SpecificRecordJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SpecificRecordJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[extends if needed for another type]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.apache.avro.specific.SpecificRecord"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.SpecificRecordJsonAppender -->
  <!-- start class org.spf4j.io.appenders.json.ThrowableJsonAppender -->
  <class name="ThrowableJsonAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="ThrowableJsonAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppendedType" return="org.spf4j.base.CoreTextMediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[extends if needed for another type]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Throwable"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <param name="appenderSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Throwable"/>
      <param name="appendTo" type="java.lang.Appendable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.json.ThrowableJsonAppender -->
</package>
<package name="org.spf4j.perf">
  <!-- start interface org.spf4j.perf.CloseableMeasurementRecorder -->
  <interface name="CloseableMeasurementRecorder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorder"/>
    <implements name="java.lang.AutoCloseable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.CloseableMeasurementRecorder -->
  <!-- start interface org.spf4j.perf.CloseableMeasurementRecorderSource -->
  <interface name="CloseableMeasurementRecorderSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <implements name="java.lang.AutoCloseable"/>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.CloseableMeasurementRecorderSource -->
  <!-- start interface org.spf4j.perf.JmxSupport -->
  <interface name="JmxSupport"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="registerJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[a java object that exposes JMX attributes and operations.
 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.JmxSupport -->
  <!-- start interface org.spf4j.perf.MeasurementAccumulator -->
  <interface name="MeasurementAccumulator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorder"/>
    <method name="get" return="long[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return null when no measurements have been made.]]>
      </doc>
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[reset this entity.

 @return a clone of the object prior to reset or null if no measurements have been made.]]>
      </doc>
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCompositeData" return="javax.management.openmbean.CompositeDataSupport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return null if no measurements have been made.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementAccumulator -->
  <!-- start interface org.spf4j.perf.MeasurementRecorder -->
  <interface name="MeasurementRecorder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="increment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increment measurement by one.]]>
      </doc>
    </method>
    <method name="record"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
      <doc>
      <![CDATA[record a measurement for current time. System.currentTimeMillis().
 @param measurement the measurement value]]>
      </doc>
    </method>
    <method name="recordAt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long"/>
      <doc>
      <![CDATA[Point in time value recording.
 @param timestampMillis
 @param measurement]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to record a measurement tuple (timestamp, long value)
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementRecorder -->
  <!-- start interface org.spf4j.perf.MeasurementRecorderSource -->
  <interface name="MeasurementRecorderSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <doc>
      <![CDATA[do not hold onto the returned recorder.
 the returned recorder should never cross Thread boundaries.
 @param forWhat - Object to get a recorder for.
 @return - measurement recorder.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for measurement recorders.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementRecorderSource -->
  <!-- start interface org.spf4j.perf.MeasurementsInfo -->
  <interface name="MeasurementsInfo"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasuredEntity" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementNames" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementUnits" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAggregations" return="org.spf4j.tsdb2.avro.Aggregation[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getMeasurementUnit" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getMeasurementAggregation" return="org.spf4j.tsdb2.avro.Aggregation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getNumberOfMeasurements" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementType" return="org.spf4j.tsdb2.avro.MeasurementType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toCompositeType" return="javax.management.openmbean.CompositeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementsInfo -->
  <!-- start interface org.spf4j.perf.MeasurementsSource -->
  <interface name="MeasurementsSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEntitiesMeasurements" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitiesMeasurementsAndReset" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementsSource -->
  <!-- start interface org.spf4j.perf.MeasurementStore -->
  <interface name="MeasurementStore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="alocateMeasurements" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementInfo" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make any allocations necessary for the following measurements.

 @param measurementInfo - the information about the measurement(s)
 @param sampleTimeMillis - the expected sample time. (interval between the stored measurements).
 @return - the id of the measurementInfo table.
 @throws IOException - IO issues.]]>
      </doc>
    </method>
    <method name="saveMeasurements"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Save measurements.

 @param tableId - the table ID to store measurements for.
 @param timeStampMillis - the timestamp of the measurement (milliseconds since Jan 1 1970 UTC)
 @param measurements - the measurements to persist. (same order as declared)
 @throws IOException - IO issues.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[flush all data that might be buffered by this store.

 @throws IOException - IO issues.]]>
      </doc>
    </method>
    <method name="query" return="org.spf4j.perf.MeasurementStoreQuery"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return a query-able interface for the store.
 Not all stores will be directly query-able, like most remote stores.
 This method will apply usually only to node local stores.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A measurement store.

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementStore -->
  <!-- start interface org.spf4j.perf.MeasurementStoreQuery -->
  <interface name="MeasurementStoreQuery"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasurements" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="java.util.function.Predicate"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getObservations" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getObservations" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.apache.avro.Schema"/>
      <param name="from" type="java.time.Instant"/>
      <param name="to" type="java.time.Instant"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAggregatedObservations" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.apache.avro.Schema"/>
      <param name="from" type="java.time.Instant"/>
      <param name="to" type="java.time.Instant"/>
      <param name="aggFreq" type="int"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMeasurementData" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.apache.avro.Schema"/>
      <param name="from" type="java.time.Instant"/>
      <param name="to" type="java.time.Instant"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Query measurement data.
 @param measurement
 @param from
 @param to
 @return data iterable
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAggregatedMeasurementData" return="org.spf4j.base.avro.AvroCloseableIterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.apache.avro.Schema"/>
      <param name="from" type="java.time.Instant"/>
      <param name="to" type="java.time.Instant"/>
      <param name="aggFreq" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementStoreQuery -->
  <!-- start class org.spf4j.perf.MeasurmentStoreUtils -->
  <class name="MeasurmentStoreUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="toRecord" return="org.spf4j.perf.TimeSeriesRecord"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rSchema" type="org.apache.avro.Schema"/>
      <param name="tsMillis" type="long"/>
      <param name="row" type="long[]"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.MeasurmentStoreUtils -->
  <!-- start interface org.spf4j.perf.MultiMeasurementRecorder -->
  <interface name="MultiMeasurementRecorder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="record"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long[]"/>
    </method>
    <method name="recordAt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MultiMeasurementRecorder -->
  <!-- start class org.spf4j.perf.PerformanceMonitor -->
  <class name="PerformanceMonitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="callAndMonitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="callAndMonitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="callAndMonitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.spf4j.perf.MeasurementRecorder"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.PerformanceMonitor -->
  <!-- start class org.spf4j.perf.ProcessVitals -->
  <class name="ProcessVitals" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="get" return="org.spf4j.perf.ProcessVitals"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOrCreate" return="org.spf4j.perf.ProcessVitals"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOrCreate" return="org.spf4j.perf.ProcessVitals"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openFilesSampleTimeMillis" type="int"/>
      <param name="memoryUseSampleTimeMillis" type="int"/>
      <param name="gcUseSampleTimeMillis" type="int"/>
      <param name="threadUseSampleTimeMillis" type="int"/>
      <param name="cpuUseSampleTimeMillis" type="int"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility to collect process vitals. (cpu, memory, ...)
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.ProcessVitals -->
  <!-- start class org.spf4j.perf.TimeSeriesAggregatingIterator -->
  <class name="TimeSeriesAggregatingIterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <constructor name="TimeSeriesAggregatingIterator" type="java.lang.Iterable, java.util.function.ToLongFunction, java.util.function.BiConsumer, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.TimeSeriesAggregatingIterator -->
  <!-- start interface org.spf4j.perf.TimeSeriesRecord -->
  <interface name="TimeSeriesRecord"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.generic.GenericRecord"/>
    <method name="getTimeStamp" return="java.time.Instant"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLongValue" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="column" type="java.lang.String"/>
    </method>
    <method name="getDoubleValue" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="column" type="java.lang.String"/>
    </method>
    <method name="getFrequencyMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
    </method>
    <method name="getUnit" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
    </method>
    <method name="from" return="org.spf4j.perf.TimeSeriesRecord"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rec" type="org.apache.avro.generic.GenericRecord"/>
    </method>
    <method name="accumulate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r2" type="org.spf4j.perf.TimeSeriesRecord"/>
      <doc>
      <![CDATA[Temporary, until better implementation.
 @param accumulator
 @param r2]]>
      </doc>
    </method>
    <method name="accumulateObservations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recSchema" type="org.apache.avro.Schema"/>
      <param name="r1" type="org.spf4j.tsdb2.avro.Observation"/>
      <param name="r2" type="org.spf4j.tsdb2.avro.Observation"/>
    </method>
    <method name="inferAggregationFromName" return="org.spf4j.tsdb2.avro.Aggregation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nf" type="org.apache.avro.Schema.Field"/>
      <param name="recSchema" type="org.apache.avro.Schema"/>
    </method>
    <field name="MEASUREMENT_TYPE_PROP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AGGREGATION_TYPE_PROP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNIT_TYPE_PROP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FREQ_MILLIS_REC_PROP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RAW_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IDS_PROP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.TimeSeriesRecord -->
</package>

</api>
